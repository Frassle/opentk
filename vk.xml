<?xml version="1.0" encoding="UTF-8"?>
<registry>
    <comment>
Copyright (c) 2015 The Khronos Group Inc.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and/or associated documentation files (the
"Materials"), to deal in the Materials without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Materials, and to
permit persons to whom the Materials are furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Materials.

THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.

------------------------------------------------------------------------

This file, vk.xml, is the Vulkan API Registry.
    </comment>

    <!-- SECTION: Vulkan type definitions -->
    <types>
        <type name="vk_platform" category="include">#include "vk_platform.h"</type>

        <type category="define">#define <name>VK_MAKE_VERSION</name>(major, minor, patch) \
    ((major &lt;&lt; 22) | (minor &lt;&lt; 12) | patch)</type>

        <type category="define">// Vulkan API version supported by this file
#define <name>VK_API_VERSION</name> <type>VK_MAKE_VERSION</type>(0, 144, 0)</type>

        <type category="define">
#define <name>VK_DEFINE_HANDLE</name>(obj) typedef struct obj##_T* obj;</type>
        <type category="define">
#if defined(__cplusplus)
    #if ((defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1800) || __cplusplus &gt;= 201103L)
        // The bool operator only works if there are no implicit conversions from an obj to
        // a bool-compatible type, which can then be used to unintentionally violate type safety.
        // C++11 and above supports the "explicit" keyword on conversion operators to stop this
        // from happening. Otherwise users of C++ below C++11 won't get direct access to evaluating
        // the object handle as a bool in expressions like:
        //     if (obj) vkDestroy(obj);
        #define VK_NONDISP_HANDLE_OPERATOR_BOOL() explicit operator bool() const { return handle != 0; }
    #else
        #define VK_NONDISP_HANDLE_OPERATOR_BOOL()
    #endif
    #define <name>VK_DEFINE_NONDISP_HANDLE</name>(obj) \
        struct obj { \
            obj() { } \
            obj(uint64_t x) { handle = x; } \
            obj&amp; operator =(uint64_t x) { handle = x; return *this; } \
            bool operator==(const obj&amp; other) const { return handle == other.handle; } \
            bool operator!=(const obj&amp; other) const { return handle != other.handle; } \
            bool operator!() const { return !handle; } \
            VK_NONDISP_HANDLE_OPERATOR_BOOL() \
            uint64_t handle; \
        };
#else
    #define VK_DEFINE_NONDISP_HANDLE(obj) typedef struct obj##_T { uint64_t handle; } obj;
#endif
        </type>

        <type requires="vk_platform" name="VkDeviceSize"/>
        <type requires="vk_platform" name="VkSampleMask"/>
        <type requires="vk_platform" name="VkFlags"/>
        <!-- Basic C types, pulled in via vk_platform.h -->
        <type requires="vk_platform" name="char"/>
        <type requires="vk_platform" name="float"/>
        <type requires="vk_platform" name="VkBool32"/>
        <type requires="vk_platform" name="uint8_t"/>
        <type requires="vk_platform" name="uint32_t"/>
        <type requires="vk_platform" name="uint64_t"/>
        <type requires="vk_platform" name="int32_t"/>
        <type requires="vk_platform" name="size_t"/>
        <!-- Bitfield types -->
        <type requires="VkDeviceCreateFlagBits"           category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceCreateFlags</name>;</type>                <!-- Device creation flags -->
        <type requires="VkQueueFlagBits"                  category="bitmask">typedef <type>VkFlags</type> <name>VkQueueFlags</name>;</type>                       <!-- Queue capabilities -->
        <type requires="VkMemoryPropertyFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryPropertyFlags</name>;</type>              <!-- Memory properties passed into vkAllocMemory(). -->
        <type requires="VkMemoryHeapFlagBits"             category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryHeapFlags</name>;</type>                  <!-- Memory heap flags -->
        <type requires="VkMemoryOutputFlagBits"           category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryOutputFlags</name>;</type>                <!-- Memory output flags passed to resource transition commands -->
        <type requires="VkMemoryInputFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryInputFlags</name>;</type>                 <!-- Memory input flags passed to resource transition commands -->
        <type requires="VkBufferUsageFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkBufferUsageFlags</name>;</type>                 <!-- Buffer usage flags -->
        <type requires="VkBufferCreateFlagBits"           category="bitmask">typedef <type>VkFlags</type> <name>VkBufferCreateFlags</name>;</type>                <!-- Buffer creation flags -->
        <type requires="VkShaderStageFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkShaderStageFlags</name>;</type>                 <!-- Shader stage flags -->
        <type requires="VkImageUsageFlagBits"             category="bitmask">typedef <type>VkFlags</type> <name>VkImageUsageFlags</name>;</type>                  <!-- Image usage flags -->
        <type requires="VkImageCreateFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkImageCreateFlags</name>;</type>                 <!-- Image creation flags -->
        <type requires="VkAttachmentViewCreateFlagBits"   category="bitmask">typedef <type>VkFlags</type> <name>VkAttachmentViewCreateFlags</name>;</type>        <!-- Framebuffer attachment view creation flags -->
        <type requires="VkPipelineCreateFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCreateFlags</name>;</type>              <!-- Pipeline creation flags -->
        <type requires="VkChannelFlagBits"                category="bitmask">typedef <type>VkFlags</type> <name>VkChannelFlags</name>;</type>                     <!-- Channel flags -->
        <type requires="VkFenceCreateFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkFenceCreateFlags</name>;</type>                 <!-- Fence creation flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkSemaphoreCreateFlags</name>;</type>             <!-- Semaphore creation flags -->
        <type requires="VkFormatFeatureFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkFormatFeatureFlags</name>;</type>               <!-- Format capability flags -->
        <type requires="VkQueryControlFlagBits"           category="bitmask">typedef <type>VkFlags</type> <name>VkQueryControlFlags</name>;</type>                <!-- Query control flags -->
        <type requires="VkQueryResultFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkQueryResultFlags</name>;</type>                 <!-- Query result flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkShaderModuleCreateFlags</name>;</type>          <!-- Shader module creation flags (no bits yet) -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkShaderCreateFlags</name>;</type>                <!-- Shader creation flags (no bits yet) -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkEventCreateFlags</name>;</type>                 <!-- Event creation flags  (no bits yet) -->
        <type requires="VkCmdPoolCreateFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkCmdPoolCreateFlags</name>;</type>               <!-- Command pool creation flags -->
        <type requires="VkCmdPoolResetFlagBits"           category="bitmask">typedef <type>VkFlags</type> <name>VkCmdPoolResetFlags</name>;</type>                <!-- Command pool reset flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkCmdBufferCreateFlags</name>;</type>             <!-- Command buffer creation flags (no bits yet) -->
        <type requires="VkCmdBufferResetFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkCmdBufferResetFlags</name>;</type>                <!-- Command buffer reset flags -->
        <type requires="VkCmdBufferOptimizeFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkCmdBufferOptimizeFlags</name>;</type>           <!-- Command buffer optimization flags -->
        <type requires="VkQueryPipelineStatisticFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkQueryPipelineStatisticFlags</name>;</type>      <!-- Pipeline statistics flags -->
        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryMapFlags</name>;</type>                   <!-- Memory mapping flags (no bits yet) -->
        <type requires="VkImageAspectFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkImageAspectFlags</name>;</type>                 <!-- Bitfield of image aspects -->
        <type requires="VkSparseMemoryBindFlagBits"       category="bitmask">typedef <type>VkFlags</type> <name>VkSparseMemoryBindFlags</name>;</type>            <!-- Sparse memory bind flags -->
        <type requires="VkSparseImageFormatFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkSparseImageFormatFlags</name>;</type>           <!-- Sparse image memory requirements flags -->
        <type requires="VkSubpassDescriptionFlagBits"     category="bitmask">typedef <type>VkFlags</type> <name>VkSubpassDescriptionFlags</name>;</type>          <!-- Subpass description flags -->
        <type requires="VkPipelineStageFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineStageFlags</name>;</type>               <!-- Pipeline stages -->

        <!-- Types which can be void pointers or class pointers, selected at compile time -->
        <type category="handle"><type>VK_DEFINE_HANDLE</type>(<name>VkInstance</name>)</type>
        <type category="handle">VK_DEFINE_HANDLE(<name>VkPhysicalDevice</name>)</type>
        <type category="handle">VK_DEFINE_HANDLE(<name>VkDevice</name>)</type>
        <type category="handle">VK_DEFINE_HANDLE(<name>VkQueue</name>)</type>
        <type category="handle">VK_DEFINE_HANDLE(<name>VkCmdBuffer</name>)</type>
        <type category="handle"><type>VK_DEFINE_NONDISP_HANDLE</type>(<name>VkDeviceMemory</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkCmdPool</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkBuffer</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkBufferView</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkImage</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkImageView</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkAttachmentView</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkShaderModule</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkShader</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkPipeline</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkPipelineLayout</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkSampler</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkDescriptorSet</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkDescriptorSetLayout</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkDescriptorPool</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkDynamicViewportState</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkDynamicRasterState</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkDynamicColorBlendState</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkDynamicDepthStencilState</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkFence</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkSemaphore</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkEvent</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkQueryPool</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkFramebuffer</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkRenderPass</name>)</type>
        <type category="handle">VK_DEFINE_NONDISP_HANDLE(<name>VkPipelineCache</name>)</type>

        <!-- Types generated from corresponding <enums> tags below -->
        <type name="VkAttachmentLoadOp" category="enum"/>
        <type name="VkAttachmentStoreOp" category="enum"/>
        <type name="VkAttachmentViewCreateFlagBits" category="enum"/>
        <type name="VkBlend" category="enum"/>
        <type name="VkBlendOp" category="enum"/>
        <type name="VkBorderColor" category="enum"/>
        <type name="VkBufferCreateFlagBits" category="enum"/>
        <type name="VkBufferUsageFlagBits" category="enum"/>
        <type name="VkBufferViewType" category="enum"/>
        <type name="VkChannelFlagBits" category="enum"/>
        <type name="VkChannelSwizzle" category="enum"/>
        <type name="VkCmdPoolCreateFlagBits" category="enum"/>
        <type name="VkCmdPoolResetFlagBits" category="enum"/>
        <type name="VkCmdBufferResetFlagBits" category="enum"/>
        <type name="VkCmdBufferLevel" category="enum"/>
        <type name="VkCmdBufferOptimizeFlagBits" category="enum"/>
        <type name="VkCompareOp" category="enum"/>
        <type name="VkCullMode" category="enum"/>
        <type name="VkDescriptorPoolUsage" category="enum"/>
        <type name="VkDescriptorSetUsage" category="enum"/>
        <type name="VkDescriptorType" category="enum"/>
        <type name="VkDeviceCreateFlagBits" category="enum"/>
        <type name="VkFenceCreateFlagBits" category="enum"/>
        <type name="VkFillMode" category="enum"/>
        <type name="VkFormat" category="enum"/>
        <type name="VkFormatFeatureFlagBits" category="enum"/>
        <type name="VkFrontFace" category="enum"/>
        <type name="VkImageAspect" category="enum"/>
        <type name="VkImageAspectFlagBits" category="enum"/>
        <type name="VkImageCreateFlagBits" category="enum"/>
        <type name="VkImageLayout" category="enum"/>
        <type name="VkImageTiling" category="enum"/>
        <type name="VkImageType" category="enum"/>
        <type name="VkImageUsageFlagBits" category="enum"/>
        <type name="VkImageViewType" category="enum"/>
        <type name="VkSharingMode" category="enum"/>
        <type name="VkIndexType" category="enum"/>
        <type name="VkLogicOp" category="enum"/>
        <type name="VkMemoryHeapFlagBits" category="enum"/>
        <type name="VkMemoryInputFlagBits" category="enum"/>
        <type name="VkMemoryOutputFlagBits" category="enum"/>
        <type name="VkMemoryPropertyFlagBits" category="enum"/>
        <type name="VkPhysicalDeviceType" category="enum"/>
        <type name="VkPipelineBindPoint" category="enum"/>
        <type name="VkPipelineCreateFlagBits" category="enum"/>
        <type name="VkPrimitiveTopology" category="enum"/>
        <type name="VkQueryControlFlagBits" category="enum"/>
        <type name="VkQueryPipelineStatisticFlagBits" category="enum"/>
        <type name="VkQueryResultFlagBits" category="enum"/>
        <type name="VkQueryType" category="enum"/>
        <type name="VkQueueFlagBits" category="enum"/>
        <type name="VkRenderPassContents" category="enum"/>
        <type name="VkResult" category="enum"/>
        <type name="VkShaderStage" category="enum"/>
        <type name="VkShaderStageFlagBits" category="enum"/>
        <type name="VkStencilOp" category="enum"/>
        <type name="VkStructureType" category="enum"/>
        <type name="VkSubpassDescriptionFlagBits" category="enum"/>
        <type name="VkSystemAllocType" category="enum"/>
        <type name="VkTexAddress" category="enum"/>
        <type name="VkTexFilter" category="enum"/>
        <type name="VkTexMipmapMode" category="enum"/>
        <type name="VkTimestampType" category="enum"/>
        <type name="VkVertexInputStepRate" category="enum"/>
        <type name="VkPipelineStageFlagBits" category="enum"/>
        <type name="VkSparseMemoryBindFlagBits" category="enum"/>
        <type name="VkSparseImageFormatFlagBits" category="enum"/>

        <!-- The PFN_vk*Function types are used by VkAllocCallbacks below -->
        <type>typedef void* (VKAPI *<name>PFN_vkAllocFunction</name>)(
    void*                           pUserData,
    size_t                          size,
    size_t                          alignment,
    <type>VkSystemAllocType</type>               allocType);</type>
        <type>typedef void (VKAPI *<name>PFN_vkFreeFunction</name>)(
    void*                           pUserData,
    void*                           pMem);</type>

        <!-- The PFN_vkVoidFunction type are used by VkGet*ProcAddr below -->
        <type>typedef void (VKAPI *<name>PFN_vkVoidFunction</name>)(void);</type>
        <!-- Struct types -->
        <type category="struct" name="VkOffset2D">
            <member><type>int32_t</type>        <name>x</name></member>
            <member><type>int32_t</type>        <name>y</name></member>
        </type>
        <type category="struct" name="VkOffset3D">
            <member><type>int32_t</type>        <name>x</name></member>
            <member><type>int32_t</type>        <name>y</name></member>
            <member><type>int32_t</type>        <name>z</name></member>
        </type>
        <type category="struct" name="VkExtent2D">
            <member><type>int32_t</type>        <name>width</name></member>
            <member><type>int32_t</type>        <name>height</name></member>
        </type>
        <type category="struct" name="VkExtent3D">
            <member><type>int32_t</type>        <name>width</name></member>
            <member><type>int32_t</type>        <name>height</name></member>
            <member><type>int32_t</type>        <name>depth</name></member>
        </type>
        <type category="struct" name="VkViewport">
            <member><type>float</type>          <name>originX</name></member>
            <member><type>float</type>          <name>originY</name></member>
            <member><type>float</type>          <name>width</name></member>
            <member><type>float</type>          <name>height</name></member>
            <member><type>float</type>          <name>minDepth</name></member>
            <member><type>float</type>          <name>maxDepth</name></member>
        </type>
        <type category="struct" name="VkRect2D">
            <member><type>VkOffset2D</type>     <name>offset</name></member>
            <member><type>VkExtent2D</type>     <name>extent</name></member>
        </type>
        <type category="struct" name="VkRect3D">
            <member><type>VkOffset3D</type>     <name>offset</name></member>
            <member><type>VkExtent3D</type>     <name>extent</name></member>
        </type>
        <type category="struct" name="VkChannelMapping">
            <member><type>VkChannelSwizzle</type> <name>r</name></member>
            <member><type>VkChannelSwizzle</type> <name>g</name></member>
            <member><type>VkChannelSwizzle</type> <name>b</name></member>
            <member><type>VkChannelSwizzle</type> <name>a</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceProperties">
            <member><type>uint32_t</type>       <name>apiVersion</name></member>
            <member><type>uint32_t</type>       <name>driverVersion</name></member>
            <member><type>uint32_t</type>       <name>vendorId</name></member>
            <member><type>uint32_t</type>       <name>deviceId</name></member>
            <member><type>VkPhysicalDeviceType</type> <name>deviceType</name></member>
            <member><type>char</type>           <name>deviceName</name>[<enum>VK_MAX_PHYSICAL_DEVICE_NAME</enum>]</member>
            <member><type>uint8_t</type>        <name>pipelineCacheUUID</name>[<enum>VK_UUID_LENGTH</enum>]</member>
        </type>
        <type category="struct" name="VkExtensionProperties">
            <member><type>char</type>            <name>extName</name>[<enum>VK_MAX_EXTENSION_NAME</enum>]</member> <!-- extension name -->
            <member><type>uint32_t</type>        <name>specVersion</name></member>                    <!-- version of the extension specification implemented -->
        </type>
        <type category="struct" name="VkLayerProperties">
            <member><type>char</type>            <name>layerName</name>[<enum>VK_MAX_EXTENSION_NAME</enum>]</member> <!-- layer name -->
            <member><type>uint32_t</type>        <name>specVersion</name></member>                    <!-- version of the layer specification implemented -->
            <member><type>uint32_t</type>        <name>implVersion</name></member>                    <!-- build or release version of the layer's library -->
            <member><type>char</type>      <name>description</name>[<enum>VK_MAX_DESCRIPTION</enum>]</member> <!-- Free-form description of the layer -->
        </type>
        <type category="struct" name="VkApplicationInfo">
            <member><type>VkStructureType</type> <name>sType</name></member>                          <!-- Type of structure. Should be VK_STRUCTURE_TYPE_APPLICATION_INFO -->
            <member>const void*                  <name>pNext</name></member>                          <!-- Next structure in chain -->
            <member>const <type>char</type>*     <name>pAppName</name></member>
            <member><type>uint32_t</type>        <name>appVersion</name></member>
            <member>const <type>char</type>*     <name>pEngineName</name></member>
            <member><type>uint32_t</type>        <name>engineVersion</name></member>
            <member><type>uint32_t</type>        <name>apiVersion</name></member>
        </type>
        <type category="struct" name="VkAllocCallbacks">
            <member>void*                        <name>pUserData</name></member>
            <member><type>PFN_vkAllocFunction</type> <name>pfnAlloc</name></member>
            <member><type>PFN_vkFreeFunction</type> <name>pfnFree</name></member>
        </type>
        <type category="struct" name="VkDeviceQueueCreateInfo">
            <member><type>uint32_t</type>        <name>queueFamilyIndex</name></member>
            <member><type>uint32_t</type>        <name>queueCount</name></member>
        </type>
        <type category="struct" name="VkDeviceCreateInfo">
            <member><type>VkStructureType</type> <name>sType</name></member>                          <!-- Should be VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO -->
            <member>const void*                  <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>uint32_t</type>        <name>queueRecordCount</name></member>
            <member>const <type>VkDeviceQueueCreateInfo</type>* <name>pRequestedQueues</name></member>
            <member><type>uint32_t</type>               <name>layerCount</name></member>
            <member>const <type>char</type>*const*      <name>ppEnabledLayerNames</name></member>            <!-- Ordered list of layer names to be enabled -->
            <member><type>uint32_t</type>               <name>extensionCount</name></member>
            <member>const <type>char</type>*const*      <name>ppEnabledExtensionNames</name></member>
            <member>const <type>VkPhysicalDeviceFeatures</type>* <name>pEnabledFeatures</name></member>
            <member><type>VkDeviceCreateFlags</type>    <name>flags</name></member>                          <!-- Device creation flags -->
        </type>
        <type category="struct" name="VkInstanceCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Should be VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member>const <type>VkApplicationInfo</type>* <name>pAppInfo</name></member>
            <member>const <type>VkAllocCallbacks</type>* <name>pAllocCb</name></member>
            <member><type>uint32_t</type>               <name>layerCount</name></member>
            <member>const <type>char</type>*const*      <name>ppEnabledLayerNames</name></member>            <!-- Ordered list of layer names to be enabled -->
            <member><type>uint32_t</type>               <name>extensionCount</name></member>
            <member>const <type>char</type>*const*      <name>ppEnabledExtensionNames</name></member>        <!-- Extension names to be enabled -->
        </type>
        <type category="struct" name="VkQueueFamilyProperties">
            <member><type>VkQueueFlags</type>           <name>queueFlags</name></member>                     <!-- Queue flags -->
            <member><type>uint32_t</type>               <name>queueCount</name></member>
            <member><type>VkBool32</type>               <name>supportsTimestamps</name></member>
        </type>
        <type category="struct" name="VkPhysicalDeviceMemoryProperties">
            <member><type>uint32_t</type>               <name>memoryTypeCount</name></member>
            <member><type>VkMemoryType</type>           <name>memoryTypes</name>[<enum>VK_MAX_MEMORY_TYPES</enum>]</member>
            <member><type>uint32_t</type>               <name>memoryHeapCount</name></member>
            <member><type>VkMemoryHeap</type>           <name>memoryHeaps</name>[<enum>VK_MAX_MEMORY_HEAPS</enum>]</member>
        </type>
        <type category="struct" name="VkMemoryAllocInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_MEMORY_ALLOC_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkDeviceSize</type>           <name>allocationSize</name></member>                 <!-- Size of memory allocation -->
            <member><type>uint32_t</type>               <name>memoryTypeIndex</name></member>                <!-- Index of the of the memory type to allocate from -->
        </type>
        <type category="struct" name="VkMemoryRequirements">
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>alignment</name></member>                      <!-- Specified in bytes -->
            <member><type>uint32_t</type>               <name>memoryTypeBits</name></member>                 <!-- Bitfield of the allowed memory type indices into memoryTypes[] for this object -->
        </type>
        <type category="struct" name="VkSparseImageFormatProperties">
            <member><type>VkImageAspect</type>          <name>aspect</name></member>
            <member><type>VkExtent3D</type>             <name>imageGranularity</name></member>
            <member><type>VkSparseImageFormatFlags</type> <name>flags</name></member>
        </type>
        <type category="struct" name="VkSparseImageMemoryRequirements">
            <member><type>VkSparseImageFormatProperties</type> <name>formatProps</name></member>
            <member><type>uint32_t</type>               <name>imageMipTailStartLOD</name></member>
            <member><type>VkDeviceSize</type>           <name>imageMipTailSize</name></member>               <!-- Specified in bytes, must be a multiple of image block size / alignment -->
            <member><type>VkDeviceSize</type>           <name>imageMipTailOffset</name></member>             <!-- Specified in bytes, must be a multiple of image block size / alignment -->
            <member><type>VkDeviceSize</type>           <name>imageMipTailStride</name></member>             <!-- Specified in bytes, must be a multiple of image block size / alignment -->
        </type>
        <type category="struct" name="VkMemoryType">
            <member><type>VkMemoryPropertyFlags</type>  <name>propertyFlags</name></member>                  <!-- Memory properties of this memory type -->
            <member><type>uint32_t</type>               <name>heapIndex</name></member>                      <!-- Index of the memory heap allocations of this memory type are taken from -->
        </type>
        <type category="struct" name="VkMemoryHeap">
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Available memory in the heap-->
            <member><type>VkMemoryHeapFlags</type>      <name>flags</name></member>                          <!-- Flags for the heap-->
        </type>
        <type category="struct" name="VkMappedMemoryRange">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkDeviceMemory</type>         <name>mem</name></member>                            <!-- Mapped memory object -->
            <member><type>VkDeviceSize</type>           <name>offset</name></member>                         <!-- Offset within the mapped memory the range starts from -->
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Size of the range within the mapped memory -->
        </type>
        <type category="struct" name="VkFormatProperties">
            <member><type>VkFormatFeatureFlags</type>   <name>linearTilingFeatures</name></member>           <!-- Format features in case of linear tiling -->
            <member><type>VkFormatFeatureFlags</type>   <name>optimalTilingFeatures</name></member>          <!-- Format features in case of optimal tiling -->
        </type>
        <type category="struct" name="VkImageFormatProperties">
            <member><type>uint64_t</type>               <name>maxResourceSize</name></member>                <!-- max size (in bytes) of this resource type -->
            <member><type>uint32_t</type>               <name>maxSamples</name></member>                     <!-- max sample count for this resource type -->
        </type>
        <type category="struct" name="VkDescriptorInfo">
            <member><type>VkBufferView</type>           <name>bufferView</name></member>                     <!-- Buffer view to write to the descriptor (in case it's a buffer descriptor, otherwise should be VK_NULL_HANDLE) -->
            <member><type>VkSampler</type>              <name>sampler</name></member>                        <!-- Sampler to write to the descriptor (in case it's a SAMPLER or COMBINED_IMAGE_SAMPLER descriptor, otherwise should be VK_NULL_HANDLE) -->
            <member><type>VkImageView</type>            <name>imageView</name></member>                      <!-- Image view to write to the descriptor (in case it's a SAMPLED_IMAGE, STORAGE_IMAGE, or COMBINED_IMAGE_SAMPLER descriptor, otherwise should be VK_NULL_HANDLE) -->
            <member><type>VkAttachmentView</type>       <name>attachmentView</name></member>                 <!-- Input attachment view to write to the descriptor (in case it's a INPUT_ATTACHMENT descriptor, otherwise should be VK_NULL_HANDLE) -->
            <member><type>VkImageLayout</type>          <name>imageLayout</name></member>                    <!-- Layout the image is expected to be in when accessed using this descriptor (only used if imageView or attachmentView is not VK_NULL_HANDLE) -->
        </type>
        <type category="struct" name="VkWriteDescriptorSet">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkDescriptorSet</type>        <name>destSet</name></member>                        <!-- Destination descriptor set -->
            <member><type>uint32_t</type>               <name>destBinding</name></member>                    <!-- Binding within the destination descriptor set to write -->
            <member><type>uint32_t</type>               <name>destArrayElement</name></member>               <!-- Array element within the destination binding to write -->
            <member><type>uint32_t</type>               <name>count</name></member>                          <!-- Number of descriptors to write (determines the size of the array pointed by pDescriptors) -->
            <member><type>VkDescriptorType</type>       <name>descriptorType</name></member>                 <!-- Descriptor type to write (determines which fields of the array pointed by pDescriptors are going to be used) -->
            <member>const <type>VkDescriptorInfo</type>* <name>pDescriptors</name></member>                   <!-- Array of info structures describing the descriptors to write -->
        </type>
        <type category="struct" name="VkCopyDescriptorSet">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkDescriptorSet</type>        <name>srcSet</name></member>                         <!-- Source descriptor set -->
            <member><type>uint32_t</type>               <name>srcBinding</name></member>                     <!-- Binding within the source descriptor set to copy from -->
            <member><type>uint32_t</type>               <name>srcArrayElement</name></member>                <!-- Array element within the source binding to copy from -->
            <member><type>VkDescriptorSet</type>        <name>destSet</name></member>                        <!-- Destination descriptor set -->
            <member><type>uint32_t</type>               <name>destBinding</name></member>                    <!-- Binding within the destination descriptor set to copy to -->
            <member><type>uint32_t</type>               <name>destArrayElement</name></member>               <!-- Array element within the destination binding to copy to -->
            <member><type>uint32_t</type>               <name>count</name></member>                          <!-- Number of descriptors to copy -->
        </type>
        <type category="struct" name="VkBufferCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure. -->
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Specified in bytes -->
            <member><type>VkBufferUsageFlags</type>     <name>usage</name></member>                          <!-- Buffer usage flags -->
            <member><type>VkBufferCreateFlags</type>    <name>flags</name></member>                          <!-- Buffer creation flags -->
            <member><type>VkSharingMode</type>          <name>sharingMode</name></member>
            <member><type>uint32_t</type>               <name>queueFamilyCount</name></member>
            <member>const <type>uint32_t</type>*        <name>pQueueFamilyIndices</name></member>
        </type>
        <type category="struct" name="VkBufferViewCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure. -->
            <member><type>VkBuffer</type>               <name>buffer</name></member>
            <member><type>VkBufferViewType</type>       <name>viewType</name></member>
            <member><type>VkFormat</type>               <name>format</name></member>                         <!-- Optionally specifies format of elements -->
            <member><type>VkDeviceSize</type>           <name>offset</name></member>                         <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>range</name></member>                          <!-- View size specified in bytes -->
        </type>
        <type category="struct" name="VkImageSubresource">
            <member><type>VkImageAspect</type>          <name>aspect</name></member>
            <member><type>uint32_t</type>               <name>mipLevel</name></member>
            <member><type>uint32_t</type>               <name>arraySlice</name></member>
        </type>
        <type category="struct" name="VkImageSubresourceRange">
            <member><type>VkImageAspect</type>          <name>aspect</name></member>
            <member><type>uint32_t</type>               <name>baseMipLevel</name></member>
            <member><type>uint32_t</type>               <name>mipLevels</name></member>
            <member><type>uint32_t</type>               <name>baseArraySlice</name></member>
            <member><type>uint32_t</type>               <name>arraySize</name></member>
        </type>
        <type category="struct" name="VkMemoryBarrier">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_MEMORY_BARRIER -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure. -->
            <member><type>VkMemoryOutputFlags</type>    <name>outputMask</name></member>                     <!-- Outputs the barrier should sync -->
            <member><type>VkMemoryInputFlags</type>     <name>inputMask</name></member>                      <!-- Inputs the barrier should sync to -->
        </type>
        <type category="struct" name="VkBufferMemoryBarrier">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure. -->
            <member><type>VkMemoryOutputFlags</type>    <name>outputMask</name></member>                     <!-- Outputs the barrier should sync -->
            <member><type>VkMemoryInputFlags</type>     <name>inputMask</name></member>                      <!-- Inputs the barrier should sync to -->
            <member><type>uint32_t</type>               <name>srcQueueFamilyIndex</name></member>            <!-- Queue family to transition ownership from -->
            <member><type>uint32_t</type>               <name>destQueueFamilyIndex</name></member>           <!-- Queue family to transition ownership to -->
            <member><type>VkBuffer</type>               <name>buffer</name></member>                         <!-- Buffer to sync -->
            <member><type>VkDeviceSize</type>           <name>offset</name></member>                         <!-- Offset within the buffer to sync -->
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Amount of bytes to sync -->
        </type>
        <type category="struct" name="VkImageMemoryBarrier">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure. -->
            <member><type>VkMemoryOutputFlags</type>    <name>outputMask</name></member>                     <!-- Outputs the barrier should sync -->
            <member><type>VkMemoryInputFlags</type>     <name>inputMask</name></member>                      <!-- Inputs the barrier should sync to -->
            <member><type>VkImageLayout</type>          <name>oldLayout</name></member>                      <!-- Current layout of the image -->
            <member><type>VkImageLayout</type>          <name>newLayout</name></member>                      <!-- New layout to transition the image to -->
            <member><type>uint32_t</type>               <name>srcQueueFamilyIndex</name></member>            <!-- Queue family to transition ownership from -->
            <member><type>uint32_t</type>               <name>destQueueFamilyIndex</name></member>           <!-- Queue family to transition ownership to -->
            <member><type>VkImage</type>                <name>image</name></member>                          <!-- Image to sync -->
            <member><type>VkImageSubresourceRange</type> <name>subresourceRange</name></member>               <!-- Subresource range to sync -->
        </type>
        <type category="struct" name="VkImageCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure. -->
            <member><type>VkImageType</type>            <name>imageType</name></member>
            <member><type>VkFormat</type>               <name>format</name></member>
            <member><type>VkExtent3D</type>             <name>extent</name></member>
            <member><type>uint32_t</type>               <name>mipLevels</name></member>
            <member><type>uint32_t</type>               <name>arraySize</name></member>
            <member><type>uint32_t</type>               <name>samples</name></member>
            <member><type>VkImageTiling</type>          <name>tiling</name></member>
            <member><type>VkImageUsageFlags</type>      <name>usage</name></member>                          <!-- Image usage flags -->
            <member><type>VkImageCreateFlags</type>     <name>flags</name></member>                          <!-- Image creation flags -->
            <member><type>VkSharingMode</type>          <name>sharingMode</name></member>                    <!-- Cross-queue-family sharing mode -->
            <member><type>uint32_t</type>               <name>queueFamilyCount</name></member>               <!-- Number of queue families to share across -->
            <member>const <type>uint32_t</type>*        <name>pQueueFamilyIndices</name></member>            <!-- Array of queue family indices to share across -->
        </type>
        <type category="struct" name="VkSubresourceLayout">
            <member><type>VkDeviceSize</type>           <name>offset</name></member>                         <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>size</name></member>                           <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>rowPitch</name></member>                       <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>depthPitch</name></member>                     <!-- Specified in bytes -->
        </type>
        <type category="struct" name="VkImageViewCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkImage</type>                <name>image</name></member>
            <member><type>VkImageViewType</type>        <name>viewType</name></member>
            <member><type>VkFormat</type>               <name>format</name></member>
            <member><type>VkChannelMapping</type>       <name>channels</name></member>
            <member><type>VkImageSubresourceRange</type> <name>subresourceRange</name></member>
        </type>
        <type category="struct" name="VkAttachmentViewCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_ATTACHMENT_VIEW_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkImage</type>                <name>image</name></member>
            <member><type>VkFormat</type>               <name>format</name></member>
            <member><type>uint32_t</type>               <name>mipLevel</name></member>
            <member><type>uint32_t</type>               <name>baseArraySlice</name></member>
            <member><type>uint32_t</type>               <name>arraySize</name></member>
            <member><type>VkAttachmentViewCreateFlags</type> <name>flags</name></member>                          <!-- Framebuffer attachment view flags -->
        </type>
        <type category="struct" name="VkBufferCopy">
            <member><type>VkDeviceSize</type>           <name>srcOffset</name></member>                      <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>destOffset</name></member>                     <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>copySize</name></member>                       <!-- Specified in bytes -->
        </type>
        <type category="struct" name="VkSparseMemoryBindInfo">
            <member><type>VkDeviceSize</type>           <name>offset</name></member>                         <!-- Specified in bytes -->
            <member><type>VkDeviceSize</type>           <name>memOffset</name></member>                      <!-- Specified in bytes -->
            <member><type>VkDeviceMemory</type>         <name>mem</name></member>
            <member><type>VkSparseMemoryBindFlags</type><name>flags</name></member>
        </type>
        <type category="struct" name="VkSparseImageMemoryBindInfo">
            <member><type>VkImageSubresource</type>     <name>subresource</name></member>
            <member><type>VkOffset3D</type>             <name>offset</name></member>
            <member><type>VkExtent3D</type>             <name>extent</name></member>
            <member><type>VkDeviceSize</type>           <name>memOffset</name></member>                      <!-- Specified in bytes -->
            <member><type>VkDeviceMemory</type>         <name>mem</name></member>
            <member><type>VkSparseMemoryBindFlags</type><name>flags</name></member>
        </type>
        <type category="struct" name="VkImageCopy">
            <member><type>VkImageSubresource</type>     <name>srcSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>srcOffset</name></member>                      <!-- Specified in pixels for both compressed and uncompressed images -->
            <member><type>VkImageSubresource</type>     <name>destSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>destOffset</name></member>                     <!-- Specified in pixels for both compressed and uncompressed images -->
            <member><type>VkExtent3D</type>             <name>extent</name></member>                         <!-- Specified in pixels for both compressed and uncompressed images -->
        </type>
        <type category="struct" name="VkImageBlit">
            <member><type>VkImageSubresource</type>     <name>srcSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>srcOffset</name></member>                      <!-- Specified in pixels for both compressed and uncompressed images -->
            <member><type>VkExtent3D</type>             <name>srcExtent</name></member>                      <!-- Specified in pixels for both compressed and uncompressed images -->
            <member><type>VkImageSubresource</type>     <name>destSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>destOffset</name></member>                     <!-- Specified in pixels for both compressed and uncompressed images -->
            <member><type>VkExtent3D</type>             <name>destExtent</name></member>                     <!-- Specified in pixels for both compressed and uncompressed images -->
        </type>
        <type category="struct" name="VkBufferImageCopy">
            <member><type>VkDeviceSize</type>           <name>bufferOffset</name></member>                   <!-- Specified in bytes -->
            <member><type>uint32_t</type>               <name>bufferRowLength</name></member>                      <!-- Specified in texels -->
            <member><type>uint32_t</type>               <name>bufferImageHeight</name></member>
            <member><type>VkImageSubresource</type>     <name>imageSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>imageOffset</name></member>                    <!-- Specified in pixels for both compressed and uncompressed images -->
            <member><type>VkExtent3D</type>             <name>imageExtent</name></member>                    <!-- Specified in pixels for both compressed and uncompressed images -->
        </type>
        <type category="struct" name="VkImageResolve">
            <member><type>VkImageSubresource</type>     <name>srcSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>srcOffset</name></member>
            <member><type>VkImageSubresource</type>     <name>destSubresource</name></member>
            <member><type>VkOffset3D</type>             <name>destOffset</name></member>
            <member><type>VkExtent3D</type>             <name>extent</name></member>
        </type>
        <type category="struct" name="VkShaderModuleCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>size_t</type>                 <name>codeSize</name></member>                       <!-- Specified in bytes -->
            <member>const void*                         <name>pCode</name></member>                          <!-- Binary code of size codeSize -->
            <member><type>VkShaderModuleCreateFlags</type> <name>flags</name></member>                       <!-- Reserved -->
        </type>
        <type category="struct" name="VkShaderCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_SHADER_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkShaderModule</type>         <name>module</name></member>                         <!-- Module containing entry point -->
            <member>const char*                         <name>pName</name></member>                          <!-- Null-terminated entry point name -->
            <member><type>VkShaderCreateFlags</type>    <name>flags</name></member>                          <!-- Reserved -->
        </type>
        <type category="struct" name="VkDescriptorSetLayoutBinding">
            <member><type>VkDescriptorType</type>       <name>descriptorType</name></member>                 <!-- Type of the descriptors in this binding -->
            <member><type>uint32_t</type>               <name>arraySize</name></member>                      <!-- Number of descriptors in this binding -->
            <member><type>VkShaderStageFlags</type>     <name>stageFlags</name></member>                     <!-- Shader stages this binding is visible to -->
            <member>const <type>VkSampler</type>*       <name>pImmutableSamplers</name></member>             <!-- Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains count number of elements) -->
        </type>
        <type category="struct" name="VkDescriptorSetLayoutCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>uint32_t</type>               <name>count</name></member>                          <!-- Number of bindings in the descriptor set layout -->
            <member>const <type>VkDescriptorSetLayoutBinding</type>* <name>pBinding</name></member>       <!-- Array of descriptor set layout bindings -->
        </type>
        <type category="struct" name="VkDescriptorTypeCount">
            <member><type>VkDescriptorType</type>       <name>type</name></member>
            <member><type>uint32_t</type>               <name>count</name></member>
        </type>
        <type category="struct" name="VkDescriptorPoolCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>uint32_t</type>               <name>count</name></member>
            <member>const <type>VkDescriptorTypeCount</type>* <name>pTypeCount</name></member>
        </type>
        <type category="struct" name="VkSpecializationMapEntry">
            <member><type>uint32_t</type>               <name>constantId</name></member>                     <!-- The SpecConstant ID specified in the BIL -->
            <member><type>size_t</type>                 <name>size</name></member>                           <!-- Size in bytes of the SpecConstant -->
            <member><type>uint32_t</type>               <name>offset</name></member>                         <!-- Offset of the value in the data block -->
        </type>
        <type category="struct" name="VkSpecializationInfo">
            <member><type>uint32_t</type>               <name>mapEntryCount</name></member>                  <!-- Number of entries in the map -->
            <member>const <type>VkSpecializationMapEntry</type>* <name>pMap</name></member>                  <!-- Array of map entries -->
            <member><type>size_t</type>                 <name>dataSize</name></member>                       <!-- Size in bytes of pData -->
            <member>const void*                         <name>pData</name></member>                          <!-- Pointer to SpecConstant data -->
        </type>
        <type category="struct" name="VkPipelineShaderStageCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkShaderStage</type>          <name>stage</name></member>
            <member><type>VkShader</type>               <name>shader</name></member>
            <member>const <type>VkSpecializationInfo</type>* <name>pSpecializationInfo</name></member>
        </type>
        <type category="struct" name="VkComputePipelineCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkPipelineShaderStageCreateInfo</type> <name>cs</name></member>
            <member><type>VkPipelineCreateFlags</type>  <name>flags</name></member>                          <!-- Pipeline creation flags -->
            <member><type>VkPipelineLayout</type>       <name>layout</name></member>                         <!-- Interface layout of the pipeline -->
            <member><type>VkPipeline</type>             <name>basePipelineHandle</name></member>             <!-- If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of -->
            <member><type>int32_t</type>                <name>basePipelineIndex</name></member>              <!-- If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of -->
        </type>
        <type category="struct" name="VkVertexInputBindingDescription">
            <member><type>uint32_t</type>               <name>binding</name></member>                        <!-- Vertex buffer binding id -->
            <member><type>uint32_t</type>               <name>strideInBytes</name></member>                  <!-- Distance between vertices in bytes (0 = no advancement) -->
            <member><type>VkVertexInputStepRate</type>  <name>stepRate</name></member>                       <!-- Rate at which binding is incremented -->
        </type>
        <type category="struct" name="VkVertexInputAttributeDescription">
            <member><type>uint32_t</type>               <name>location</name></member>                       <!-- location of the shader vertex attrib -->
            <member><type>uint32_t</type>               <name>binding</name></member>                        <!-- Vertex buffer binding id -->
            <member><type>VkFormat</type>               <name>format</name></member>                         <!-- format of source data -->
            <member><type>uint32_t</type>               <name>offsetInBytes</name></member>                  <!-- Offset of first element in bytes from base of vertex -->
        </type>
        <type category="struct" name="VkPipelineVertexInputStateCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Should be VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>uint32_t</type>               <name>bindingCount</name></member>                   <!-- number of bindings -->
            <member>const <type>VkVertexInputBindingDescription</type>* <name>pVertexBindingDescriptions</name></member>
            <member><type>uint32_t</type>               <name>attributeCount</name></member>                 <!-- number of attributes -->
            <member>const <type>VkVertexInputAttributeDescription</type>* <name>pVertexAttributeDescriptions</name></member>
        </type>
        <type category="struct" name="VkPipelineInputAssemblyStateCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_IINPUT_ASSEMBLY_STATE_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkPrimitiveTopology</type>    <name>topology</name></member>
            <member><type>VkBool32</type>               <name>primitiveRestartEnable</name></member>
        </type>
        <type category="struct" name="VkPipelineTessellationStateCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>uint32_t</type>               <name>patchControlPoints</name></member>
        </type>
        <type category="struct" name="VkPipelineViewportStateCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>uint32_t</type>               <name>viewportCount</name></member>
        </type>
        <type category="struct" name="VkPipelineRasterStateCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_RASTER_STATE_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkBool32</type>               <name>depthClipEnable</name></member>
            <member><type>VkBool32</type>               <name>rasterizerDiscardEnable</name></member>
            <member><type>VkFillMode</type>             <name>fillMode</name></member>                       <!-- optional (GL45) -->
            <member><type>VkCullMode</type>             <name>cullMode</name></member>
            <member><type>VkFrontFace</type>            <name>frontFace</name></member>
        </type>
        <type category="struct" name="VkPipelineMultisampleStateCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>uint32_t</type>               <name>rasterSamples</name></member>                  <!-- Number of samples used for rasterization -->
            <member><type>VkBool32</type>               <name>sampleShadingEnable</name></member>            <!-- optional (GL45) -->
            <member><type>float</type>                  <name>minSampleShading</name></member>               <!-- optional (GL45) -->
            <member><type>VkSampleMask</type>           <name>sampleMask</name></member>
        </type>
        <type category="struct" name="VkPipelineColorBlendAttachmentState">
            <member><type>VkBool32</type>               <name>blendEnable</name></member>
            <member><type>VkBlend</type>                <name>srcBlendColor</name></member>
            <member><type>VkBlend</type>                <name>destBlendColor</name></member>
            <member><type>VkBlendOp</type>              <name>blendOpColor</name></member>
            <member><type>VkBlend</type>                <name>srcBlendAlpha</name></member>
            <member><type>VkBlend</type>                <name>destBlendAlpha</name></member>
            <member><type>VkBlendOp</type>              <name>blendOpAlpha</name></member>
            <member><type>VkChannelFlags</type>         <name>channelWriteMask</name></member>
        </type>
        <type category="struct" name="VkPipelineColorBlendStateCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkBool32</type>               <name>alphaToCoverageEnable</name></member>
            <member><type>VkBool32</type>               <name>logicOpEnable</name></member>
            <member><type>VkLogicOp</type>              <name>logicOp</name></member>
            <member><type>uint32_t</type>               <name>attachmentCount</name></member>                <!-- # of pAttachments -->
            <member>const <type>VkPipelineColorBlendAttachmentState</type>* <name>pAttachments</name></member>
        </type>
        <type category="struct" name="VkStencilOpState">
            <member><type>VkStencilOp</type>            <name>stencilFailOp</name></member>
            <member><type>VkStencilOp</type>            <name>stencilPassOp</name></member>
            <member><type>VkStencilOp</type>            <name>stencilDepthFailOp</name></member>
            <member><type>VkCompareOp</type>            <name>stencilCompareOp</name></member>
        </type>
        <type category="struct" name="VkPipelineDepthStencilStateCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkBool32</type>               <name>depthTestEnable</name></member>
            <member><type>VkBool32</type>               <name>depthWriteEnable</name></member>
            <member><type>VkCompareOp</type>            <name>depthCompareOp</name></member>
            <member><type>VkBool32</type>               <name>depthBoundsEnable</name></member>              <!-- optional (depth_bounds_test) -->
            <member><type>VkBool32</type>               <name>stencilTestEnable</name></member>
            <member><type>VkStencilOpState</type>       <name>front</name></member>
            <member><type>VkStencilOpState</type>       <name>back</name></member>
        </type>
        <type category="struct" name="VkGraphicsPipelineCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>uint32_t</type>               <name>stageCount</name></member>
            <member>const <type>VkPipelineShaderStageCreateInfo</type>* <name>pStages</name></member>        <!-- One entry for each active shader stage -->
            <member>const <type>VkPipelineVertexInputStateCreateInfo</type>* <name>pVertexInputState</name></member>
            <member>const <type>VkPipelineInputAssemblyStateCreateInfo</type>* <name>pInputAssemblyState</name></member>
            <member>const <type>VkPipelineTessellationStateCreateInfo</type>* <name>pTessellationState</name></member>
            <member>const <type>VkPipelineViewportStateCreateInfo</type>* <name>pViewportState</name></member>
            <member>const <type>VkPipelineRasterStateCreateInfo</type>* <name>pRasterState</name></member>
            <member>const <type>VkPipelineMultisampleStateCreateInfo</type>* <name>pMultisampleState</name></member>
            <member>const <type>VkPipelineDepthStencilStateCreateInfo</type>* <name>pDepthStencilState</name></member>
            <member>const <type>VkPipelineColorBlendStateCreateInfo</type>* <name>pColorBlendState</name></member>
            <member><type>VkPipelineCreateFlags</type>  <name>flags</name></member>                          <!-- Pipeline creation flags -->
            <member><type>VkPipelineLayout</type>       <name>layout</name></member>                         <!-- Interface layout of the pipeline -->
            <member><type>VkRenderPass</type>           <name>renderPass</name></member>
            <member><type>uint32_t</type>               <name>subpass</name></member>
            <member><type>VkPipeline</type>             <name>basePipelineHandle</name></member>             <!-- If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of -->
            <member><type>int32_t</type>                <name>basePipelineIndex</name></member>              <!-- If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of -->
        </type>
        <type category="struct" name="VkPipelineCacheCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>size_t</type>                 <name>initialSize</name></member>                    <!-- Size of initial data to populate cache, in bytes -->
            <member>const void*                         <name>initialData</name></member>                    <!-- Initial data to populate cache -->
            <member><type>size_t</type>                 <name>maxSize</name></member>                        <!-- Maximum size cache can grow to, in bytes. If zero, then the cache may grow without bound. -->
        </type>
        <type category="struct" name="VkPushConstantRange">
            <member><type>VkShaderStageFlags</type>     <name>stageFlags</name></member>                     <!-- Which stages use the range -->
            <member><type>uint32_t</type>               <name>start</name></member>                          <!-- Start of the range, in bytes -->
            <member><type>uint32_t</type>               <name>length</name></member>                         <!-- Length of the range, in bytes -->
        </type>
        <type category="struct" name="VkPipelineLayoutCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>uint32_t</type>               <name>descriptorSetCount</name></member>             <!-- Number of descriptor sets interfaced by the pipeline -->
            <member>const <type>VkDescriptorSetLayout</type>* <name>pSetLayouts</name></member>              <!-- Array of setCount number of descriptor set layout objects defining the layout of the -->
            <member><type>uint32_t</type>               <name>pushConstantRangeCount</name></member>         <!-- Number of push-constant ranges used by the pipeline -->
            <member>const <type>VkPushConstantRange</type>* <name>pPushConstantRanges</name></member>        <!-- Array of pushConstantRangeCount number of ranges used by various shader stages -->
        </type>
        <type category="struct" name="VkSamplerCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkTexFilter</type>            <name>magFilter</name></member>                      <!-- Filter mode for magnification -->
            <member><type>VkTexFilter</type>            <name>minFilter</name></member>                      <!-- Filter mode for minifiation -->
            <member><type>VkTexMipmapMode</type>        <name>mipMode</name></member>                        <!-- Mipmap selection mode -->
            <member><type>VkTexAddress</type>           <name>addressU</name></member>
            <member><type>VkTexAddress</type>           <name>addressV</name></member>
            <member><type>VkTexAddress</type>           <name>addressW</name></member>
            <member><type>float</type>                  <name>mipLodBias</name></member>
            <member><type>float</type>                  <name>maxAnisotropy</name></member>
            <member><type>VkBool32</type>               <name>compareEnable</name></member>
            <member><type>VkCompareOp</type>            <name>compareOp</name></member>
            <member><type>float</type>                  <name>minLod</name></member>
            <member><type>float</type>                  <name>maxLod</name></member>
            <member><type>VkBorderColor</type>          <name>borderColor</name></member>
        </type>
        <type category="struct" name="VkDynamicViewportStateCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_DYNAMIC_VIEWPORT_STATE_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>uint32_t</type>               <name>viewportAndScissorCount</name></member>        <!-- number of entries in pViewports and pScissors -->
            <member>const <type>VkViewport</type>*      <name>pViewports</name></member>
            <member>const <type>VkRect2D</type>*        <name>pScissors</name></member>
        </type>
        <type category="struct" name="VkDynamicRasterStateCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_DYNAMIC_RASTER_STATE_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>float</type>                  <name>depthBias</name></member>
            <member><type>float</type>                  <name>depthBiasClamp</name></member>
            <member><type>float</type>                  <name>slopeScaledDepthBias</name></member>
            <member><type>float</type>                  <name>lineWidth</name></member>                      <!-- optional (GL45) - Width of lines -->
        </type>
        <type category="struct" name="VkDynamicColorBlendStateCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_DYNAMIC_COLOR_BLEND_STATE_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>float</type>                  <name>blendConst[4]</name></member>
        </type>
        <type category="struct" name="VkDynamicDepthStencilStateCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_DYNAMIC_DEPTH_STENCIL_STATE_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>float</type>                  <name>minDepthBounds</name></member>                 <!-- optional (depth_bounds_test) -->
            <member><type>float</type>                  <name>maxDepthBounds</name></member>                 <!-- optional (depth_bounds_test) -->
            <member><type>uint32_t</type>               <name>stencilReadMask</name></member>
            <member><type>uint32_t</type>               <name>stencilWriteMask</name></member>
            <member><type>uint32_t</type>               <name>stencilFrontRef</name></member>
            <member><type>uint32_t</type>               <name>stencilBackRef</name></member>
        </type>
        <type category="struct" name="VkCmdPoolCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_CMD_POOL_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>uint32_t</type>               <name>queueFamilyIndex</name></member>
            <member><type>VkCmdPoolCreateFlags</type>   <name>flags</name></member>                          <!-- Command pool creation flags -->
         </type>
         <type category="struct" name="VkCmdBufferCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_CMD_BUFFER_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkCmdPool</type>              <name>cmdPool</name></member>
            <member><type>VkCmdBufferLevel</type>       <name>level</name></member>
            <member><type>VkCmdBufferCreateFlags</type> <name>flags</name></member>                          <!-- Command buffer creation flags -->
        </type>
        <type category="struct" name="VkCmdBufferBeginInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_CMD_BUFFER_BEGIN_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkCmdBufferOptimizeFlags</type> <name>flags</name></member>                          <!-- Command buffer optimization flags -->
            <member><type>VkRenderPass</type>           <name>renderPass</name></member>                     <!-- Render pass for secondary command buffers -->
            <member><type>VkFramebuffer</type>          <name>framebuffer</name></member>                    <!-- Framebuffer for secondary command buffers -->
        </type>
        <type category="struct" name="VkRenderPassBeginInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkRenderPass</type>           <name>renderPass</name></member>
            <member><type>VkFramebuffer</type>          <name>framebuffer</name></member>
            <member><type>VkRect2D</type>               <name>renderArea</name></member>
            <member>uint32_t                            <name>clearValueCount</name></member>
            <member>const <type>VkClearValue</type>*    <name>pClearValues</name></member>
        </type>
        <type category="union" name="VkClearColorValue" comment="// Union allowing specification of floating point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared.">
            <member><type>float</type>                  <name>f32[4]</name></member>
            <member><type>int32_t</type>                <name>s32[4]</name></member>
            <member><type>uint32_t</type>               <name>u32[4]</name></member>
        </type>
        <type category="struct" name="VkClearDepthStencilValue">
            <member><type>float</type>                  <name>depth</name></member>
            <member><type>uint32_t</type>               <name>stencil</name></member>
        </type>
        <type category="union" name="VkClearValue" comment="// Union allowing specification of color, depth, and stencil color values. Actual value selected is based on attachment being cleared.">
            <member><type>VkClearColorValue</type>      <name>color</name></member>
            <member><type>VkClearDepthStencilValue</type> <name>ds</name></member>
        </type>
        <type category="struct" name="VkAttachmentDescription">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkFormat</type>               <name>format</name></member>
            <member><type>uint32_t</type>               <name>samples</name></member>
            <member><type>VkAttachmentLoadOp</type>     <name>loadOp</name></member>                         <!-- Load op for color or depth data -->
            <member><type>VkAttachmentStoreOp</type>    <name>storeOp</name></member>                        <!-- Store op for color or depth data -->
            <member><type>VkAttachmentLoadOp</type>     <name>stencilLoadOp</name></member>                  <!-- Load op for stencil data -->
            <member><type>VkAttachmentStoreOp</type>    <name>stencilStoreOp</name></member>                 <!-- Store op for stencil data -->
            <member><type>VkImageLayout</type>          <name>initialLayout</name></member>
            <member><type>VkImageLayout</type>          <name>finalLayout</name></member>
        </type>
        <type category="struct" name="VkAttachmentReference">
            <member>uint32_t                            <name>attachment</name></member>
            <member><type>VkImageLayout</type>          <name>layout</name></member>
        </type>
        <type category="struct" name="VkSubpassDescription">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_SUBPASS_DESCRIPTION -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkPipelineBindPoint</type>    <name>pipelineBindPoint</name></member>              <!-- Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now -->
            <member><type>VkSubpassDescriptionFlags</type> <name>flags</name></member>
            <member>uint32_t                            <name>inputCount</name></member>
            <member>const <type>VkAttachmentReference</type>* <name>pInputAttachments</name></member>
            <member>uint32_t                            <name>colorCount</name></member>
            <member>const <type>VkAttachmentReference</type>* <name>pColorAttachments</name></member>
            <member>const <type>VkAttachmentReference</type>* <name>pResolveAttachments</name></member>
            <member><type>VkAttachmentReference</type>  <name>depthStencilAttachment</name></member>
            <member>uint32_t                            <name>preserveCount</name></member>
            <member>const <type>VkAttachmentReference</type>* <name>pPreserveAttachments</name></member>
        </type>
        <type category="struct" name="VkSubpassDependency">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_SUBPASS_DEPENDENCY -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member>uint32_t                            <name>srcSubpass</name></member>
            <member>uint32_t                            <name>destSubpass</name></member>
            <member><type>VkPipelineStageFlags</type>   <name>srcStageMask</name></member>
            <member><type>VkPipelineStageFlags</type>   <name>destStageMask</name></member>
            <member><type>VkMemoryOutputFlags</type>    <name>outputMask</name></member>
            <member><type>VkMemoryInputFlags</type>     <name>inputMask</name></member>
            <member><type>VkBool32</type>               <name>byRegion</name></member>
        </type>
        <type category="struct" name="VkRenderPassCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>uint32_t</type>               <name>attachmentCount</name></member>
            <member>const <type>VkAttachmentDescription</type>* <name>pAttachments</name></member>
            <member><type>uint32_t</type>               <name>subpassCount</name></member>
            <member>const <type>VkSubpassDescription</type>* <name>pSubpasses</name></member>
            <member><type>uint32_t</type>               <name>dependencyCount</name></member>
            <member>const <type>VkSubpassDependency</type>* <name>pDependencies</name></member>
        </type>
        <type category="struct" name="VkEventCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_EVENT_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkEventCreateFlags</type>     <name>flags</name></member>                          <!-- Event creation flags -->
        </type>
        <type category="struct" name="VkFenceCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_FENCE_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkFenceCreateFlags</type>     <name>flags</name></member>                          <!-- Fence creation flags -->
        </type>
        <type category="struct" name="VkPhysicalDeviceFeatures">
            <member><type>VkBool32</type>               <name>robustBufferAccess</name></member>                <!-- out of bounds buffer accesses are well defined -->
            <member><type>VkBool32</type>               <name>fullDrawIndexUint32</name></member>               <!-- full 32-bit range of indices for indexed draw calls -->
            <member><type>VkBool32</type>               <name>imageCubeArray</name></member>                    <!-- image views which are arrays of cube maps -->
            <member><type>VkBool32</type>               <name>independentBlend</name></member>                  <!-- blending operations are controlled per-attachment -->
            <member><type>VkBool32</type>               <name>geometryShader</name></member>                    <!-- geometry stage -->
            <member><type>VkBool32</type>               <name>tessellationShader</name></member>                <!-- tessellation control and evaluation stage -->
            <member><type>VkBool32</type>               <name>sampleRateShading</name></member>                 <!-- per-sample shading and interpolation -->
            <member><type>VkBool32</type>               <name>dualSourceBlend</name></member>                   <!-- blend operations which take two sources -->
            <member><type>VkBool32</type>               <name>logicOp</name></member>                           <!-- logic operations -->
            <member><type>VkBool32</type>               <name>instancedDrawIndirect</name></member>             <!-- multi draw indirect -->
            <member><type>VkBool32</type>               <name>depthClip</name></member>                         <!-- depth clipping -->
            <member><type>VkBool32</type>               <name>depthBiasClamp</name></member>                    <!-- depth bias clamping -->
            <member><type>VkBool32</type>               <name>fillModeNonSolid</name></member>                  <!-- point and wireframe fill modes -->
            <member><type>VkBool32</type>               <name>depthBounds</name></member>                       <!-- depth bounds test -->
            <member><type>VkBool32</type>               <name>wideLines</name></member>                         <!-- lines with width greater than 1 -->
            <member><type>VkBool32</type>               <name>largePoints</name></member>                       <!-- points with size greater than 1 -->
            <member><type>VkBool32</type>               <name>textureCompressionETC2</name></member>            <!-- ETC texture compression formats -->
            <member><type>VkBool32</type>               <name>textureCompressionASTC_LDR</name></member>        <!-- ASTC LDR texture compression formats -->
            <member><type>VkBool32</type>               <name>textureCompressionBC</name></member>              <!-- BC1-7 texture compressed formats -->
            <member><type>VkBool32</type>               <name>pipelineStatisticsQuery</name></member>           <!-- pipeline statistics query -->
            <member><type>VkBool32</type>               <name>vertexSideEffects</name></member>                 <!-- storage buffers and images in vertex stage -->
            <member><type>VkBool32</type>               <name>tessellationSideEffects</name></member>           <!-- storage buffers and images in tessellation stage -->
            <member><type>VkBool32</type>               <name>geometrySideEffects</name></member>               <!-- storage buffers and images in geometry stage -->
            <member><type>VkBool32</type>               <name>fragmentSideEffects</name></member>               <!-- storage buffers and images in fragment stage -->
            <member><type>VkBool32</type>               <name>shaderTessellationPointSize</name></member>       <!-- tessellation stage can export point size -->
            <member><type>VkBool32</type>               <name>shaderGeometryPointSize</name></member>           <!-- geometry stage can export point size -->
            <member><type>VkBool32</type>               <name>shaderTextureGatherExtended</name></member>       <!-- texture gather with run-time values and independent offsets -->
            <member><type>VkBool32</type>               <name>shaderStorageImageExtendedFormats</name></member> <!-- the extended set of formats can be used for storage images -->
            <member><type>VkBool32</type>               <name>shaderStorageImageMultisample</name></member>     <!-- multisample images can be used for storage images -->
            <member><type>VkBool32</type>               <name>shaderStorageBufferArrayConstantIndexing</name></member>  <!-- arrays of storage buffers can be accessed with constant indices -->
            <member><type>VkBool32</type>               <name>shaderStorageImageArrayConstantIndexing</name></member>   <!-- arrays of storage images can be accessed with constant indices -->
            <member><type>VkBool32</type>               <name>shaderUniformBufferArrayDynamicIndexing</name></member>   <!-- arrays of uniform buffers can be accessed with dynamically uniform indices -->
            <member><type>VkBool32</type>               <name>shaderSampledImageArrayDynamicIndexing</name></member>    <!-- arrays of sampled images can be accessed with dynamically uniform indices -->
            <member><type>VkBool32</type>               <name>shaderStorageBufferArrayDynamicIndexing</name></member>   <!-- arrays of storage buffers can be accessed with dynamically uniform indices -->
            <member><type>VkBool32</type>               <name>shaderStorageImageArrayDynamicIndexing</name></member>    <!-- arrays of storage images can be accessed with dynamically uniform indices -->
            <member><type>VkBool32</type>               <name>shaderClipDistance</name></member>                <!-- clip distance in shaders -->
            <member><type>VkBool32</type>               <name>shaderCullDistance</name></member>                <!-- cull distance in shaders -->
            <member><type>VkBool32</type>               <name>shaderFloat64</name></member>                     <!-- 64-bit floats (doubles) in shaders -->
            <member><type>VkBool32</type>               <name>shaderInt64</name></member>                       <!-- 64-bit integers in shaders -->
            <member><type>VkBool32</type>               <name>shaderFloat16</name></member>                     <!-- 16-bit floats in shaders -->
            <member><type>VkBool32</type>               <name>shaderInt16</name></member>                       <!-- 16-bit integers in shaders -->
            <member><type>VkBool32</type>               <name>shaderResourceResidency</name></member>           <!-- shader can use texture operations that return resource residency information (requires sparseNonResident support) -->
            <member><type>VkBool32</type>               <name>shaderResourceMinLOD</name></member>              <!-- shader can use texture operations that specify minimum resource LOD -->
            <member><type>VkBool32</type>               <name>sparse</name></member>                            <!-- Sparse resources support: Resource memory can be managed at opaque page level rather than object level -->
            <member><type>VkBool32</type>               <name>sparseResidencyBuffer</name></member>             <!-- Sparse resources support: GPU can access partially resident buffers  -->
            <member><type>VkBool32</type>               <name>sparseResidencyImage2D</name></member>            <!-- Sparse resources support: GPU can access partially resident 2D (non-MSAA non-DepthStencil) images  -->
            <member><type>VkBool32</type>               <name>sparseResidencyImage3D</name></member>            <!-- Sparse resources support: GPU can access partially resident 3D images  -->
            <member><type>VkBool32</type>               <name>sparseResidency2Samples</name></member>           <!-- Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples -->
            <member><type>VkBool32</type>               <name>sparseResidency4Samples</name></member>           <!-- Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples -->
            <member><type>VkBool32</type>               <name>sparseResidency8Samples</name></member>           <!-- Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples -->
            <member><type>VkBool32</type>               <name>sparseResidency16Samples</name></member>          <!-- Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples -->
            <member><type>VkBool32</type>               <name>sparseResidencyStandard2DBlockShape</name></member> <!-- Sparse resources support: GPU will access all 2D (single sample) sparse resources using the standard block shapes (based on pixel format) -->
            <member><type>VkBool32</type>               <name>sparseResidencyStandard2DMSBlockShape</name></member> <!-- Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard block shapes (based on pixel format) -->
            <member><type>VkBool32</type>               <name>sparseResidencyStandard3DBlockShape</name></member> <!-- Sparse resources support: GPU will access all 3D sparse resources using the standard block shapes (based on pixel format) -->
            <member><type>VkBool32</type>               <name>sparseResidencyAlignedMipSize</name></member>     <!-- Sparse resources support: Images with mip-level dimensions that are NOT a multiple of the block size will be placed in the mip tail -->
            <member><type>VkBool32</type>               <name>sparseResidencyNonResident</name></member>        <!-- Sparse resources support: GPU can safely access non-resident regions of a resource, read values from read-write resources are undefined -->
            <member><type>VkBool32</type>               <name>sparseResidencyNonResidentStrict</name></member>  <!-- Sparse resources support: GPU can safely access non-resident regions of a resource, all reads return as if data is 0, writes are discarded -->
            <member><type>VkBool32</type>               <name>sparseResidencyAliased</name></member>            <!-- Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in) -->
        </type>
        <type category="struct" name="VkPhysicalDeviceLimits">
                <!-- resource maximum sizes -->
            <member><type>uint32_t</type>               <name>maxImageDimension1D</name></member>               <!-- max 1D image dimension -->
            <member><type>uint32_t</type>               <name>maxImageDimension2D</name></member>               <!-- max 2D image dimension -->
            <member><type>uint32_t</type>               <name>maxImageDimension3D</name></member>               <!-- max 3D image dimension -->
            <member><type>uint32_t</type>               <name>maxImageDimensionCube</name></member>             <!-- max cubemap image dimension -->
            <member><type>uint32_t</type>               <name>maxImageArrayLayers</name></member>               <!-- max layers for image arrays -->
            <member><type>uint32_t</type>               <name>maxTexelBufferSize</name></member>                <!-- max texel buffer size (bytes) -->
            <member><type>uint32_t</type>               <name>maxUniformBufferSize</name></member>              <!-- max uniform buffer size (bytes) -->
            <member><type>uint32_t</type>               <name>maxStorageBufferSize</name></member>              <!-- max storage buffer size (bytes) -->
            <member><type>uint32_t</type>               <name>maxPushConstantsSize</name></member>              <!-- max size of the push constants pool (bytes) -->
                <!-- memory limits -->
            <member><type>uint32_t</type>               <name>maxMemoryAllocationCount</name></member>          <!-- max number of device memory allocations supported -->
            <member><type>VkDeviceSize</type>           <name>bufferImageGranularity</name></member>            <!-- Granularity (in bytes) at which buffers and images can be bound to adjacent memory for simultaneous usage -->
                <!-- descriptor set limits -->
            <member><type>uint32_t</type>               <name>maxBoundDescriptorSets</name></member>                <!-- max number of descriptors sets that can be bound to a pipeline -->
            <member><type>uint32_t</type>               <name>maxDescriptorSets</name></member>                     <!-- max number of allocated descriptor sets -->
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorSamplers</name></member>         <!-- max num of samplers allowed per-stage in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorUniformBuffers</name></member>   <!-- max num of uniform buffers allowed per-stage in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorStorageBuffers</name></member>   <!-- max num of storage buffers allowed per-stage in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorSampledImages</name></member>    <!-- max num of sampled images allowed per-stage in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxPerStageDescriptorStorageImages</name></member>    <!-- max num of storage images allowed per-stage in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxDescriptorSetSamplers</name></member>              <!-- max num of samplers allowed in all stages in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxDescriptorSetUniformBuffers</name></member>        <!-- max num of uniform buffers allowed in all stages in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxDescriptorSetStorageBuffers</name></member>        <!-- max num of storage buffers allowed in all stages in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxDescriptorSetSampledImages</name></member>         <!-- max num of sampled images allowed in all stages in a descriptor set -->
            <member><type>uint32_t</type>               <name>maxDescriptorSetStorageImages</name></member>         <!-- max num of storage images allowed in all stages in a descriptor set -->
                <!-- vertex stage limits -->
            <member><type>uint32_t</type>               <name>maxVertexInputAttributes</name></member>          <!-- max num of vertex input attribute slots -->
            <member><type>uint32_t</type>               <name>maxVertexInputAttributeOffset</name></member>     <!-- max vertex input attribute offset added to vertex buffer offset -->
            <member><type>uint32_t</type>               <name>maxVertexInputBindingStride</name></member>       <!-- max vertex input binding stride -->
            <member><type>uint32_t</type>               <name>maxVertexOutputComponents</name></member>         <!-- max num of output components written by vertex shader -->
                <!-- tessellation control stage limits -->
            <member><type>uint32_t</type>               <name>maxTessGenLevel</name></member>                   <!-- max level supported by tess primitive generator -->
            <member><type>uint32_t</type>               <name>maxTessPatchSize</name></member>                  <!-- max patch size (vertices) -->
            <member><type>uint32_t</type>               <name>maxTessControlPerVertexInputComponents</name></member>    <!-- max num of input components per-vertex in TCS -->
            <member><type>uint32_t</type>               <name>maxTessControlPerVertexOutputComponents</name></member>   <!-- max num of output components per-vertex in TCS -->
            <member><type>uint32_t</type>               <name>maxTessControlPerPatchOutputComponents</name></member>    <!-- max num of output components per-patch in TCS -->
            <member><type>uint32_t</type>               <name>maxTessControlTotalOutputComponents</name></member>       <!-- max total num of per-vertex and per-patch output components in TCS -->
                <!-- tessellation evaluation stage limits -->
            <member><type>uint32_t</type>               <name>maxTessEvaluationInputComponents</name></member>  <!-- max num of input components per vertex in TES -->
            <member><type>uint32_t</type>               <name>maxTessEvaluationOutputComponents</name></member> <!-- max num of output components per vertex in TES -->
                <!-- geometry stage limits -->
            <member><type>uint32_t</type>               <name>maxGeometryShaderInvocations</name></member>      <!-- max invocation count supported in geometry shader -->
            <member><type>uint32_t</type>               <name>maxGeometryInputComponents</name></member>        <!-- max num of input components read in geometry stage -->
            <member><type>uint32_t</type>               <name>maxGeometryOutputComponents</name></member>       <!-- max num of output components written in geometry stage -->
            <member><type>uint32_t</type>               <name>maxGeometryOutputVertices</name></member>         <!-- max num of vertices that can be emitted in geometry stage -->
            <member><type>uint32_t</type>               <name>maxGeometryTotalOutputComponents</name></member>  <!-- max total num of components (all vertices) written in geometry stage -->
                <!-- fragment stage limits -->
            <member><type>uint32_t</type>               <name>maxFragmentInputComponents</name></member>        <!-- max num of input compontents read in fragment stage -->
            <member><type>uint32_t</type>               <name>maxFragmentOutputBuffers</name></member>          <!-- max num of output buffers written in fragment stage -->
            <member><type>uint32_t</type>               <name>maxFragmentDualSourceBuffers</name></member>      <!-- max num of output buffers written when using dual source blending -->
            <member><type>uint32_t</type>               <name>maxFragmentCombinedOutputResources</name></member><!-- max total num of storage buffers, storage images and output buffers -->
                <!-- compute stage limits -->
            <member><type>uint32_t</type>               <name>maxComputeSharedMemorySize</name></member>        <!-- max total storage size of work group local storage (bytes) -->
            <member><type>uint32_t</type>               <name>maxComputeWorkGroupCount[3]</name></member>       <!-- max num of compute work groups that may be dispatched
                                                                                                                     by a single command (x,y,z) -->
            <member><type>uint32_t</type>               <name>maxComputeWorkGroupInvocations</name></member>    <!-- max total compute invocations in a single local work group -->
            <member><type>uint32_t</type>               <name>maxComputeWorkGroupSize[3]</name></member>        <!-- max local size of a compute work group (x,y,z) -->

            <member><type>uint32_t</type>               <name>subPixelPrecisionBits</name></member>             <!-- num bits of subpixel precision in screen x and y-->
            <member><type>uint32_t</type>               <name>subTexelPrecisionBits</name></member>             <!-- num bits of subtexel precision -->
            <member><type>uint32_t</type>               <name>mipmapPrecisionBits</name></member>               <!-- num bits of mipmap precision -->

            <member><type>uint32_t</type>               <name>maxDrawIndexedIndexValue</name></member>          <!-- max index value for indexed draw calls (for 32-bit indices) -->
            <member><type>uint32_t</type>               <name>maxDrawIndirectInstanceCount</name></member>      <!-- max instance count for indirect draw calls -->
            <member><type>VkBool32</type>               <name>primitiveRestartForPatches</name></member>        <!-- is primitive restart supported for PATCHES -->

            <member><type>float</type>                  <name>maxSamplerLodBias</name></member>                 <!-- max absolute sampler level of detail bias -->
            <member><type>float</type>                  <name>maxSamplerAnisotropy</name></member>              <!-- max degree of sampler anisotropy -->

            <member><type>uint32_t</type>               <name>maxViewports</name></member>                      <!-- max number of active viewports -->
            <member><type>uint32_t</type>               <name>maxDynamicViewportStates</name></member>          <!-- max number of dynamic viewport state objects -->
            <member><type>uint32_t</type>               <name>maxViewportDimensions[2]</name></member>          <!-- max viewport dimensions (x,y) -->
            <member><type>float</type>                  <name>viewportBoundsRange[2]</name></member>            <!-- viewport bounds range (min,max) -->
            <member><type>uint32_t</type>               <name>viewportSubPixelBits</name></member>              <!-- num bits of subpixel precision for viewport -->

            <member><type>uint32_t</type>               <name>minMemoryMapAlignment</name></member>             <!-- min required alignment of pointers returned by MapMemory (bytes) -->
            <member><type>uint32_t</type>               <name>minTexelBufferOffsetAlignment</name></member>     <!-- min required alignment for texel buffer offsets (bytes)  -->
            <member><type>uint32_t</type>               <name>minUniformBufferOffsetAlignment</name></member>   <!-- min required alignment for uniform buffer sizes and offsets (bytes) -->
            <member><type>uint32_t</type>               <name>minStorageBufferOffsetAlignment</name></member>   <!-- min required alignment for storage buffer offsets (bytes) -->

            <member><type>uint32_t</type>               <name>minTexelOffset</name></member>                    <!-- min texel offset for OpTextureSampleOffset -->
            <member><type>uint32_t</type>               <name>maxTexelOffset</name></member>                    <!-- max texel offset for OpTextureSampleOffset -->
            <member><type>uint32_t</type>               <name>minTexelGatherOffset</name></member>              <!-- min texel offset for OpTextureGatherOffset -->
            <member><type>uint32_t</type>               <name>maxTexelGatherOffset</name></member>              <!-- max texel offset for OpTextureGatherOffset -->
            <member><type>float</type>                  <name>minInterpolationOffset</name></member>            <!-- furthest negative offset for interpolateAtOffset -->
            <member><type>float</type>                  <name>maxInterpolationOffset</name></member>            <!-- furthest positive offset for interpolateAtOffset -->
            <member><type>uint32_t</type>               <name>subPixelInterpolationOffsetBits</name></member>   <!-- num of subpixel bits for interpolateAtOffset -->

            <member><type>uint32_t</type>               <name>maxFramebufferWidth</name></member>               <!-- max width for a framebuffer -->
            <member><type>uint32_t</type>               <name>maxFramebufferHeight</name></member>              <!-- max height for a framebuffer -->
            <member><type>uint32_t</type>               <name>maxFramebufferLayers</name></member>              <!-- max layer count for a layered framebuffer -->
            <member><type>uint32_t</type>               <name>maxFramebufferColorSamples</name></member>        <!-- max color sample count for a framebuffer -->
            <member><type>uint32_t</type>               <name>maxFramebufferDepthSamples</name></member>        <!-- max depth sample count for a framebuffer -->
            <member><type>uint32_t</type>               <name>maxFramebufferStencilSamples</name></member>      <!-- max stencil sample count for a framebuffer -->
            <member><type>uint32_t</type>               <name>maxColorAttachments</name></member>               <!-- max num of framebuffer color attachments -->

            <member><type>uint32_t</type>               <name>maxSampledImageColorSamples</name></member>       <!-- max num of color samples for a non-integer sampled image -->
            <member><type>uint32_t</type>               <name>maxSampledImageDepthSamples</name></member>       <!-- max num of depth/stencil samples for a sampled image -->
            <member><type>uint32_t</type>               <name>maxSampledImageIntegerSamples</name></member>     <!-- max num of samples supported for an integer image -->
            <member><type>uint32_t</type>               <name>maxStorageImageSamples</name></member>            <!-- max num of samples for a storage image -->
            <member><type>uint32_t</type>               <name>maxSampleMaskWords</name></member>                <!-- max num of sample mask words -->

            <member><type>uint64_t</type>               <name>timestampFrequency</name></member>                <!-- 1/clock_tick_granularity for timestamp queries -->

            <member><type>uint32_t</type>               <name>maxClipDistances</name></member>                  <!-- max number of clip distances -->
            <member><type>uint32_t</type>               <name>maxCullDistances</name></member>                  <!-- max number of cull distances -->
            <member><type>uint32_t</type>               <name>maxCombinedClipAndCullDistances</name></member>   <!-- max combined number of user clipping -->

            <member><type>float</type>                  <name>pointSizeRange[2]</name></member>                 <!-- range (min,max) of supported point sizes -->
            <member><type>float</type>                  <name>lineWidthRange[2]</name></member>                 <!-- range (min,max) of supported line widths -->
            <member><type>float</type>                  <name>pointSizeGranularity</name></member>              <!-- granularity of supported point sizes -->
            <member><type>float</type>                  <name>lineWidthGranularity</name></member>              <!-- granularity of supported line widths -->
        </type>
        <type category="struct" name="VkSemaphoreCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkSemaphoreCreateFlags</type> <name>flags</name></member>                          <!-- Semaphore creation flags -->
        </type>
        <type category="struct" name="VkQueryPoolCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkQueryType</type>            <name>queryType</name></member>
            <member><type>uint32_t</type>               <name>slots</name></member>
            <member><type>VkQueryPipelineStatisticFlags</type> <name>pipelineStatistics</name></member>             <!-- Optional -->
        </type>
        <type category="struct" name="VkFramebufferCreateInfo">
            <member><type>VkStructureType</type>        <name>sType</name></member>                          <!-- Must be VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO -->
            <member>const void*                         <name>pNext</name></member>                          <!-- Pointer to next structure -->
            <member><type>VkRenderPass</type>           <name>renderPass</name></member>
            <member>uint32_t                            <name>attachmentCount</name></member>
            <member>const <type>VkAttachmentView</type>* <name>pAttachments</name></member>
            <member><type>uint32_t</type>               <name>width</name></member>
            <member><type>uint32_t</type>               <name>height</name></member>
            <member><type>uint32_t</type>               <name>layers</name></member>
        </type>
        <type category="struct" name="VkDrawIndirectCmd">
            <member><type>uint32_t</type>               <name>vertexCount</name></member>
            <member><type>uint32_t</type>               <name>instanceCount</name></member>
            <member><type>uint32_t</type>               <name>firstVertex</name></member>
            <member><type>uint32_t</type>               <name>firstInstance</name></member>
        </type>
        <type category="struct" name="VkDrawIndexedIndirectCmd">
            <member><type>uint32_t</type>               <name>indexCount</name></member>
            <member><type>uint32_t</type>               <name>instanceCount</name></member>
            <member><type>uint32_t</type>               <name>firstIndex</name></member>
            <member><type>int32_t</type>                <name>vertexOffset</name></member>
            <member><type>uint32_t</type>               <name>firstInstance</name></member>
        </type>
        <type category="struct" name="VkDispatchIndirectCmd">
            <member><type>uint32_t</type>               <name>x</name></member>
            <member><type>uint32_t</type>               <name>y</name></member>
            <member><type>uint32_t</type>               <name>z</name></member>
        </type>
    </types>

    <!-- SECTION: Vulkan enumerant (token) definitions. -->

    <enums namespace="VK" comment="Misc. hardcoded constants - not an enumerated type">
            <!-- This is part of the header boilerplate -->
        <enum value="256"   name="VK_MAX_PHYSICAL_DEVICE_NAME"/>
        <enum value="16"    name="VK_UUID_LENGTH"/>
        <enum value="256"   name="VK_MAX_EXTENSION_NAME"/>
        <enum value="256"   name="VK_MAX_DESCRIPTION"/>
        <enum value="32"    name="VK_MAX_MEMORY_TYPES"/>
        <enum value="16"    name="VK_MAX_MEMORY_HEAPS"/> <!-- The maximum number of unique memory heaps, each of which supporting 1 or more memory types. -->
        <enum value="MAX_FLOAT" name="VK_LOD_CLAMP_NONE"/>
        <enum value="UINT32_MAX" name="VK_LAST_MIP_LEVEL"/>
        <enum value="UINT32_MAX" name="VK_LAST_ARRAY_SLICE"/>
        <enum value="UINT64_MAX" name="VK_WHOLE_SIZE"/>
        <enum value="UINT32_MAX" name="VK_ATTACHMENT_UNUSED"/>
        <enum value="1"     name="VK_TRUE"/>
        <enum value="0"     name="VK_FALSE"/>
        <enum value="0"     name="VK_NULL_HANDLE"/>
        <enum value="UINT32_MAX" name="VK_QUEUE_FAMILY_IGNORED"/>
    </enums>

    <!-- Unlike OpenGL, most tokens in Vulkan are actual typed enumerants in
         their own numeric namespaces. The "name" attribute is the C enum
         type name, and is pulled in from a <type> definition above
         (slightly clunky, but retains the type / enum distinction). "type"
         attributes of "enum" or "bitmask" indicate that these values should
         be generated inside an appropriate definition. -->

    <enums namespace="VK" name="VkImageLayout" type="enum" expand="VK_IMAGE_LAYOUT">
        <enum value="0"     name="VK_IMAGE_LAYOUT_UNDEFINED"                         comment="Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation)"/>
        <enum value="1"     name="VK_IMAGE_LAYOUT_GENERAL"                           comment="General layout when image can be used for any kind of access"/>
        <enum value="2"     name="VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL"          comment="Optimal layout when image is only used for color attachment read/write"/>
        <enum value="3"     name="VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL"  comment="Optimal layout when image is only used for depth/stencil attachment read/write"/>
        <enum value="4"     name="VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL"   comment="Optimal layout when image is used for read only depth/stencil attachment and shader access"/>
        <enum value="5"     name="VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL"          comment="Optimal layout when image is used for read only shader access"/>
        <enum value="6"     name="VK_IMAGE_LAYOUT_TRANSFER_SOURCE_OPTIMAL"           comment="Optimal layout when image is used only as source of transfer operations"/>
        <enum value="7"     name="VK_IMAGE_LAYOUT_TRANSFER_DESTINATION_OPTIMAL"      comment="Optimal layout when image is used only as destination of transfer operations"/>
    </enums>
    <enums namespace="VK" name="VkAttachmentLoadOp" type="enum" expand="VK_ATTACHMENT_LOAD_OP">
        <enum value="0"     name="VK_ATTACHMENT_LOAD_OP_LOAD"/>
        <enum value="1"     name="VK_ATTACHMENT_LOAD_OP_CLEAR"/>
        <enum value="2"     name="VK_ATTACHMENT_LOAD_OP_DONT_CARE"/>
    </enums>
    <enums namespace="VK" name="VkAttachmentStoreOp" type="enum" expand="VK_ATTACHMENT_STORE_OP">
        <enum value="0"     name="VK_ATTACHMENT_STORE_OP_STORE"/>
        <enum value="1"     name="VK_ATTACHMENT_STORE_OP_DONT_CARE"/>
    </enums>
    <enums namespace="VK" name="VkImageType" type="enum" expand="VK_IMAGE_TYPE">
        <enum value="0"     name="VK_IMAGE_TYPE_1D"/>
        <enum value="1"     name="VK_IMAGE_TYPE_2D"/>
        <enum value="2"     name="VK_IMAGE_TYPE_3D"/>
    </enums>
    <enums namespace="VK" name="VkImageTiling" type="enum" expand="VK_IMAGE_TILING">
        <enum value="0"     name="VK_IMAGE_TILING_LINEAR"/>
        <enum value="1"     name="VK_IMAGE_TILING_OPTIMAL"/>
    </enums>
    <enums namespace="VK" name="VkImageViewType" type="enum" expand="VK_IMAGE_VIEW_TYPE">
        <enum value="0"     name="VK_IMAGE_VIEW_TYPE_1D"/>
        <enum value="1"     name="VK_IMAGE_VIEW_TYPE_2D"/>
        <enum value="2"     name="VK_IMAGE_VIEW_TYPE_3D"/>
        <enum value="3"     name="VK_IMAGE_VIEW_TYPE_CUBE"/>
        <enum value="4"     name="VK_IMAGE_VIEW_TYPE_1D_ARRAY"/>
        <enum value="5"     name="VK_IMAGE_VIEW_TYPE_2D_ARRAY"/>
        <enum value="6"     name="VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"/>
    </enums>
    <enums namespace="VK" name="VkImageAspect" type="enum" expand="VK_IMAGE_ASPECT">
        <enum value="0"     name="VK_IMAGE_ASPECT_COLOR"/>
        <enum value="1"     name="VK_IMAGE_ASPECT_DEPTH"/>
        <enum value="2"     name="VK_IMAGE_ASPECT_STENCIL"/>
        <enum value="3"     name="VK_IMAGE_ASPECT_METADATA"/>
    </enums>
    <enums namespace="VK" name="VkBufferViewType" type="enum" expand="VK_BUFFER_VIEW_TYPE">
        <enum value="0"     name="VK_BUFFER_VIEW_TYPE_RAW"                           comment="Raw buffer without special structure (UBO, SSBO)"/>
        <enum value="1"     name="VK_BUFFER_VIEW_TYPE_FORMATTED"                     comment="Buffer with format (TBO, IBO)"/>
    </enums>
    <enums namespace="VK" name="VkCmdBufferLevel" type="enum" expand="VK_CMD_BUFFER_LEVEL">
        <enum value="0"     name="VK_CMD_BUFFER_LEVEL_PRIMARY"/>
        <enum value="1"     name="VK_CMD_BUFFER_LEVEL_SECONDARY"/>
    </enums>
    <enums namespace="VK" name="VkChannelSwizzle" type="enum" expand="VK_CHANNEL_SWIZZLE">
        <enum value="0"     name="VK_CHANNEL_SWIZZLE_ZERO"/>
        <enum value="1"     name="VK_CHANNEL_SWIZZLE_ONE"/>
        <enum value="2"     name="VK_CHANNEL_SWIZZLE_R"/>
        <enum value="3"     name="VK_CHANNEL_SWIZZLE_G"/>
        <enum value="4"     name="VK_CHANNEL_SWIZZLE_B"/>
        <enum value="5"     name="VK_CHANNEL_SWIZZLE_A"/>
    </enums>
    <enums namespace="VK" name="VkDescriptorType" type="enum" expand="VK_DESCRIPTOR_TYPE">
        <enum value="0"     name="VK_DESCRIPTOR_TYPE_SAMPLER"/>
        <enum value="1"     name="VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"/>
        <enum value="2"     name="VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE"/>
        <enum value="3"     name="VK_DESCRIPTOR_TYPE_STORAGE_IMAGE"/>
        <enum value="4"     name="VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER"/>
        <enum value="5"     name="VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER"/>
        <enum value="6"     name="VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER"/>
        <enum value="7"     name="VK_DESCRIPTOR_TYPE_STORAGE_BUFFER"/>
        <enum value="8"     name="VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC"/>
        <enum value="9"     name="VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC"/>
        <enum value="10"    name="VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT"/>
    </enums>
    <enums namespace="VK" name="VkDescriptorPoolUsage" type="enum" expand="VK_DESCRIPTOR_POOL_USAGE">
        <enum value="0"     name="VK_DESCRIPTOR_POOL_USAGE_ONE_SHOT"/>
        <enum value="1"     name="VK_DESCRIPTOR_POOL_USAGE_DYNAMIC"/>
    </enums>
    <enums namespace="VK" name="VkDescriptorSetUsage" type="enum" expand="VK_DESCRIPTOR_SET_USAGE">
        <enum value="0"     name="VK_DESCRIPTOR_SET_USAGE_ONE_SHOT"/>
        <enum value="1"     name="VK_DESCRIPTOR_SET_USAGE_STATIC"/>
    </enums>
    <enums namespace="VK" name="VkQueryType" type="enum" expand="VK_QUERY_TYPE">
        <enum value="0"     name="VK_QUERY_TYPE_OCCLUSION"/>
        <enum value="1"     name="VK_QUERY_TYPE_PIPELINE_STATISTICS"                 comment="Optional"/>
    </enums>
    <enums namespace="VK" name="VkTimestampType" type="enum" expand="VK_TIMESTAMP_TYPE">
        <enum value="0"     name="VK_TIMESTAMP_TYPE_TOP"/>
        <enum value="1"     name="VK_TIMESTAMP_TYPE_BOTTOM"/>
    </enums>
    <enums namespace="VK" name="VkBorderColor" type="enum" expand="VK_BORDER_COLOR">
        <enum value="0"     name="VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK"/>
        <enum value="1"     name="VK_BORDER_COLOR_INT_TRANSPARENT_BLACK"/>
        <enum value="2"     name="VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK"/>
        <enum value="3"     name="VK_BORDER_COLOR_INT_OPAQUE_BLACK"/>
        <enum value="4"     name="VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE"/>
        <enum value="5"     name="VK_BORDER_COLOR_INT_OPAQUE_WHITE"/>
    </enums>
    <enums namespace="VK" name="VkPipelineBindPoint" type="enum" expand="VK_PIPELINE_BIND_POINT">
        <enum value="0"     name="VK_PIPELINE_BIND_POINT_COMPUTE"/>
        <enum value="1"     name="VK_PIPELINE_BIND_POINT_GRAPHICS"/>
    </enums>
    <enums namespace="VK" name="VkPrimitiveTopology" type="enum" expand="VK_PRIMITIVE_TOPOLOGY">
        <enum value="0"     name="VK_PRIMITIVE_TOPOLOGY_POINT_LIST"/>
        <enum value="1"     name="VK_PRIMITIVE_TOPOLOGY_LINE_LIST"/>
        <enum value="2"     name="VK_PRIMITIVE_TOPOLOGY_LINE_STRIP"/>
        <enum value="3"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST"/>
        <enum value="4"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP"/>
        <enum value="5"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN"/>
        <enum value="6"     name="VK_PRIMITIVE_TOPOLOGY_LINE_LIST_ADJ"/>
        <enum value="7"     name="VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_ADJ"/>
        <enum value="8"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_ADJ"/>
        <enum value="9"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_ADJ"/>
        <enum value="10"    name="VK_PRIMITIVE_TOPOLOGY_PATCH"/>
    </enums>
    <enums namespace="VK" name="VkSharingMode" type="enum" expand="VK_SHARING_MODE">
        <enum value="0"     name="VK_SHARING_MODE_EXCLUSIVE"/>
        <enum value="1"     name="VK_SHARING_MODE_CONCURRENT"/>
    </enums>
    <enums namespace="VK" name="VkIndexType" type="enum" expand="VK_INDEX_TYPE">
        <enum value="0"     name="VK_INDEX_TYPE_UINT16"/>
        <enum value="1"     name="VK_INDEX_TYPE_UINT32"/>
    </enums>
    <enums namespace="VK" name="VkTexFilter" type="enum" expand="VK_TEX_FILTER">
        <enum value="0"     name="VK_TEX_FILTER_NEAREST"/>
        <enum value="1"     name="VK_TEX_FILTER_LINEAR"/>
    </enums>
    <enums namespace="VK" name="VkTexMipmapMode" type="enum" expand="VK_TEX_MIPMAP_MODE">
        <enum value="0"     name="VK_TEX_MIPMAP_MODE_BASE"                           comment="Always choose base level"/>
        <enum value="1"     name="VK_TEX_MIPMAP_MODE_NEAREST"                        comment="Choose nearest mip level"/>
        <enum value="2"     name="VK_TEX_MIPMAP_MODE_LINEAR"                         comment="Linear filter between mip levels"/>
    </enums>
    <enums namespace="VK" name="VkTexAddress" type="enum" expand="VK_TEX_ADDRESS">
        <enum value="0"     name="VK_TEX_ADDRESS_WRAP"/>
        <enum value="1"     name="VK_TEX_ADDRESS_MIRROR"/>
        <enum value="2"     name="VK_TEX_ADDRESS_CLAMP"/>
        <enum value="3"     name="VK_TEX_ADDRESS_MIRROR_ONCE"/>
        <enum value="4"     name="VK_TEX_ADDRESS_CLAMP_BORDER"/>
    </enums>
    <enums namespace="VK" name="VkCompareOp" type="enum" expand="VK_COMPARE_OP">
        <enum value="0"     name="VK_COMPARE_OP_NEVER"/>
        <enum value="1"     name="VK_COMPARE_OP_LESS"/>
        <enum value="2"     name="VK_COMPARE_OP_EQUAL"/>
        <enum value="3"     name="VK_COMPARE_OP_LESS_EQUAL"/>
        <enum value="4"     name="VK_COMPARE_OP_GREATER"/>
        <enum value="5"     name="VK_COMPARE_OP_NOT_EQUAL"/>
        <enum value="6"     name="VK_COMPARE_OP_GREATER_EQUAL"/>
        <enum value="7"     name="VK_COMPARE_OP_ALWAYS"/>
    </enums>
    <enums namespace="VK" name="VkFillMode" type="enum" expand="VK_FILL_MODE">
        <enum value="0"     name="VK_FILL_MODE_POINTS"/>
        <enum value="1"     name="VK_FILL_MODE_WIREFRAME"/>
        <enum value="2"     name="VK_FILL_MODE_SOLID"/>
    </enums>
    <enums namespace="VK" name="VkCullMode" type="enum" expand="VK_CULL_MODE">
        <enum value="0"     name="VK_CULL_MODE_NONE"/>
        <enum value="1"     name="VK_CULL_MODE_FRONT"/>
        <enum value="2"     name="VK_CULL_MODE_BACK"/>
        <enum value="3"     name="VK_CULL_MODE_FRONT_AND_BACK"/>
    </enums>
    <enums namespace="VK" name="VkFrontFace" type="enum" expand="VK_FRONT_FACE">
        <enum value="0"     name="VK_FRONT_FACE_CCW"/>
        <enum value="1"     name="VK_FRONT_FACE_CW"/>
    </enums>
    <enums namespace="VK" name="VkBlend" type="enum" expand="VK_BLEND">
        <enum value="0"     name="VK_BLEND_ZERO"/>
        <enum value="1"     name="VK_BLEND_ONE"/>
        <enum value="2"     name="VK_BLEND_SRC_COLOR"/>
        <enum value="3"     name="VK_BLEND_ONE_MINUS_SRC_COLOR"/>
        <enum value="4"     name="VK_BLEND_DEST_COLOR"/>
        <enum value="5"     name="VK_BLEND_ONE_MINUS_DEST_COLOR"/>
        <enum value="6"     name="VK_BLEND_SRC_ALPHA"/>
        <enum value="7"     name="VK_BLEND_ONE_MINUS_SRC_ALPHA"/>
        <enum value="8"     name="VK_BLEND_DEST_ALPHA"/>
        <enum value="9"     name="VK_BLEND_ONE_MINUS_DEST_ALPHA"/>
        <enum value="10"    name="VK_BLEND_CONSTANT_COLOR"/>
        <enum value="11"    name="VK_BLEND_ONE_MINUS_CONSTANT_COLOR"/>
        <enum value="12"    name="VK_BLEND_CONSTANT_ALPHA"/>
        <enum value="13"    name="VK_BLEND_ONE_MINUS_CONSTANT_ALPHA"/>
        <enum value="14"    name="VK_BLEND_SRC_ALPHA_SATURATE"/>
        <enum value="15"    name="VK_BLEND_SRC1_COLOR"/>
        <enum value="16"    name="VK_BLEND_ONE_MINUS_SRC1_COLOR"/>
        <enum value="17"    name="VK_BLEND_SRC1_ALPHA"/>
        <enum value="18"    name="VK_BLEND_ONE_MINUS_SRC1_ALPHA"/>
    </enums>
    <enums namespace="VK" name="VkBlendOp" type="enum" expand="VK_BLEND_OP">
        <enum value="0"     name="VK_BLEND_OP_ADD"/>
        <enum value="1"     name="VK_BLEND_OP_SUBTRACT"/>
        <enum value="2"     name="VK_BLEND_OP_REVERSE_SUBTRACT"/>
        <enum value="3"     name="VK_BLEND_OP_MIN"/>
        <enum value="4"     name="VK_BLEND_OP_MAX"/>
    </enums>
    <enums namespace="VK" name="VkStencilOp" type="enum" expand="VK_STENCIL_OP">
        <enum value="0"     name="VK_STENCIL_OP_KEEP"/>
        <enum value="1"     name="VK_STENCIL_OP_ZERO"/>
        <enum value="2"     name="VK_STENCIL_OP_REPLACE"/>
        <enum value="3"     name="VK_STENCIL_OP_INC_CLAMP"/>
        <enum value="4"     name="VK_STENCIL_OP_DEC_CLAMP"/>
        <enum value="5"     name="VK_STENCIL_OP_INVERT"/>
        <enum value="6"     name="VK_STENCIL_OP_INC_WRAP"/>
        <enum value="7"     name="VK_STENCIL_OP_DEC_WRAP"/>
    </enums>
    <enums namespace="VK" name="VkLogicOp" type="enum" expand="VK_LOGIC_OP">
        <enum value="0"     name="VK_LOGIC_OP_CLEAR"/>
        <enum value="1"     name="VK_LOGIC_OP_AND"/>
        <enum value="2"     name="VK_LOGIC_OP_AND_REVERSE"/>
        <enum value="3"     name="VK_LOGIC_OP_COPY"/>
        <enum value="4"     name="VK_LOGIC_OP_AND_INVERTED"/>
        <enum value="5"     name="VK_LOGIC_OP_NOOP"/>
        <enum value="6"     name="VK_LOGIC_OP_XOR"/>
        <enum value="7"     name="VK_LOGIC_OP_OR"/>
        <enum value="8"     name="VK_LOGIC_OP_NOR"/>
        <enum value="9"     name="VK_LOGIC_OP_EQUIV"/>
        <enum value="10"    name="VK_LOGIC_OP_INVERT"/>
        <enum value="11"    name="VK_LOGIC_OP_OR_REVERSE"/>
        <enum value="12"    name="VK_LOGIC_OP_COPY_INVERTED"/>
        <enum value="13"    name="VK_LOGIC_OP_OR_INVERTED"/>
        <enum value="14"    name="VK_LOGIC_OP_NAND"/>
        <enum value="15"    name="VK_LOGIC_OP_SET"/>
    </enums>
    <enums namespace="VK" name="VkSystemAllocType" type="enum" expand="VK_SYSTEM_ALLOC_TYPE">
        <enum value="0"     name="VK_SYSTEM_ALLOC_TYPE_API_OBJECT"/>
        <enum value="1"     name="VK_SYSTEM_ALLOC_TYPE_INTERNAL"/>
        <enum value="2"     name="VK_SYSTEM_ALLOC_TYPE_INTERNAL_TEMP"/>
        <enum value="3"     name="VK_SYSTEM_ALLOC_TYPE_INTERNAL_SHADER"/>
        <enum value="4"     name="VK_SYSTEM_ALLOC_TYPE_DEBUG"/>
    </enums>
    <enums namespace="VK" name="VkPhysicalDeviceType" type="enum" expand="VK_PHYSICAL_DEVICE_TYPE">
        <enum value="0"     name="VK_PHYSICAL_DEVICE_TYPE_OTHER"/>
        <enum value="1"     name="VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU"/>
        <enum value="2"     name="VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU"/>
        <enum value="3"     name="VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU"/>
        <enum value="4"     name="VK_PHYSICAL_DEVICE_TYPE_CPU"/>
    </enums>
    <enums namespace="VK" name="VkVertexInputStepRate" type="enum" expand="VK_VERTEX_INPUT_STEP_RATE">
        <enum value="0"     name="VK_VERTEX_INPUT_STEP_RATE_VERTEX"/>
        <enum value="1"     name="VK_VERTEX_INPUT_STEP_RATE_INSTANCE"/>
    </enums>
    <enums namespace="VK" name="VkFormat" type="enum" expand="VK_FORMAT" comment="Vulkan format definitions">
        <enum value="0"     name="VK_FORMAT_UNDEFINED"/>
        <enum value="1"     name="VK_FORMAT_R4G4_UNORM"/>
        <enum value="2"     name="VK_FORMAT_R4G4_USCALED"/>
        <enum value="3"     name="VK_FORMAT_R4G4B4A4_UNORM"/>
        <enum value="4"     name="VK_FORMAT_R4G4B4A4_USCALED"/>
        <enum value="5"     name="VK_FORMAT_R5G6B5_UNORM"/>
        <enum value="6"     name="VK_FORMAT_R5G6B5_USCALED"/>
        <enum value="7"     name="VK_FORMAT_R5G5B5A1_UNORM"/>
        <enum value="8"     name="VK_FORMAT_R5G5B5A1_USCALED"/>
        <enum value="9"     name="VK_FORMAT_R8_UNORM"/>
        <enum value="10"    name="VK_FORMAT_R8_SNORM"/>
        <enum value="11"    name="VK_FORMAT_R8_USCALED"/>
        <enum value="12"    name="VK_FORMAT_R8_SSCALED"/>
        <enum value="13"    name="VK_FORMAT_R8_UINT"/>
        <enum value="14"    name="VK_FORMAT_R8_SINT"/>
        <enum value="15"    name="VK_FORMAT_R8_SRGB"/>
        <enum value="16"    name="VK_FORMAT_R8G8_UNORM"/>
        <enum value="17"    name="VK_FORMAT_R8G8_SNORM"/>
        <enum value="18"    name="VK_FORMAT_R8G8_USCALED"/>
        <enum value="19"    name="VK_FORMAT_R8G8_SSCALED"/>
        <enum value="20"    name="VK_FORMAT_R8G8_UINT"/>
        <enum value="21"    name="VK_FORMAT_R8G8_SINT"/>
        <enum value="22"    name="VK_FORMAT_R8G8_SRGB"/>
        <enum value="23"    name="VK_FORMAT_R8G8B8_UNORM"/>
        <enum value="24"    name="VK_FORMAT_R8G8B8_SNORM"/>
        <enum value="25"    name="VK_FORMAT_R8G8B8_USCALED"/>
        <enum value="26"    name="VK_FORMAT_R8G8B8_SSCALED"/>
        <enum value="27"    name="VK_FORMAT_R8G8B8_UINT"/>
        <enum value="28"    name="VK_FORMAT_R8G8B8_SINT"/>
        <enum value="29"    name="VK_FORMAT_R8G8B8_SRGB"/>
        <enum value="30"    name="VK_FORMAT_R8G8B8A8_UNORM"/>
        <enum value="31"    name="VK_FORMAT_R8G8B8A8_SNORM"/>
        <enum value="32"    name="VK_FORMAT_R8G8B8A8_USCALED"/>
        <enum value="33"    name="VK_FORMAT_R8G8B8A8_SSCALED"/>
        <enum value="34"    name="VK_FORMAT_R8G8B8A8_UINT"/>
        <enum value="35"    name="VK_FORMAT_R8G8B8A8_SINT"/>
        <enum value="36"    name="VK_FORMAT_R8G8B8A8_SRGB"/>
        <enum value="37"    name="VK_FORMAT_R10G10B10A2_UNORM"/>
        <enum value="38"    name="VK_FORMAT_R10G10B10A2_SNORM"/>
        <enum value="39"    name="VK_FORMAT_R10G10B10A2_USCALED"/>
        <enum value="40"    name="VK_FORMAT_R10G10B10A2_SSCALED"/>
        <enum value="41"    name="VK_FORMAT_R10G10B10A2_UINT"/>
        <enum value="42"    name="VK_FORMAT_R10G10B10A2_SINT"/>
        <enum value="43"    name="VK_FORMAT_R16_UNORM"/>
        <enum value="44"    name="VK_FORMAT_R16_SNORM"/>
        <enum value="45"    name="VK_FORMAT_R16_USCALED"/>
        <enum value="46"    name="VK_FORMAT_R16_SSCALED"/>
        <enum value="47"    name="VK_FORMAT_R16_UINT"/>
        <enum value="48"    name="VK_FORMAT_R16_SINT"/>
        <enum value="49"    name="VK_FORMAT_R16_SFLOAT"/>
        <enum value="50"    name="VK_FORMAT_R16G16_UNORM"/>
        <enum value="51"    name="VK_FORMAT_R16G16_SNORM"/>
        <enum value="52"    name="VK_FORMAT_R16G16_USCALED"/>
        <enum value="53"    name="VK_FORMAT_R16G16_SSCALED"/>
        <enum value="54"    name="VK_FORMAT_R16G16_UINT"/>
        <enum value="55"    name="VK_FORMAT_R16G16_SINT"/>
        <enum value="56"    name="VK_FORMAT_R16G16_SFLOAT"/>
        <enum value="57"    name="VK_FORMAT_R16G16B16_UNORM"/>
        <enum value="58"    name="VK_FORMAT_R16G16B16_SNORM"/>
        <enum value="59"    name="VK_FORMAT_R16G16B16_USCALED"/>
        <enum value="60"    name="VK_FORMAT_R16G16B16_SSCALED"/>
        <enum value="61"    name="VK_FORMAT_R16G16B16_UINT"/>
        <enum value="62"    name="VK_FORMAT_R16G16B16_SINT"/>
        <enum value="63"    name="VK_FORMAT_R16G16B16_SFLOAT"/>
        <enum value="64"    name="VK_FORMAT_R16G16B16A16_UNORM"/>
        <enum value="65"    name="VK_FORMAT_R16G16B16A16_SNORM"/>
        <enum value="66"    name="VK_FORMAT_R16G16B16A16_USCALED"/>
        <enum value="67"    name="VK_FORMAT_R16G16B16A16_SSCALED"/>
        <enum value="68"    name="VK_FORMAT_R16G16B16A16_UINT"/>
        <enum value="69"    name="VK_FORMAT_R16G16B16A16_SINT"/>
        <enum value="70"    name="VK_FORMAT_R16G16B16A16_SFLOAT"/>
        <enum value="71"    name="VK_FORMAT_R32_UINT"/>
        <enum value="72"    name="VK_FORMAT_R32_SINT"/>
        <enum value="73"    name="VK_FORMAT_R32_SFLOAT"/>
        <enum value="74"    name="VK_FORMAT_R32G32_UINT"/>
        <enum value="75"    name="VK_FORMAT_R32G32_SINT"/>
        <enum value="76"    name="VK_FORMAT_R32G32_SFLOAT"/>
        <enum value="77"    name="VK_FORMAT_R32G32B32_UINT"/>
        <enum value="78"    name="VK_FORMAT_R32G32B32_SINT"/>
        <enum value="79"    name="VK_FORMAT_R32G32B32_SFLOAT"/>
        <enum value="80"    name="VK_FORMAT_R32G32B32A32_UINT"/>
        <enum value="81"    name="VK_FORMAT_R32G32B32A32_SINT"/>
        <enum value="82"    name="VK_FORMAT_R32G32B32A32_SFLOAT"/>
        <enum value="83"    name="VK_FORMAT_R64_SFLOAT"/>
        <enum value="84"    name="VK_FORMAT_R64G64_SFLOAT"/>
        <enum value="85"    name="VK_FORMAT_R64G64B64_SFLOAT"/>
        <enum value="86"    name="VK_FORMAT_R64G64B64A64_SFLOAT"/>
        <enum value="87"    name="VK_FORMAT_R11G11B10_UFLOAT"/>
        <enum value="88"    name="VK_FORMAT_R9G9B9E5_UFLOAT"/>
        <enum value="89"    name="VK_FORMAT_D16_UNORM"/>
        <enum value="90"    name="VK_FORMAT_D24_UNORM"/>
        <enum value="91"    name="VK_FORMAT_D32_SFLOAT"/>
        <enum value="92"    name="VK_FORMAT_S8_UINT"/>
        <enum value="93"    name="VK_FORMAT_D16_UNORM_S8_UINT"/>
        <enum value="94"    name="VK_FORMAT_D24_UNORM_S8_UINT"/>
        <enum value="95"    name="VK_FORMAT_D32_SFLOAT_S8_UINT"/>
        <enum value="96"    name="VK_FORMAT_BC1_RGB_UNORM"/>
        <enum value="97"    name="VK_FORMAT_BC1_RGB_SRGB"/>
        <enum value="98"    name="VK_FORMAT_BC1_RGBA_UNORM"/>
        <enum value="99"    name="VK_FORMAT_BC1_RGBA_SRGB"/>
        <enum value="100"   name="VK_FORMAT_BC2_UNORM"/>
        <enum value="101"   name="VK_FORMAT_BC2_SRGB"/>
        <enum value="102"   name="VK_FORMAT_BC3_UNORM"/>
        <enum value="103"   name="VK_FORMAT_BC3_SRGB"/>
        <enum value="104"   name="VK_FORMAT_BC4_UNORM"/>
        <enum value="105"   name="VK_FORMAT_BC4_SNORM"/>
        <enum value="106"   name="VK_FORMAT_BC5_UNORM"/>
        <enum value="107"   name="VK_FORMAT_BC5_SNORM"/>
        <enum value="108"   name="VK_FORMAT_BC6H_UFLOAT"/>
        <enum value="109"   name="VK_FORMAT_BC6H_SFLOAT"/>
        <enum value="110"   name="VK_FORMAT_BC7_UNORM"/>
        <enum value="111"   name="VK_FORMAT_BC7_SRGB"/>
        <enum value="112"   name="VK_FORMAT_ETC2_R8G8B8_UNORM"/>
        <enum value="113"   name="VK_FORMAT_ETC2_R8G8B8_SRGB"/>
        <enum value="114"   name="VK_FORMAT_ETC2_R8G8B8A1_UNORM"/>
        <enum value="115"   name="VK_FORMAT_ETC2_R8G8B8A1_SRGB"/>
        <enum value="116"   name="VK_FORMAT_ETC2_R8G8B8A8_UNORM"/>
        <enum value="117"   name="VK_FORMAT_ETC2_R8G8B8A8_SRGB"/>
        <enum value="118"   name="VK_FORMAT_EAC_R11_UNORM"/>
        <enum value="119"   name="VK_FORMAT_EAC_R11_SNORM"/>
        <enum value="120"   name="VK_FORMAT_EAC_R11G11_UNORM"/>
        <enum value="121"   name="VK_FORMAT_EAC_R11G11_SNORM"/>
        <enum value="122"   name="VK_FORMAT_ASTC_4x4_UNORM"/>
        <enum value="123"   name="VK_FORMAT_ASTC_4x4_SRGB"/>
        <enum value="124"   name="VK_FORMAT_ASTC_5x4_UNORM"/>
        <enum value="125"   name="VK_FORMAT_ASTC_5x4_SRGB"/>
        <enum value="126"   name="VK_FORMAT_ASTC_5x5_UNORM"/>
        <enum value="127"   name="VK_FORMAT_ASTC_5x5_SRGB"/>
        <enum value="128"   name="VK_FORMAT_ASTC_6x5_UNORM"/>
        <enum value="129"   name="VK_FORMAT_ASTC_6x5_SRGB"/>
        <enum value="130"   name="VK_FORMAT_ASTC_6x6_UNORM"/>
        <enum value="131"   name="VK_FORMAT_ASTC_6x6_SRGB"/>
        <enum value="132"   name="VK_FORMAT_ASTC_8x5_UNORM"/>
        <enum value="133"   name="VK_FORMAT_ASTC_8x5_SRGB"/>
        <enum value="134"   name="VK_FORMAT_ASTC_8x6_UNORM"/>
        <enum value="135"   name="VK_FORMAT_ASTC_8x6_SRGB"/>
        <enum value="136"   name="VK_FORMAT_ASTC_8x8_UNORM"/>
        <enum value="137"   name="VK_FORMAT_ASTC_8x8_SRGB"/>
        <enum value="138"   name="VK_FORMAT_ASTC_10x5_UNORM"/>
        <enum value="139"   name="VK_FORMAT_ASTC_10x5_SRGB"/>
        <enum value="140"   name="VK_FORMAT_ASTC_10x6_UNORM"/>
        <enum value="141"   name="VK_FORMAT_ASTC_10x6_SRGB"/>
        <enum value="142"   name="VK_FORMAT_ASTC_10x8_UNORM"/>
        <enum value="143"   name="VK_FORMAT_ASTC_10x8_SRGB"/>
        <enum value="144"   name="VK_FORMAT_ASTC_10x10_UNORM"/>
        <enum value="145"   name="VK_FORMAT_ASTC_10x10_SRGB"/>
        <enum value="146"   name="VK_FORMAT_ASTC_12x10_UNORM"/>
        <enum value="147"   name="VK_FORMAT_ASTC_12x10_SRGB"/>
        <enum value="148"   name="VK_FORMAT_ASTC_12x12_UNORM"/>
        <enum value="149"   name="VK_FORMAT_ASTC_12x12_SRGB"/>
        <enum value="150"   name="VK_FORMAT_B4G4R4A4_UNORM"/>
        <enum value="151"   name="VK_FORMAT_B5G5R5A1_UNORM"/>
        <enum value="152"   name="VK_FORMAT_B5G6R5_UNORM"/>
        <enum value="153"   name="VK_FORMAT_B5G6R5_USCALED"/>
        <enum value="154"   name="VK_FORMAT_B8G8R8_UNORM"/>
        <enum value="155"   name="VK_FORMAT_B8G8R8_SNORM"/>
        <enum value="156"   name="VK_FORMAT_B8G8R8_USCALED"/>
        <enum value="157"   name="VK_FORMAT_B8G8R8_SSCALED"/>
        <enum value="158"   name="VK_FORMAT_B8G8R8_UINT"/>
        <enum value="159"   name="VK_FORMAT_B8G8R8_SINT"/>
        <enum value="160"   name="VK_FORMAT_B8G8R8_SRGB"/>
        <enum value="161"   name="VK_FORMAT_B8G8R8A8_UNORM"/>
        <enum value="162"   name="VK_FORMAT_B8G8R8A8_SNORM"/>
        <enum value="163"   name="VK_FORMAT_B8G8R8A8_USCALED"/>
        <enum value="164"   name="VK_FORMAT_B8G8R8A8_SSCALED"/>
        <enum value="165"   name="VK_FORMAT_B8G8R8A8_UINT"/>
        <enum value="166"   name="VK_FORMAT_B8G8R8A8_SINT"/>
        <enum value="167"   name="VK_FORMAT_B8G8R8A8_SRGB"/>
        <enum value="168"   name="VK_FORMAT_B10G10R10A2_UNORM"/>
        <enum value="169"   name="VK_FORMAT_B10G10R10A2_SNORM"/>
        <enum value="170"   name="VK_FORMAT_B10G10R10A2_USCALED"/>
        <enum value="171"   name="VK_FORMAT_B10G10R10A2_SSCALED"/>
        <enum value="172"   name="VK_FORMAT_B10G10R10A2_UINT"/>
        <enum value="173"   name="VK_FORMAT_B10G10R10A2_SINT"/>
    </enums>
    <enums namespace="VK" name="VkShaderStage" type="enum" expand="VK_SHADER_STAGE" comment="Shader stage enumerant">
        <enum value="0"     name="VK_SHADER_STAGE_VERTEX"/>
        <enum value="1"     name="VK_SHADER_STAGE_TESS_CONTROL"/>
        <enum value="2"     name="VK_SHADER_STAGE_TESS_EVALUATION"/>
        <enum value="3"     name="VK_SHADER_STAGE_GEOMETRY"/>
        <enum value="4"     name="VK_SHADER_STAGE_FRAGMENT"/>
        <enum value="5"     name="VK_SHADER_STAGE_COMPUTE"/>
    </enums>
    <enums namespace="VK" name="VkStructureType" type="enum" expand="VK_STRUCTURE_TYPE" comment="Structure type enumerant">
        <enum value="0"     name="VK_STRUCTURE_TYPE_APPLICATION_INFO"/>
        <enum value="1"     name="VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"/>
        <enum value="2"     name="VK_STRUCTURE_TYPE_MEMORY_ALLOC_INFO"/>
        <enum value="3"     name="VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"/>
        <enum value="4"     name="VK_STRUCTURE_TYPE_ATTACHMENT_VIEW_CREATE_INFO"/>
        <enum value="5"     name="VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"/>
        <enum value="6"     name="VK_STRUCTURE_TYPE_SHADER_CREATE_INFO"/>
        <enum value="7"     name="VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"/>
        <enum value="8"     name="VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"/>
        <enum value="9"     name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"/>
        <enum value="10"    name="VK_STRUCTURE_TYPE_DYNAMIC_VIEWPORT_STATE_CREATE_INFO"/>
        <enum value="11"    name="VK_STRUCTURE_TYPE_DYNAMIC_RASTER_STATE_CREATE_INFO"/>
        <enum value="12"    name="VK_STRUCTURE_TYPE_DYNAMIC_COLOR_BLEND_STATE_CREATE_INFO"/>
        <enum value="13"    name="VK_STRUCTURE_TYPE_DYNAMIC_DEPTH_STENCIL_STATE_CREATE_INFO"/>
        <enum value="14"    name="VK_STRUCTURE_TYPE_CMD_BUFFER_CREATE_INFO"/>
        <enum value="15"    name="VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"/>
        <enum value="16"    name="VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"/>
        <enum value="17"    name="VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"/>
        <enum value="18"    name="VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"/>
        <enum value="19"    name="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"/>
        <enum value="20"    name="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"/>
        <enum value="21"    name="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"/>
        <enum value="22"    name="VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"/>
        <enum value="23"    name="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"/>
        <enum value="24"    name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"/>
        <enum value="25"    name="VK_STRUCTURE_TYPE_PIPELINE_RASTER_STATE_CREATE_INFO"/>
        <enum value="26"    name="VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"/>
        <enum value="27"    name="VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"/>
        <enum value="28"    name="VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"/>
        <enum value="29"    name="VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"/>
        <enum value="30"    name="VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"/>
        <enum value="31"    name="VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"/>
        <enum value="32"    name="VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"/>
        <enum value="33"    name="VK_STRUCTURE_TYPE_CMD_BUFFER_BEGIN_INFO"/>
        <enum value="34"    name="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"/>
        <enum value="35"    name="VK_STRUCTURE_TYPE_MEMORY_BARRIER"/>
        <enum value="36"    name="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"/>
        <enum value="37"    name="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"/>
        <enum value="38"    name="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"/>
        <enum value="39"    name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"/>
        <enum value="40"    name="VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"/>
        <enum value="41"    name="VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"/>
        <enum value="42"    name="VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"/>
        <enum value="43"    name="VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"/>
        <enum value="44"    name="VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"/>
        <enum value="45"    name="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION"/>
        <enum value="46"    name="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION"/>
        <enum value="47"    name="VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY"/>
        <enum value="48"    name="VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"/>
        <enum value="49"    name="VK_STRUCTURE_TYPE_CMD_POOL_CREATE_INFO"/>
    </enums>
    <enums namespace="VK" name="VkRenderPassContents" type="enum" expand="VK_RENDER_PASS_CONTENTS">
        <enum value="0"     name="VK_RENDER_PASS_CONTENTS_INLINE"/>
        <enum value="1"     name="VK_RENDER_PASS_CONTENTS_SECONDARY_CMD_BUFFERS"/>
    </enums>
    <enums namespace="VK" name="VkResult" type="enum" expand="VK_RESULT" comment="Error and return codes">
        <!-- Return codes for successful operation execution (positive values) -->
        <enum value="0"     name="VK_SUCCESS"/>
        <enum value="1"     name="VK_UNSUPPORTED"/>
        <enum value="2"     name="VK_NOT_READY"/>
        <enum value="3"     name="VK_TIMEOUT"/>
        <enum value="4"     name="VK_EVENT_SET"/>
        <enum value="5"     name="VK_EVENT_RESET"/>
        <enum value="6"     name="VK_INCOMPLETE"/>
        <!-- Error codes (negative values) -->
        <enum value="-1"    name="VK_ERROR_UNKNOWN"/>
        <enum value="-2"    name="VK_ERROR_UNAVAILABLE"/>
        <enum value="-3"    name="VK_ERROR_INITIALIZATION_FAILED"/>
        <enum value="-4"    name="VK_ERROR_OUT_OF_HOST_MEMORY"/>
        <enum value="-5"    name="VK_ERROR_OUT_OF_DEVICE_MEMORY"/>
        <enum value="-6"    name="VK_ERROR_DEVICE_ALREADY_CREATED"/>
        <enum value="-7"    name="VK_ERROR_DEVICE_LOST"/>
        <enum value="-8"    name="VK_ERROR_INVALID_POINTER"/>
        <enum value="-9"    name="VK_ERROR_INVALID_VALUE"/>
        <enum value="-10"   name="VK_ERROR_INVALID_HANDLE"/>
        <enum value="-11"   name="VK_ERROR_INVALID_ORDINAL"/>
        <enum value="-12"   name="VK_ERROR_INVALID_MEMORY_SIZE"/>
        <enum value="-13"   name="VK_ERROR_INVALID_EXTENSION"/>
        <enum value="-14"   name="VK_ERROR_INVALID_FLAGS"/>
        <enum value="-15"   name="VK_ERROR_INVALID_ALIGNMENT"/>
        <enum value="-16"   name="VK_ERROR_INVALID_FORMAT"/>
        <enum value="-17"   name="VK_ERROR_INVALID_IMAGE"/>
        <enum value="-18"   name="VK_ERROR_INVALID_DESCRIPTOR_SET_DATA"/>
        <enum value="-19"   name="VK_ERROR_INVALID_QUEUE_TYPE"/>
        <enum value="-20"   name="VK_ERROR_UNSUPPORTED_SHADER_IL_VERSION"/>
        <enum value="-21"   name="VK_ERROR_BAD_SHADER_CODE"/>
        <enum value="-22"   name="VK_ERROR_BAD_PIPELINE_DATA"/>
        <enum value="-23"   name="VK_ERROR_NOT_MAPPABLE"/>
        <enum value="-24"   name="VK_ERROR_MEMORY_MAP_FAILED"/>
        <enum value="-25"   name="VK_ERROR_MEMORY_UNMAP_FAILED"/>
        <enum value="-26"   name="VK_ERROR_INCOMPATIBLE_DEVICE"/>
        <enum value="-27"   name="VK_ERROR_INCOMPATIBLE_DRIVER"/>
        <enum value="-28"   name="VK_ERROR_INCOMPLETE_COMMAND_BUFFER"/>
        <enum value="-29"   name="VK_ERROR_BUILDING_COMMAND_BUFFER"/>
        <enum value="-30"   name="VK_ERROR_MEMORY_NOT_BOUND"/>
        <enum value="-31"   name="VK_ERROR_INCOMPATIBLE_QUEUE"/>
        <enum value="-32"   name="VK_ERROR_INVALID_LAYER"/>
            <unused start="-33"/>
    </enums>
    <!-- Flags -->
    <enums namespace="VK" name="VkDeviceCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_DEVICE_CREATE_VALIDATION_BIT"/>
    </enums>
    <enums namespace="VK" name="VkQueueFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_QUEUE_GRAPHICS_BIT"                             comment="Queue supports graphics operations"/>
        <enum bitpos="1"    name="VK_QUEUE_COMPUTE_BIT"                              comment="Queue supports compute operations"/>
        <enum bitpos="2"    name="VK_QUEUE_DMA_BIT"                                  comment="Queue supports DMA operations"/>
        <enum bitpos="3"    name="VK_QUEUE_SPARSE_MEMMGR_BIT"                        comment="Queue supports sparse resource memory management operations"/>
        <enum bitpos="30"   name="VK_QUEUE_EXTENDED_BIT"                             comment="Extended queue"/>
    </enums>
    <enums namespace="VK" name="VkMemoryPropertyFlagBits" type="bitmask">
        <enum value="0"     name="VK_MEMORY_PROPERTY_DEVICE_ONLY"                    comment="If otherwise stated, then allocate memory on device"/>
        <enum bitpos="0"    name="VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT"               comment="Memory should be mappable by host"/>
        <enum bitpos="1"    name="VK_MEMORY_PROPERTY_HOST_NON_COHERENT_BIT"          comment="Memory may not have i/o coherency so vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges must be used flush/invalidate host cache"/>
        <enum bitpos="2"    name="VK_MEMORY_PROPERTY_HOST_UNCACHED_BIT"              comment="Memory should not be cached by the host"/>
        <enum bitpos="3"    name="VK_MEMORY_PROPERTY_HOST_WRITE_COMBINED_BIT"        comment="Memory should support host write combining"/>
        <enum bitpos="4"    name="VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT"           comment="Memory may be allocated by the driver when it is required"/>
    </enums>
    <enums namespace="VK" name="VkMemoryHeapFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_MEMORY_HEAP_HOST_LOCAL"                         comment="If set, heap represents host memory"/>
    </enums>
    <enums namespace="VK" name="VkMemoryOutputFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_MEMORY_OUTPUT_HOST_WRITE_BIT"                   comment="Controls output coherency of host writes"/>
        <enum bitpos="1"    name="VK_MEMORY_OUTPUT_SHADER_WRITE_BIT"                 comment="Controls output coherency of generic shader writes"/>
        <enum bitpos="2"    name="VK_MEMORY_OUTPUT_COLOR_ATTACHMENT_BIT"             comment="Controls output coherency of color attachment writes"/>
        <enum bitpos="3"    name="VK_MEMORY_OUTPUT_DEPTH_STENCIL_ATTACHMENT_BIT"     comment="Controls output coherency of depth/stencil attachment writes"/>
        <enum bitpos="4"    name="VK_MEMORY_OUTPUT_TRANSFER_BIT"                     comment="Controls output coherency of transfer operations"/>
    </enums>
    <enums namespace="VK" name="VkMemoryInputFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_MEMORY_INPUT_HOST_READ_BIT"                     comment="Controls input coherency of host reads"/>
        <enum bitpos="1"    name="VK_MEMORY_INPUT_INDIRECT_COMMAND_BIT"              comment="Controls input coherency of indirect command reads"/>
        <enum bitpos="2"    name="VK_MEMORY_INPUT_INDEX_FETCH_BIT"                   comment="Controls input coherency of index fetches"/>
        <enum bitpos="3"    name="VK_MEMORY_INPUT_VERTEX_ATTRIBUTE_FETCH_BIT"        comment="Controls input coherency of vertex attribute fetches"/>
        <enum bitpos="4"    name="VK_MEMORY_INPUT_UNIFORM_READ_BIT"                  comment="Controls input coherency of uniform buffer reads"/>
        <enum bitpos="5"    name="VK_MEMORY_INPUT_SHADER_READ_BIT"                   comment="Controls input coherency of generic shader reads"/>
        <enum bitpos="6"    name="VK_MEMORY_INPUT_COLOR_ATTACHMENT_BIT"              comment="Controls input coherency of color attachment reads"/>
        <enum bitpos="7"    name="VK_MEMORY_INPUT_DEPTH_STENCIL_ATTACHMENT_BIT"      comment="Controls input coherency of depth/stencil attachment reads"/>
        <enum bitpos="8"    name="VK_MEMORY_INPUT_INPUT_ATTACHMENT_BIT"              comment="Controls input coherency of input attachment reads"/>
        <enum bitpos="9"    name="VK_MEMORY_INPUT_TRANSFER_BIT"                      comment="Controls input coherency of transfer operations"/>
    </enums>
    <enums namespace="VK" name="VkBufferUsageFlagBits" type="bitmask">
        <enum value="0"     name="VK_BUFFER_USAGE_GENERAL"                           comment="No special usage"/>
        <enum bitpos="0"    name="VK_BUFFER_USAGE_TRANSFER_SOURCE_BIT"               comment="Can be used as a source of transfer operations"/>
        <enum bitpos="1"    name="VK_BUFFER_USAGE_TRANSFER_DESTINATION_BIT"          comment="Can be used as a destination of transfer operations"/>
        <enum bitpos="2"    name="VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT"          comment="Can be used as TBO"/>
        <enum bitpos="3"    name="VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT"          comment="Can be used as IBO"/>
        <enum bitpos="4"    name="VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT"                comment="Can be used as UBO"/>
        <enum bitpos="5"    name="VK_BUFFER_USAGE_STORAGE_BUFFER_BIT"                comment="Can be used as SSBO"/>
        <enum bitpos="6"    name="VK_BUFFER_USAGE_INDEX_BUFFER_BIT"                  comment="Can be used as source of fixed function index fetch (index buffer)"/>
        <enum bitpos="7"    name="VK_BUFFER_USAGE_VERTEX_BUFFER_BIT"                 comment="Can be used as source of fixed function vertex fetch (VBO)"/>
        <enum bitpos="8"    name="VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT"               comment="Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer)"/>
    </enums>
    <enums namespace="VK" name="VkBufferCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_BUFFER_CREATE_SPARSE_BIT"                       comment="Buffer should support sparse backing"/>
        <enum bitpos="1"    name="VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT"             comment="Buffer should support sparse backing with partial residency"/>
        <enum bitpos="2"    name="VK_BUFFER_CREATE_SPARSE_ALIASED_BIT"               comment="Buffer should support constent data access to physical memory blocks mapped into multiple locations of sparse buffers"/>
    </enums>
    <enums namespace="VK" name="VkShaderStageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SHADER_STAGE_VERTEX_BIT"/>
        <enum bitpos="1"    name="VK_SHADER_STAGE_TESS_CONTROL_BIT"/>
        <enum bitpos="2"    name="VK_SHADER_STAGE_TESS_EVALUATION_BIT"/>
        <enum bitpos="3"    name="VK_SHADER_STAGE_GEOMETRY_BIT"/>
        <enum bitpos="4"    name="VK_SHADER_STAGE_FRAGMENT_BIT"/>
        <enum bitpos="5"    name="VK_SHADER_STAGE_COMPUTE_BIT"/>
        <enum value="0x7FFFFFFF" name="VK_SHADER_STAGE_ALL"/>
    </enums>
    <enums namespace="VK" name="VkImageUsageFlagBits" type="bitmask">
        <enum value="0"     name="VK_IMAGE_USAGE_GENERAL"                            comment="No special usage"/>
        <enum bitpos="0"    name="VK_IMAGE_USAGE_TRANSFER_SOURCE_BIT"                comment="Can be used as a source of transfer operations"/>
        <enum bitpos="1"    name="VK_IMAGE_USAGE_TRANSFER_DESTINATION_BIT"           comment="Can be used as a destination of transfer operations"/>
        <enum bitpos="2"    name="VK_IMAGE_USAGE_SAMPLED_BIT"                        comment="Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)"/>
        <enum bitpos="3"    name="VK_IMAGE_USAGE_STORAGE_BIT"                        comment="Can be used as storage image (STORAGE_IMAGE descriptor type)"/>
        <enum bitpos="4"    name="VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT"               comment="Can be used as framebuffer color attachment"/>
        <enum bitpos="5"    name="VK_IMAGE_USAGE_DEPTH_STENCIL_BIT"                  comment="Can be used as framebuffer depth/stencil attachment"/>
        <enum bitpos="6"    name="VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT"           comment="Image data not needed outside of rendering"/>
        <enum bitpos="7"    name="VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT"               comment="Can be used as framebuffer input attachment"/>
    </enums>
    <enums namespace="VK" name="VkImageCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_IMAGE_CREATE_SPARSE_BIT"                        comment="Image should support sparse backing"/>
        <enum bitpos="1"    name="VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"              comment="Image should support sparse backing with partial residency"/>
        <enum bitpos="2"    name="VK_IMAGE_CREATE_SPARSE_ALIASED_BIT"                comment="Image should support constent data access to physical memory blocks mapped into multiple locations of sparse images"/>
        <enum bitpos="3"    name="VK_IMAGE_CREATE_INVARIANT_DATA_BIT"/>
        <enum bitpos="4"    name="VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT"                comment="Allows image views to have different format than the base image"/>
        <enum bitpos="5"    name="VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT"               comment="Allows creating image views with cube type from the created image"/>
    </enums>
    <enums namespace="VK" name="VkAttachmentViewCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_ATTACHMENT_VIEW_CREATE_READ_ONLY_DEPTH_BIT"/>
        <enum bitpos="1"    name="VK_ATTACHMENT_VIEW_CREATE_READ_ONLY_STENCIL_BIT"/>
    </enums>
    <enums namespace="VK" name="VkPipelineCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT"/>
        <enum bitpos="1"    name="VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT"/>
        <enum bitpos="2"    name="VK_PIPELINE_CREATE_DERIVATIVE_BIT"/>
    </enums>
    <enums namespace="VK" name="VkChannelFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_CHANNEL_R_BIT"/>
        <enum bitpos="1"    name="VK_CHANNEL_G_BIT"/>
        <enum bitpos="2"    name="VK_CHANNEL_B_BIT"/>
        <enum bitpos="3"    name="VK_CHANNEL_A_BIT"/>
    </enums>
    <enums namespace="VK" name="VkFenceCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_FENCE_CREATE_SIGNALED_BIT"/>
    </enums>
    <enums namespace="VK" name="VkFormatFeatureFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT"               comment="Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)"/>
        <enum bitpos="1"    name="VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT"               comment="Format can be used for storage images (STORAGE_IMAGE descriptor type)"/>
        <enum bitpos="2"    name="VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT"        comment="Format supports atomic operations in case it's used for storage images"/>
        <enum bitpos="3"    name="VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT"        comment="Format can be used for uniform texel buffers (TBOs)"/>
        <enum bitpos="4"    name="VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT"        comment="Format can be used for storage texel buffers (IBOs)"/>
        <enum bitpos="5"    name="VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT" comment="Format supports atomic operations in case it's used for storage texel buffers"/>
        <enum bitpos="6"    name="VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT"               comment="Format can be used for vertex buffers (VBOs)"/>
        <enum bitpos="7"    name="VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT"            comment="Format can be used for color attachment images"/>
        <enum bitpos="8"    name="VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT"      comment="Format supports blending in case it's used for color attachment images"/>
        <enum bitpos="9"    name="VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT"    comment="Format can be used for depth/stencil attachment images"/>
        <enum bitpos="10"   name="VK_FORMAT_FEATURE_CONVERSION_BIT"                  comment="Format can be used as the source or destination of format converting blits"/>
    </enums>
    <enums namespace="VK" name="VkQueryControlFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_QUERY_CONTROL_CONSERVATIVE_BIT"                 comment="Allow conservative results to be collected by the query"/>
    </enums>
    <enums namespace="VK" name="VkQueryResultFlagBits" type="bitmask">
        <enum value="0"     name="VK_QUERY_RESULT_DEFAULT"                           comment="Results of the queries are immediately written to the destination buffer as 32-bit values"/>
        <enum bitpos="0"    name="VK_QUERY_RESULT_64_BIT"                            comment="Results of the queries are written to the destination buffer as 64-bit values"/>
        <enum bitpos="1"    name="VK_QUERY_RESULT_WAIT_BIT"                          comment="Results of the queries are waited on before proceeding with the result copy"/>
        <enum bitpos="2"    name="VK_QUERY_RESULT_WITH_AVAILABILITY_BIT"             comment="Besides the results of the query, the availability of the results is also written"/>
        <enum bitpos="3"    name="VK_QUERY_RESULT_PARTIAL_BIT"                       comment="Copy the partial results of the query even if the final results aren't available"/>
    </enums>
    <enums namespace="VK" name="VkCmdBufferOptimizeFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_CMD_BUFFER_OPTIMIZE_SMALL_BATCH_BIT"/>
        <enum bitpos="1"    name="VK_CMD_BUFFER_OPTIMIZE_PIPELINE_SWITCH_BIT"/>
        <enum bitpos="2"    name="VK_CMD_BUFFER_OPTIMIZE_ONE_TIME_SUBMIT_BIT"/>
        <enum bitpos="3"    name="VK_CMD_BUFFER_OPTIMIZE_DESCRIPTOR_SET_SWITCH_BIT"/>
        <enum bitpos="4"    name="VK_CMD_BUFFER_OPTIMIZE_NO_SIMULTANEOUS_USE_BIT"    comment="Only one call to the secondary command buffer will exist at any given time"/>
    </enums>
    <enums namespace="VK" name="VkQueryPipelineStatisticFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_QUERY_PIPELINE_STATISTIC_IA_VERTICES_BIT"       comment="Optional"/>
        <enum bitpos="1"    name="VK_QUERY_PIPELINE_STATISTIC_IA_PRIMITIVES_BIT"     comment="Optional"/>
        <enum bitpos="2"    name="VK_QUERY_PIPELINE_STATISTIC_VS_INVOCATIONS_BIT"    comment="Optional"/>
        <enum bitpos="3"    name="VK_QUERY_PIPELINE_STATISTIC_GS_INVOCATIONS_BIT"    comment="Optional"/>
        <enum bitpos="4"    name="VK_QUERY_PIPELINE_STATISTIC_GS_PRIMITIVES_BIT"     comment="Optional"/>
        <enum bitpos="5"    name="VK_QUERY_PIPELINE_STATISTIC_C_INVOCATIONS_BIT"     comment="Optional"/>
        <enum bitpos="6"    name="VK_QUERY_PIPELINE_STATISTIC_C_PRIMITIVES_BIT"      comment="Optional"/>
        <enum bitpos="7"    name="VK_QUERY_PIPELINE_STATISTIC_FS_INVOCATIONS_BIT"    comment="Optional"/>
        <enum bitpos="8"    name="VK_QUERY_PIPELINE_STATISTIC_TCS_PATCHES_BIT"       comment="Optional"/>
        <enum bitpos="9"    name="VK_QUERY_PIPELINE_STATISTIC_TES_INVOCATIONS_BIT"   comment="Optional"/>
        <enum bitpos="10"   name="VK_QUERY_PIPELINE_STATISTIC_CS_INVOCATIONS_BIT"    comment="Optional"/>
    </enums>
    <enums namespace="VK" name="VkImageAspectFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_IMAGE_ASPECT_COLOR_BIT"/>
        <enum bitpos="1"    name="VK_IMAGE_ASPECT_DEPTH_BIT"/>
        <enum bitpos="2"    name="VK_IMAGE_ASPECT_STENCIL_BIT"/>
        <enum bitpos="3"    name="VK_IMAGE_ASPECT_METADATA_BIT"/>
    </enums>
    <enums namespace="VK" name="VkSparseMemoryBindFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SPARSE_MEMORY_BIND_REPLICATE_64KIB_BLOCK_BIT"   comment="Replicate the first 64 KiB memory block to the entire bind rage"/>
    </enums>
    <enums namespace="VK" name="VkSparseImageFormatFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SPARSE_IMAGE_FMT_SINGLE_MIPTAIL_BIT"            comment="Image uses a single miptail region for all array slices"/>
        <enum bitpos="1"    name="VK_SPARSE_IMAGE_FMT_ALIGNED_MIP_SIZE_BIT"          comment="Image requires mip levels to be an exact multiple of the sparse iamge block size for non-mip-tail levels."/>
        <enum bitpos="2"    name="VK_SPARSE_IMAGE_FMT_NONSTD_BLOCK_SIZE_BIT"         comment="Image uses a non-standard sparse block size"/>
    </enums>
    <enums namespace="VK" name="VkPipelineStageFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT"                 comment="Before subsequent commands are processed"/>
        <enum bitpos="1"    name="VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT"               comment="Draw/DispatchIndirect command fetch"/>
        <enum bitpos="2"    name="VK_PIPELINE_STAGE_VERTEX_INPUT_BIT"                comment="Vertex/index fetch"/>
        <enum bitpos="3"    name="VK_PIPELINE_STAGE_VERTEX_SHADER_BIT"               comment="Vertex shading"/>
        <enum bitpos="4"    name="VK_PIPELINE_STAGE_TESS_CONTROL_SHADER_BIT"         comment="Tessellation control shading"/>
        <enum bitpos="5"    name="VK_PIPELINE_STAGE_TESS_EVALUATION_SHADER_BIT"      comment="Tessellation evaluation shading"/>
        <enum bitpos="6"    name="VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"             comment="Geometry shading"/>
        <enum bitpos="7"    name="VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT"             comment="Fragment shading"/>
        <enum bitpos="8"    name="VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT"        comment="Early fragment (depth/stencil) tests"/>
        <enum bitpos="9"    name="VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT"         comment="Late fragment (depth/stencil) tests"/>
        <enum bitpos="10"   name="VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT"     comment="Color attachment writes"/>
        <enum bitpos="11"   name="VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT"              comment="Compute shading"/>
        <enum bitpos="12"   name="VK_PIPELINE_STAGE_TRANSFER_BIT"                    comment="Transfer/copy operations"/>
        <enum bitpos="13"   name="VK_PIPELINE_STAGE_TRANSITION_BIT"                  comment="Resource transition commands"/>
        <enum bitpos="14"   name="VK_PIPELINE_STAGE_HOST_BIT"                        comment="Indicates host (CPU) is a source/sink of the dependency"/>
        <enum value="0x000007FF" name="VK_PIPELINE_STAGE_ALL_GRAPHICS"               comment="All stages of the graphics pipeline"/>
        <enum value="0x00003FFF" name="VK_PIPELINE_STAGE_ALL_GPU_COMMANDS"           comment="All graphics, compute, copy, and transition commands"/>
    </enums>
    <enums namespace="VK" name="VkSubpassDescriptionFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_SUBPASS_DESCRIPTION_NO_OVERDRAW_BIT"/>
    </enums>
    <enums namespace="VK" name="VkCmdPoolCreateFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_CMD_POOL_CREATE_TRANSIENT_BIT"                  comment="Command buffers have a short lifetime"/>
        <enum bitpos="1"    name="VK_CMD_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"       comment="Command buffers may release their memory individually"/>
    </enums>
    <enums namespace="VK" name="VkCmdPoolResetFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_CMD_POOL_RESET_RELEASE_RESOURCES"               comment="Release resources owned by the pool"/>
    </enums>
    <enums namespace="VK" name="VkCmdBufferResetFlagBits" type="bitmask">
        <enum bitpos="0"    name="VK_CMD_BUFFER_RESET_RELEASE_RESOURCES"             comment="Release resources owned by the buffer"/>
    </enums>

    <!-- SECTION: Vulkan command definitions -->
    <commands namespace="vk">
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateInstance</name></proto>
            <param>const <type>VkInstanceCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkInstance</type>* <name>pInstance</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyInstance</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkEnumeratePhysicalDevices</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param><type>uint32_t</type>* <name>pPhysicalDeviceCount</name></param>
            <param><type>VkPhysicalDevice</type>* <name>pPhysicalDevices</name></param>
        </command>
        <command>
            <proto><type>PFN_vkVoidFunction</type> <name>vkGetDeviceProcAddr</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const char* <name>pName</name></param>
        </command>
        <command>
            <proto><type>PFN_vkVoidFunction</type> <name>vkGetInstanceProcAddr</name></proto>
            <param><type>VkInstance</type> <name>instance</name></param>
            <param>const char* <name>pName</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceProperties</type>* <name>pProperties</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceQueueFamilyProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type>* <name>pCount</name></param>
            <param><type>VkQueueFamilyProperties</type>* <name>pQueueFamilyProperties</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceMemoryProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceMemoryProperties</type>* <name>pMemoryProperties</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceFeatures</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceFeatures</type>* <name>pFeatures</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceFormatProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkFormatProperties</type>* <name>pFormatProperties</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceImageFormatProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkImageType</type> <name>type</name></param>
            <param><type>VkImageTiling</type> <name>tiling</name></param>
            <param><type>VkImageUsageFlags</type> <name>usage</name></param>
            <param><type>VkImageFormatProperties</type>* <name>pImageFormatProperties</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceLimits</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkPhysicalDeviceLimits</type>* <name>pLimits</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateDevice</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>VkDeviceCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkDevice</type>* <name>pDevice</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyDevice</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkGetGlobalLayerProperties</name></proto>
            <param><type>uint32_t</type>* <name>pCount</name></param>
            <param><type>VkLayerProperties</type>* <name>pProperties</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkGetGlobalExtensionProperties</name></proto>
            <param>const <type>char</type>* <name>pLayerName</name></param>
            <param><type>uint32_t</type>* <name>pCount</name></param>
            <param><type>VkExtensionProperties</type>* <name>pProperties</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceLayerProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>uint32_t</type>* <name>pCount</name></param>
            <param><type>VkLayerProperties</type>* <name>pProperties</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceExtensionProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param>const <type>char</type>* <name>pLayerName</name></param>
            <param><type>uint32_t</type>* <name>pCount</name></param>
            <param><type>VkExtensionProperties</type>* <name>pProperties</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkGetDeviceQueue</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
            <param><type>uint32_t</type> <name>queueIndex</name></param>
            <param><type>VkQueue</type>* <name>pQueue</name></param>
        </command>
        <command threadsafe="app">
            <proto><type>VkResult</type> <name>vkQueueSubmit</name></proto>
            <param modified="true"><type>VkQueue</type> <name>queue</name></param>
            <param><type>uint32_t</type> <name>cmdBufferCount</name></param>
            <param>const <type>VkCmdBuffer</type>* <name>pCmdBuffers</name></param>
            <param><type>VkFence</type> <name>fence</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkQueueWaitIdle</name></proto>
            <param><type>VkQueue</type> <name>queue</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDeviceWaitIdle</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkAllocMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkMemoryAllocInfo</type>* <name>pAllocInfo</name></param>
            <param><type>VkDeviceMemory</type>* <name>pMem</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkFreeMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDeviceMemory</type> <name>mem</name></param>
        </command>
        <command threadsafe="app">
            <proto><type>VkResult</type> <name>vkMapMemory</name></proto>
            <param modified="true"><type>VkDevice</type> <name>device</name></param>
            <param modified="true"><type>VkDeviceMemory</type> <name>mem</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>VkDeviceSize</type> <name>size</name></param>
            <param><type>VkMemoryMapFlags</type> <name>flags</name></param>
            <param>void** <name>ppData</name></param>
        </command>
        <command threadsafe="app">
            <proto><type>VkResult</type> <name>vkUnmapMemory</name></proto>
            <param modified="true"><type>VkDevice</type> <name>device</name></param>
            <param modified="true"><type>VkDeviceMemory</type> <name>mem</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkFlushMappedMemoryRanges</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>memRangeCount</name></param>
            <param>const <type>VkMappedMemoryRange</type>* <name>pMemRanges</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkInvalidateMappedMemoryRanges</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>memRangeCount</name></param>
            <param>const <type>VkMappedMemoryRange</type>* <name>pMemRanges</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkGetDeviceMemoryCommitment</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDeviceMemory</type> <name>memory</name></param>
            <param><type>VkDeviceSize</type>* <name>pCommittedMemoryInBytes</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkGetBufferMemoryRequirements</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkMemoryRequirements</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkBindBufferMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceMemory</type> <name>mem</name></param>
            <param><type>VkDeviceSize</type> <name>memOffset</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkGetImageMemoryRequirements</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>VkMemoryRequirements</type>* <name>pMemoryRequirements</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkBindImageMemory</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>VkDeviceMemory</type> <name>mem</name></param>
            <param><type>VkDeviceSize</type> <name>memOffset</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkGetImageSparseMemoryRequirements</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>uint32_t</type>* <name>pNumRequirements</name></param>
            <param><type>VkSparseImageMemoryRequirements</type>* <name>pSparseMemoryRequirements</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSparseImageFormatProperties</name></proto>
            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
            <param><type>VkFormat</type> <name>format</name></param>
            <param><type>VkImageType</type> <name>type</name></param>
            <param><type>uint32_t</type> <name>samples</name></param>
            <param><type>VkImageUsageFlags</type> <name>usage</name></param>
            <param><type>VkImageTiling</type> <name>tiling</name></param>
            <param><type>uint32_t</type>* <name>pNumProperties</name></param>
            <param><type>VkSparseImageFormatProperties</type>* <name>pProperties</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkQueueBindSparseBufferMemory</name></proto>
            <param><type>VkQueue</type> <name>queue</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>uint32_t</type> <name>numBindings</name></param>
            <param>const <type>VkSparseMemoryBindInfo</type>* <name>pBindInfo</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkQueueBindSparseImageOpaqueMemory</name></proto>
            <param><type>VkQueue</type> <name>queue</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>uint32_t</type> <name>numBindings</name></param>
            <param>const <type>VkSparseMemoryBindInfo</type>* <name>pBindInfo</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkQueueBindSparseImageMemory</name></proto>
            <param><type>VkQueue</type> <name>queue</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>uint32_t</type> <name>numBindings</name></param>
            <param>const <type>VkSparseImageMemoryBindInfo</type>* <name>pBindInfo</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateFence</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkFenceCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkFence</type>* <name>pFence</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyFence</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkFence</type> <name>fence</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkResetFences</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>fenceCount</name></param>
            <param>const <type>VkFence</type>* <name>pFences</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkGetFenceStatus</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkFence</type> <name>fence</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkWaitForFences</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>fenceCount</name></param>
            <param>const <type>VkFence</type>* <name>pFences</name></param>
            <param><type>VkBool32</type> <name>waitAll</name></param>
            <param><type>uint64_t</type> <name>timeout</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateSemaphore</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSemaphoreCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkSemaphore</type>* <name>pSemaphore</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroySemaphore</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkSemaphore</type> <name>semaphore</name></param>
        </command>
        <command threadsafe="app">
            <proto><type>VkResult</type> <name>vkQueueSignalSemaphore</name></proto>
            <param><type>VkQueue</type> <name>queue</name></param>
            <param modified="true"><type>VkSemaphore</type> <name>semaphore</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkQueueWaitSemaphore</name></proto>
            <param><type>VkQueue</type> <name>queue</name></param>
            <param><type>VkSemaphore</type> <name>semaphore</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateEvent</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkEventCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkEvent</type>* <name>pEvent</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyEvent</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkEvent</type> <name>event</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkGetEventStatus</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkEvent</type> <name>event</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkSetEvent</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkEvent</type> <name>event</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkResetEvent</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkEvent</type> <name>event</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateQueryPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkQueryPoolCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkQueryPool</type>* <name>pQueryPool</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyQueryPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkGetQueryPoolResults</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>startQuery</name></param>
            <param><type>uint32_t</type> <name>queryCount</name></param>
            <param><type>size_t</type>* <name>pDataSize</name></param>
            <param>void* <name>pData</name></param>
            <param><type>VkQueryResultFlags</type> <name>flags</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateBuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkBufferCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkBuffer</type>* <name>pBuffer</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyBuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateBufferView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkBufferViewCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkBufferView</type>* <name>pView</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyBufferView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkBufferView</type> <name>bufferView</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateImage</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImageCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkImage</type>* <name>pImage</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyImage</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkGetImageSubresourceLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param>const <type>VkImageSubresource</type>* <name>pSubresource</name></param>
            <param><type>VkSubresourceLayout</type>* <name>pLayout</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateImageView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkImageViewCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkImageView</type>* <name>pView</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyImageView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkImageView</type> <name>imageView</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateAttachmentView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkAttachmentViewCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkAttachmentView</type>* <name>pView</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyAttachmentView</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkAttachmentView</type> <name>attachmentView</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkCreateShaderModule</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkShaderModuleCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkShaderModule</type>* <name>pShaderModule</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkDestroyShaderModule</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkShaderModule</type> <name>shaderModule</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateShader</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkShaderCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkShader</type>* <name>pShader</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyShader</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkShader</type> <name>shader</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkCreatePipelineCache</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPipelineCacheCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkPipelineCache</type>* <name>pPipelineCache</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkDestroyPipelineCache</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPipelineCache</type> <name>pipelineCache</name></param>
        </command>
        <command>
            <proto><type>size_t</type> <name>vkGetPipelineCacheSize</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPipelineCache</type> <name>pipelineCache</name></param>
        </command>
        <command>
            <proto>VkResult <name>vkGetPipelineCacheData</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param>void* <name>pData</name></param>
        </command>
        <command>
            <proto>VkResult <name>vkMergePipelineCaches</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPipelineCache</type> <name>destCache</name></param>
            <param><type>uint32_t</type> <name>srcCacheCount</name></param>
            <param>const <type>VkPipelineCache</type>* <name>pSrcCaches</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkCreateGraphicsPipelines</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param><type>uint32_t</type> <name>count</name></param>
            <param>const <type>VkGraphicsPipelineCreateInfo</type>* <name>pCreateInfos</name></param>
            <param><type>VkPipeline</type>* <name>pPipelines</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkCreateComputePipelines</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPipelineCache</type> <name>pipelineCache</name></param>
            <param><type>uint32_t</type> <name>count</name></param>
            <param>const <type>VkComputePipelineCreateInfo</type>* <name>pCreateInfos</name></param>
            <param><type>VkPipeline</type>* <name>pPipelines</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyPipeline</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPipeline</type> <name>pipeline</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreatePipelineLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkPipelineLayoutCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkPipelineLayout</type>* <name>pPipelineLayout</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyPipelineLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkPipelineLayout</type> <name>pipelineLayout</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateSampler</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkSamplerCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkSampler</type>* <name>pSampler</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroySampler</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkSampler</type> <name>sampler</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateDescriptorSetLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDescriptorSetLayoutCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkDescriptorSetLayout</type>* <name>pSetLayout</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyDescriptorSetLayout</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDescriptorSetLayout</type> <name>descriptorSetLayout</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateDescriptorPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDescriptorPoolUsage</type> <name>poolUsage</name></param>
            <param><type>uint32_t</type> <name>maxSets</name></param>
            <param>const <type>VkDescriptorPoolCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkDescriptorPool</type>* <name>pDescriptorPool</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyDescriptorPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
        </command>
        <command threadsafe="app">
            <proto><type>VkResult</type> <name>vkResetDescriptorPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param modified="true"><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
        </command>
        <command threadsafe="app">
            <proto><type>VkResult</type> <name>vkAllocDescriptorSets</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param modified="true"><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
            <param><type>VkDescriptorSetUsage</type> <name>setUsage</name></param>
            <param><type>uint32_t</type> <name>count</name></param>
            <param>const <type>VkDescriptorSetLayout</type>* <name>pSetLayouts</name></param>
            <param><type>VkDescriptorSet</type>* <name>pDescriptorSets</name></param>
        </command>
        <command threadsafe="app">
            <proto><type>VkResult</type> <name>vkFreeDescriptorSets</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param modified="true"><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
            <param><type>uint32_t</type> <name>count</name></param>
            <param>const <type>VkDescriptorSet</type>* <name>pDescriptorSets</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkUpdateDescriptorSets</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>uint32_t</type> <name>writeCount</name></param>
            <param>const <type>VkWriteDescriptorSet</type>* <name>pDescriptorWrites</name></param>
            <param><type>uint32_t</type> <name>copyCount</name></param>
            <param>const <type>VkCopyDescriptorSet</type>* <name>pDescriptorCopies</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateDynamicViewportState</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDynamicViewportStateCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkDynamicViewportState</type>* <name>pState</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyDynamicViewportState</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDynamicViewportState</type> <name>dynamicViewportState</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateDynamicRasterState</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDynamicRasterStateCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkDynamicRasterState</type>* <name>pState</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyDynamicRasterState</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDynamicRasterState</type> <name>dynamicRasterState</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateDynamicColorBlendState</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDynamicColorBlendStateCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkDynamicColorBlendState</type>* <name>pState</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyDynamicColorBlendState</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDynamicColorBlendState</type> <name>dynamicColorBlendState</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateDynamicDepthStencilState</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkDynamicDepthStencilStateCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkDynamicDepthStencilState</type>* <name>pState</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyDynamicDepthStencilState</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkDynamicDepthStencilState</type> <name>dynamicDepthStencilState</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateFramebuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkFramebufferCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkFramebuffer</type>* <name>pFramebuffer</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyFramebuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkFramebuffer</type> <name>framebuffer</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateRenderPass</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkRenderPassCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkRenderPass</type>* <name>pRenderPass</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyRenderPass</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkRenderPass</type> <name>renderPass</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkGetRenderAreaGranularity</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkRenderPass</type> <name>renderPass</name></param>
            <param><type>VkExtent2D</type>* <name>pGranularity</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkCreateCommandPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkCmdPoolCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkCmdPool</type>* <name>pCmdPool</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkDestroyCommandPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkCmdPool</type> <name>cmdPool</name></param>
        </command>
        <command>
            <proto><type>VkResult</type> <name>vkResetCommandPool</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkCmdPool</type> <name>cmdPool</name></param>
            <param><type>VkCmdPoolResetFlags</type> <name>flags</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkCreateCommandBuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param>const <type>VkCmdBufferCreateInfo</type>* <name>pCreateInfo</name></param>
            <param><type>VkCmdBuffer</type>* <name>pCmdBuffer</name></param>
        </command>
        <command threadsafe="system">
            <proto><type>VkResult</type> <name>vkDestroyCommandBuffer</name></proto>
            <param><type>VkDevice</type> <name>device</name></param>
            <param><type>VkCmdBuffer</type> <name>commandBuffer</name></param>
        </command>
        <command threadsafe="app">
            <proto><type>VkResult</type> <name>vkBeginCommandBuffer</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param>const <type>VkCmdBufferBeginInfo</type>* <name>pBeginInfo</name></param>
        </command>
        <command threadsafe="app">
            <proto><type>VkResult</type> <name>vkEndCommandBuffer</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
        </command>
        <command threadsafe="app">
            <proto><type>VkResult</type> <name>vkResetCommandBuffer</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkCmdBufferResetFlags</type> <name>flags</name></param>
        </command>
        <command threadsafe="app" queues="graphics,compute" renderpass="both">
            <proto>void <name>vkCmdBindPipeline</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
            <param><type>VkPipeline</type> <name>pipeline</name></param>
        </command>
        <command threadsafe="app" queues="graphics" renderpass="inside">
            <proto>void <name>vkCmdBindDynamicViewportState</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkDynamicViewportState</type> <name>dynamicViewportState</name></param>
        </command>
        <command threadsafe="app" queues="graphics" renderpass="inside">
            <proto>void <name>vkCmdBindDynamicRasterState</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkDynamicRasterState</type> <name>dynamicRasterState</name></param>
        </command>
        <command threadsafe="app" queues="graphics" renderpass="inside">
            <proto>void <name>vkCmdBindDynamicColorBlendState</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkDynamicColorBlendState</type> <name>dynamicColorBlendState</name></param>
        </command>
        <command threadsafe="app" queues="graphics" renderpass="inside">
            <proto>void <name>vkCmdBindDynamicDepthStencilState</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkDynamicDepthStencilState</type> <name>dynamicDepthStencilState</name></param>
        </command>
        <command threadsafe="app" queues="graphics,compute" renderpass="both">
            <proto>void <name>vkCmdBindDescriptorSets</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
            <param><type>VkPipelineLayout</type> <name>layout</name></param>
            <param><type>uint32_t</type> <name>firstSet</name></param>
            <param><type>uint32_t</type> <name>setCount</name></param>
            <param>const <type>VkDescriptorSet</type>* <name>pDescriptorSets</name></param>
            <param><type>uint32_t</type> <name>dynamicOffsetCount</name></param>
            <param>const <type>uint32_t</type>* <name>pDynamicOffsets</name></param>
        </command>
        <command threadsafe="app" queues="graphics" renderpass="inside">
            <proto>void <name>vkCmdBindIndexBuffer</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>VkIndexType</type> <name>indexType</name></param>
        </command>
        <command threadsafe="app" queues="graphics" renderpass="inside">
            <proto>void <name>vkCmdBindVertexBuffers</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>uint32_t</type> <name>startBinding</name></param>
            <param><type>uint32_t</type> <name>bindingCount</name></param>
            <param>const <type>VkBuffer</type>* <name>pBuffers</name></param>
            <param>const <type>VkDeviceSize</type>* <name>pOffsets</name></param>
        </command>
        <command threadsafe="app" queues="graphics" renderpass="inside">
            <proto>void <name>vkCmdDraw</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>uint32_t</type> <name>firstVertex</name></param>
            <param><type>uint32_t</type> <name>vertexCount</name></param>
            <param><type>uint32_t</type> <name>firstInstance</name></param>
            <param><type>uint32_t</type> <name>instanceCount</name></param>
        </command>
        <command threadsafe="app" queues="graphics" renderpass="inside">
            <proto>void <name>vkCmdDrawIndexed</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>uint32_t</type> <name>firstIndex</name></param>
            <param><type>uint32_t</type> <name>indexCount</name></param>
            <param><type>int32_t</type> <name>vertexOffset</name></param>
            <param><type>uint32_t</type> <name>firstInstance</name></param>
            <param><type>uint32_t</type> <name>instanceCount</name></param>
        </command>
        <command threadsafe="app" queues="graphics" renderpass="inside">
            <proto>void <name>vkCmdDrawIndirect</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>uint32_t</type> <name>count</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command threadsafe="app" queues="graphics" renderpass="inside">
            <proto>void <name>vkCmdDrawIndexedIndirect</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
            <param><type>uint32_t</type> <name>count</name></param>
            <param><type>uint32_t</type> <name>stride</name></param>
        </command>
        <command threadsafe="app" queues="compute">
            <proto>void <name>vkCmdDispatch</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>uint32_t</type> <name>x</name></param>
            <param><type>uint32_t</type> <name>y</name></param>
            <param><type>uint32_t</type> <name>z</name></param>
        </command>
        <command threadsafe="app" queues="compute">
            <proto>void <name>vkCmdDispatchIndirect</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkBuffer</type> <name>buffer</name></param>
            <param><type>VkDeviceSize</type> <name>offset</name></param>
        </command>
        <command threadsafe="app" queues="dma,graphics,compute">
            <proto>void <name>vkCmdCopyBuffer</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkBuffer</type> <name>srcBuffer</name></param>
            <param><type>VkBuffer</type> <name>destBuffer</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param>const <type>VkBufferCopy</type>* <name>pRegions</name></param>
        </command>
        <command threadsafe="app" queues="dma,graphics,compute">
            <proto>void <name>vkCmdCopyImage</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkImage</type> <name>srcImage</name></param>
            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
            <param><type>VkImage</type> <name>destImage</name></param>
            <param><type>VkImageLayout</type> <name>destImageLayout</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param>const <type>VkImageCopy</type>* <name>pRegions</name></param>
        </command>
        <command threadsafe="app" queues="graphics,compute" renderpass="outside">
            <proto>void <name>vkCmdBlitImage</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkImage</type> <name>srcImage</name></param>
            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
            <param><type>VkImage</type> <name>destImage</name></param>
            <param><type>VkImageLayout</type> <name>destImageLayout</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param>const <type>VkImageBlit</type>* <name>pRegions</name></param>
            <param><type>VkTexFilter</type> <name>filter</name></param>
        </command>
        <command threadsafe="app" queues="dma,graphics,compute">
            <proto>void <name>vkCmdCopyBufferToImage</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkBuffer</type> <name>srcBuffer</name></param>
            <param><type>VkImage</type> <name>destImage</name></param>
            <param><type>VkImageLayout</type> <name>destImageLayout</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param>const <type>VkBufferImageCopy</type>* <name>pRegions</name></param>
        </command>
        <command threadsafe="app" queues="dma,graphics,compute">
            <proto>void <name>vkCmdCopyImageToBuffer</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkImage</type> <name>srcImage</name></param>
            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
            <param><type>VkBuffer</type> <name>destBuffer</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param>const <type>VkBufferImageCopy</type>* <name>pRegions</name></param>
        </command>
        <command threadsafe="app" queues="dma,graphics,compute">
            <proto>void <name>vkCmdUpdateBuffer</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkBuffer</type> <name>destBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>destOffset</name></param>
            <param><type>VkDeviceSize</type> <name>dataSize</name></param>
            <param>const <type>uint32_t</type>* <name>pData</name></param>
        </command>
        <command threadsafe="app" queues="dma,graphics,compute">
            <proto>void <name>vkCmdFillBuffer</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkBuffer</type> <name>destBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>destOffset</name></param>
            <param><type>VkDeviceSize</type> <name>fillSize</name></param>
            <param><type>uint32_t</type> <name>data</name></param>
        </command>
        <command threadsafe="app" queues="dma,graphics,compute" renderpass="outside">
            <proto>void <name>vkCmdClearColorImage</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
            <param>const <type>VkClearColorValue</type>* <name>pColor</name></param>
            <param><type>uint32_t</type> <name>rangeCount</name></param>
            <param>const <type>VkImageSubresourceRange</type>* <name>pRanges</name></param>
        </command>
        <command threadsafe="app" queues="graphics" renderpass="outside">
            <proto>void <name>vkCmdClearDepthStencilImage</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkImage</type> <name>image</name></param>
            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
            <param><type>float</type> <name>depth</name></param>
            <param><type>uint32_t</type> <name>stencil</name></param>
            <param><type>uint32_t</type> <name>rangeCount</name></param>
            <param>const <type>VkImageSubresourceRange</type>* <name>pRanges</name></param>
        </command>
        <command threadsafe="app" queues="graphics" renderpass="inside">
            <proto>void <name>vkCmdClearColorAttachment</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>uint32_t</type> <name>colorAttachment</name></param>
            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
            <param>const <type>VkClearColorValue</type>* <name>pColor</name></param>
            <param><type>uint32_t</type> <name>rectCount</name></param>
            <param>const <type>VkRect3D</type>* <name>pRects</name></param>
        </command>
        <command threadsafe="app" queues="graphics" renderpass="inside">
            <proto>void <name>vkCmdClearDepthStencilAttachment</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkImageAspectFlags</type> <name>imageAspectMask</name></param>
            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
            <param><type>float</type> <name>depth</name></param>
            <param><type>uint32_t</type> <name>stencil</name></param>
            <param><type>uint32_t</type> <name>rectCount</name></param>
            <param>const <type>VkRect3D</type>* <name>pRects</name></param>
        </command>
        <command threadsafe="app" queues="graphics,compute" renderpass="outside">
            <proto>void <name>vkCmdResolveImage</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkImage</type> <name>srcImage</name></param>
            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
            <param><type>VkImage</type> <name>destImage</name></param>
            <param><type>VkImageLayout</type> <name>destImageLayout</name></param>
            <param><type>uint32_t</type> <name>regionCount</name></param>
            <param>const <type>VkImageResolve</type>* <name>pRegions</name></param>
        </command>
        <command threadsafe="app" queues="graphics,compute">
            <proto>void <name>vkCmdSetEvent</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkEvent</type> <name>event</name></param>
            <param><type>VkPipelineStageFlags</type> <name>stageMask</name></param>
        </command>
        <command threadsafe="app" queues="graphics,compute">
            <proto>void <name>vkCmdResetEvent</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkEvent</type> <name>event</name></param>
            <param><type>VkPipelineStageFlags</type> <name>stageMask</name></param>
        </command>
        <command threadsafe="app" queues="graphics,compute">
            <proto>void <name>vkCmdWaitEvents</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>uint32_t</type> <name>eventCount</name></param>
            <param>const <type>VkEvent</type>* <name>pEvents</name></param>
            <param><type>VkPipelineStageFlags</type> <name>srcStageMask</name></param>
            <param><type>VkPipelineStageFlags</type> <name>destStageMask</name></param>
            <param><type>uint32_t</type> <name>memBarrierCount</name></param>
            <param>const void* const* <name>ppMemBarriers</name></param>
        </command>
        <command threadsafe="app" queues="graphics,compute">
            <proto>void <name>vkCmdPipelineBarrier</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkPipelineStageFlags</type> <name>srcStageMask</name></param>
            <param><type>VkPipelineStageFlags</type> <name>destStageMask</name></param>
            <param><type>VkBool32</type> <name>byRegion</name></param>
            <param><type>uint32_t</type> <name>memBarrierCount</name></param>
            <param>const void* const* <name>ppMemBarriers</name></param>
        </command>
        <command threadsafe="app" queues="graphics,compute">
            <proto>void <name>vkCmdBeginQuery</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>slot</name></param>
            <param><type>VkQueryControlFlags</type> <name>flags</name></param>
        </command>
        <command threadsafe="app" queues="graphics,compute">
            <proto>void <name>vkCmdEndQuery</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>slot</name></param>
        </command>
        <command threadsafe="app" queues="graphics,compute">
            <proto>void <name>vkCmdResetQueryPool</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>startQuery</name></param>
            <param><type>uint32_t</type> <name>queryCount</name></param>
        </command>
        <command threadsafe="app" queues="graphics,compute">
            <proto>void <name>vkCmdWriteTimestamp</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkTimestampType</type> <name>timestampType</name></param>
            <param><type>VkBuffer</type> <name>destBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>destOffset</name></param>
        </command>
        <command threadsafe="app" queues="graphics,compute">
            <proto>void <name>vkCmdCopyQueryPoolResults</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkQueryPool</type> <name>queryPool</name></param>
            <param><type>uint32_t</type> <name>startQuery</name></param>
            <param><type>uint32_t</type> <name>queryCount</name></param>
            <param><type>VkBuffer</type> <name>destBuffer</name></param>
            <param><type>VkDeviceSize</type> <name>destOffset</name></param>
            <param><type>VkDeviceSize</type> <name>destStride</name></param>
            <param><type>VkQueryResultFlags</type> <name>flags</name></param>
        </command>
        <command>
            <proto>void <name>vkCmdPushConstants</name></proto>
            <param><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkPipelineLayout</type> <name>layout</name></param>
            <param><type>VkShaderStageFlags</type> <name>stageFlags</name></param>
            <param><type>uint32_t</type> <name>start</name></param>
            <param><type>uint32_t</type> <name>length</name></param>
            <param>const void* <name>values</name></param>
        </command>
        <command threadsafe="app" queues="graphics" renderpass="outside">
            <proto>void <name>vkCmdBeginRenderPass</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param>const <type>VkRenderPassBeginInfo</type>* <name>pRenderPassBegin</name></param>
            <param><type>VkRenderPassContents</type> <name>contents</name></param>
        </command>
        <command>
            <proto>void <name>vkCmdNextSubpass</name></proto>
            <param><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>VkRenderPassContents</type> <name>contents</name></param>
        </command>
        <command threadsafe="app" queues="graphics" renderpass="inside">
            <proto>void <name>vkCmdEndRenderPass</name></proto>
            <param modified="true"><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
        </command>
        <command>
            <proto>void <name>vkCmdExecuteCommands</name></proto>
            <param><type>VkCmdBuffer</type> <name>cmdBuffer</name></param>
            <param><type>uint32_t</type> <name>cmdBuffersCount</name></param>
            <param>const <type>VkCmdBuffer</type>* <name>pCmdBuffers</name></param>
        </command>
    </commands>

    <!-- SECTION: Vulkan API interface definitions -->
    <feature api="vulkan" name="VK_VERSION_1_0" number="1.0">
        <require comment="Header boilerplate">
            <type name="vk_platform"/>
        </require>
        <require comment="API version">
            <type name="VK_API_VERSION"/>
        </require>
        <require comment="API constants">
            <enum name="VK_LOD_CLAMP_NONE"/>
            <enum name="VK_LAST_MIP_LEVEL"/>
            <enum name="VK_LAST_ARRAY_SLICE"/>
            <enum name="VK_WHOLE_SIZE"/>
            <enum name="VK_ATTACHMENT_UNUSED"/>
            <enum name="VK_TRUE"/>
            <enum name="VK_FALSE"/>
            <enum name="VK_NULL_HANDLE"/>
            <enum name="VK_QUEUE_FAMILY_IGNORED"/>
        </require>
        <require comment="Device initialization">
            <command name="vkCreateInstance"/>
            <command name="vkDestroyInstance"/>
            <command name="vkEnumeratePhysicalDevices"/>
            <command name="vkGetPhysicalDeviceFeatures"/>
            <command name="vkGetPhysicalDeviceFormatProperties"/>
            <command name="vkGetPhysicalDeviceImageFormatProperties"/>
            <command name="vkGetPhysicalDeviceLimits"/>
            <command name="vkGetPhysicalDeviceProperties"/>
            <command name="vkGetPhysicalDeviceQueueFamilyProperties"/>
            <command name="vkGetPhysicalDeviceMemoryProperties"/>
            <command name="vkGetInstanceProcAddr"/>
            <command name="vkGetDeviceProcAddr"/>
        </require>
        <require comment="Device functions">
            <command name="vkCreateDevice"/>
            <command name="vkDestroyDevice"/>
        </require>
        <require comment="Extension discovery functions">
            <command name="vkGetGlobalExtensionProperties"/>
            <command name="vkGetPhysicalDeviceExtensionProperties"/>
        </require>
        <require comment="Layer discovery functions">
            <command name="vkGetGlobalLayerProperties"/>
            <command name="vkGetPhysicalDeviceLayerProperties"/>
        </require>
        <require comment="Queue functions">
            <command name="vkGetDeviceQueue"/>
            <command name="vkQueueSubmit"/>
            <command name="vkQueueWaitIdle"/>
            <command name="vkDeviceWaitIdle"/>
        </require>
        <require comment="Memory functions">
            <command name="vkAllocMemory"/>
            <command name="vkFreeMemory"/>
            <command name="vkMapMemory"/>
            <command name="vkUnmapMemory"/>
            <command name="vkFlushMappedMemoryRanges"/>
            <command name="vkInvalidateMappedMemoryRanges"/>
            <command name="vkGetDeviceMemoryCommitment"/>
        </require>
        <require comment="Memory management API functions">
            <command name="vkBindBufferMemory"/>
            <command name="vkBindImageMemory"/>
            <command name="vkGetBufferMemoryRequirements"/>
            <command name="vkGetImageMemoryRequirements"/>
        </require>
        <require comment="Sparse resource memory management API functions">
            <command name="vkGetImageSparseMemoryRequirements"/>
            <command name="vkGetPhysicalDeviceSparseImageFormatProperties"/>
            <command name="vkQueueBindSparseBufferMemory"/>
            <command name="vkQueueBindSparseImageOpaqueMemory"/>
            <command name="vkQueueBindSparseImageMemory"/>
        </require>
        <require comment="Fence functions">
            <command name="vkCreateFence"/>
            <command name="vkDestroyFence"/>
            <command name="vkResetFences"/>
            <command name="vkGetFenceStatus"/>
            <command name="vkWaitForFences"/>
        </require>
        <require comment="Queue semaphore functions">
            <command name="vkCreateSemaphore"/>
            <command name="vkDestroySemaphore"/>
            <command name="vkQueueSignalSemaphore"/>
            <command name="vkQueueWaitSemaphore"/>
        </require>
        <require comment="Event functions">
            <command name="vkCreateEvent"/>
            <command name="vkDestroyEvent"/>
            <command name="vkGetEventStatus"/>
            <command name="vkSetEvent"/>
            <command name="vkResetEvent"/>
        </require>
        <require comment="Query functions">
            <command name="vkCreateQueryPool"/>
            <command name="vkDestroyQueryPool"/>
            <command name="vkGetQueryPoolResults"/>
        </require>
        <require comment="Buffer functions">
            <command name="vkCreateBuffer"/>
            <command name="vkDestroyBuffer"/>
        </require>
        <require comment="Buffer view functions">
            <command name="vkCreateBufferView"/>
            <command name="vkDestroyBufferView"/>
        </require>
        <require comment="Image functions">
            <command name="vkCreateImage"/>
            <command name="vkDestroyImage"/>
            <command name="vkGetImageSubresourceLayout"/>
        </require>
        <require comment="Image view functions">
            <command name="vkCreateImageView"/>
            <command name="vkDestroyImageView"/>
            <command name="vkCreateAttachmentView"/>
            <command name="vkDestroyAttachmentView"/>
        </require>
        <require comment="Shader functions">
            <command name="vkCreateShaderModule"/>
            <command name="vkDestroyShaderModule"/>
            <command name="vkCreateShader"/>
            <command name="vkDestroyShader"/>
        </require>
        <require comment="Pipeline Cache functions">
            <command name="vkCreatePipelineCache"/>
            <command name="vkDestroyPipelineCache"/>
            <command name="vkGetPipelineCacheSize"/>
            <command name="vkGetPipelineCacheData"/>
            <command name="vkMergePipelineCaches"/>
        </require>

        <require comment="Pipeline functions">
            <command name="vkCreateGraphicsPipelines"/>
            <command name="vkCreateComputePipelines"/>
            <command name="vkDestroyPipeline"/>
        </require>
        <require comment="Pipeline layout functions">
            <command name="vkCreatePipelineLayout"/>
            <command name="vkDestroyPipelineLayout"/>
        </require>
        <require comment="Sampler functions">
            <command name="vkCreateSampler"/>
            <command name="vkDestroySampler"/>
        </require>
        <require comment="Descriptor set functions">
            <command name="vkCreateDescriptorSetLayout"/>
            <command name="vkDestroyDescriptorSetLayout"/>
            <command name="vkCreateDescriptorPool"/>
            <command name="vkDestroyDescriptorPool"/>
            <command name="vkResetDescriptorPool"/>
            <command name="vkAllocDescriptorSets"/>
            <command name="vkFreeDescriptorSets"/>
            <command name="vkUpdateDescriptorSets"/>
        </require>
        <require comment="State object functions">
            <command name="vkCreateDynamicViewportState"/>
            <command name="vkDestroyDynamicViewportState"/>
            <command name="vkCreateDynamicRasterState"/>
            <command name="vkDestroyDynamicRasterState"/>
            <command name="vkCreateDynamicColorBlendState"/>
            <command name="vkDestroyDynamicColorBlendState"/>
            <command name="vkCreateDynamicDepthStencilState"/>
            <command name="vkDestroyDynamicDepthStencilState"/>
        </require>
        <require comment="Pass functions">
            <command name="vkCreateFramebuffer"/>
            <command name="vkDestroyFramebuffer"/>
            <command name="vkCreateRenderPass"/>
            <command name="vkDestroyRenderPass"/>
            <command name="vkGetRenderAreaGranularity"/>
        </require>
        <require comment="Command pool functions">
            <command name="vkCreateCommandPool"/>
            <command name="vkDestroyCommandPool"/>
            <command name="vkResetCommandPool"/>
        </require>
        <require comment="Command buffer functions">
            <command name="vkCreateCommandBuffer"/>
            <command name="vkDestroyCommandBuffer"/>
            <command name="vkBeginCommandBuffer"/>
            <command name="vkEndCommandBuffer"/>
            <command name="vkResetCommandBuffer"/>
        </require>
        <require comment="Command buffer building functions">
            <command name="vkCmdBindPipeline"/>
            <command name="vkCmdBindDynamicViewportState"/>
            <command name="vkCmdBindDynamicRasterState"/>
            <command name="vkCmdBindDynamicColorBlendState"/>
            <command name="vkCmdBindDynamicDepthStencilState"/>
            <command name="vkCmdBindDescriptorSets"/>
            <command name="vkCmdBindIndexBuffer"/>
            <command name="vkCmdBindVertexBuffers"/>
            <command name="vkCmdDraw"/>
            <command name="vkCmdDrawIndexed"/>
            <command name="vkCmdDrawIndirect"/>
            <command name="vkCmdDrawIndexedIndirect"/>
            <command name="vkCmdDispatch"/>
            <command name="vkCmdDispatchIndirect"/>
            <command name="vkCmdCopyBuffer"/>
            <command name="vkCmdCopyImage"/>
            <command name="vkCmdBlitImage"/>
            <command name="vkCmdCopyBufferToImage"/>
            <command name="vkCmdCopyImageToBuffer"/>
            <command name="vkCmdUpdateBuffer"/>
            <command name="vkCmdFillBuffer"/>
            <command name="vkCmdClearColorImage"/>
            <command name="vkCmdClearDepthStencilImage"/>
            <command name="vkCmdClearColorAttachment"/>
            <command name="vkCmdClearDepthStencilAttachment"/>
            <command name="vkCmdResolveImage"/>
            <command name="vkCmdSetEvent"/>
            <command name="vkCmdResetEvent"/>
            <command name="vkCmdWaitEvents"/>
            <command name="vkCmdPipelineBarrier"/>
            <command name="vkCmdBeginQuery"/>
            <command name="vkCmdEndQuery"/>
            <command name="vkCmdResetQueryPool"/>
            <command name="vkCmdWriteTimestamp"/>
            <command name="vkCmdCopyQueryPoolResults"/>
            <command name="vkCmdPushConstants"/>
            <command name="vkCmdBeginRenderPass"/>
            <command name="vkCmdNextSubpass"/>
            <command name="vkCmdEndRenderPass"/>
            <command name="vkCmdExecuteCommands"/>
        </require>
        <require comment="Types not directly used by the API">
            <!-- Include <type name="typename"/> here for e.g. structs that
                 are not parameter types of commands, but still need to be
                 defined in the API.
             -->
            <type name="VkBufferMemoryBarrier"/>
            <type name="VkDispatchIndirectCmd"/>
            <type name="VkDrawIndexedIndirectCmd"/>
            <type name="VkDrawIndirectCmd"/>
            <type name="VkImageMemoryBarrier"/>
            <type name="VkMemoryBarrier"/>
        </require>
    </feature>

    <!-- SECTION: Vulkan extension interface definitions (none yet) -->
</registry>