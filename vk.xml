<?xml version="1.0" encoding="UTF-8"?>
<registry>
  <comment>
    Copyright (c) 2015 The Khronos Group Inc.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and/or associated documentation files (the
    "Materials"), to deal in the Materials without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Materials, and to
    permit persons to whom the Materials are furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Materials.

    THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.

    ------------------------------------------------------------------------

    This file, vk.xml, is the Vulkan API Registry.
  </comment>

  <!-- SECTION: Vulkan type definitions -->
  <types>
    <!-- Awkward way of inserting a bunch of preprocessor boilerplate -->
    <type name="vk_platform">
      #include "vk_platform.h"
      #define VK_MAKE_VERSION(major, minor, patch) \
      ((major &lt;&lt; 22) | (minor &lt;&lt; 12) | patch)

      // Vulkan API version supported by this file
      #define VK_API_VERSION VK_MAKE_VERSION(0, 111, 0)

      #if defined (__cplusplus) &amp;&amp; (VK_UINTPTRLEAST64_MAX == UINTPTR_MAX)
      #define VK_TYPE_SAFE_COMPATIBLE_HANDLES 1
      #endif

      #if defined(VK_TYPE_SAFE_COMPATIBLE_HANDLES) &amp;&amp; !defined(VK_DISABLE_TYPE_SAFE_HANDLES)
      #define VK_DEFINE_PTR_HANDLE(_obj) struct _obj##_T { char _dummy; }; typedef _obj##_T* _obj;
      #define VK_DEFINE_PTR_SUBCLASS_HANDLE(_obj, _base) struct _obj##_T : public _base##_T {}; typedef _obj##_T* _obj;

      #define VK_DEFINE_BASE_HANDLE(_obj) VK_DEFINE_PTR_HANDLE(_obj)
      #define VK_DEFINE_DISP_SUBCLASS_HANDLE(_obj, _base) VK_DEFINE_PTR_SUBCLASS_HANDLE(_obj, _base)
      #define VK_DEFINE_NONDISP_SUBCLASS_HANDLE(_obj, _base) VK_DEFINE_PTR_SUBCLASS_HANDLE(_obj, _base)
      #else
      #define VK_DEFINE_BASE_HANDLE(_obj) typedef VkUintPtrLeast64 _obj;
      #define VK_DEFINE_DISP_SUBCLASS_HANDLE(_obj, _base) typedef uintptr_t _obj;
      #define VK_DEFINE_NONDISP_SUBCLASS_HANDLE(_obj, _base) typedef VkUintPtrLeast64 _obj;
      #endif
    </type>
    <type requires="vk_platform" name="VkDeviceSize"/>
    <type requires="vk_platform" name="VkSampleMask"/>
    <type requires="vk_platform" name="VkFlags"/>
    <!-- Basic C types, pulled in via vk_platform.h -->
    <type requires="vk_platform" name="char"/>
    <type requires="vk_platform" name="float"/>
    <type requires="vk_platform" name="bool32_t"/>
    <type requires="vk_platform" name="uint32_t"/>
    <type requires="vk_platform" name="uint64_t"/>
    <type requires="vk_platform" name="int32_t"/>
    <type requires="vk_platform" name="size_t"/>
    <!-- Bitfield types -->
    <type requires="VkDeviceCreateFlagBits"               >
      typedef <type>VkFlags</type> <name>VkDeviceCreateFlags</name>;
    </type>
    <!-- Device creation flags -->
    <type requires="VkQueueFlagBits"                      >
      typedef <type>VkFlags</type> <name>VkQueueFlags</name>;
    </type>
    <!-- Queue capabilities -->
    <type requires="VkMemoryPropertyFlagBits"             >
      typedef <type>VkFlags</type> <name>VkMemoryPropertyFlags</name>;
    </type>
    <!-- Memory properties passed into vkAllocMemory(). -->
    <type requires="VkMemoryOutputFlagBits"               >
      typedef <type>VkFlags</type> <name>VkMemoryOutputFlags</name>;
    </type>
    <!-- Memory output flags passed to resource transition commands -->
    <type requires="VkMemoryInputFlagBits"                >
      typedef <type>VkFlags</type> <name>VkMemoryInputFlags</name>;
    </type>
    <!-- Memory input flags passed to resource transition commands -->
    <type requires="VkBufferUsageFlagBits"                >
      typedef <type>VkFlags</type> <name>VkBufferUsageFlags</name>;
    </type>
    <!-- Buffer usage flags -->
    <type requires="VkBufferCreateFlagBits"               >
      typedef <type>VkFlags</type> <name>VkBufferCreateFlags</name>;
    </type>
    <!-- Buffer creation flags -->
    <type requires="VkShaderStageFlagBits"                >
      typedef <type>VkFlags</type> <name>VkShaderStageFlags</name>;
    </type>
    <!-- Shader stage flags -->
    <type requires="VkImageUsageFlagBits"                 >
      typedef <type>VkFlags</type> <name>VkImageUsageFlags</name>;
    </type>
    <!-- Image usage flags -->
    <type requires="VkImageCreateFlagBits"                >
      typedef <type>VkFlags</type> <name>VkImageCreateFlags</name>;
    </type>
    <!-- Image creation flags -->
    <type requires="VkDepthStencilViewCreateFlagBits"     >
      typedef <type>VkFlags</type> <name>VkDepthStencilViewCreateFlags</name>;
    </type>
    <!-- Depth-stencil view creation flags -->
    <type requires="VkPipelineCreateFlagBits"             >
      typedef <type>VkFlags</type> <name>VkPipelineCreateFlags</name>;
    </type>
    <!-- Pipeline creation flags -->
    <type requires="VkChannelFlagBits"                    >
      typedef <type>VkFlags</type> <name>VkChannelFlags</name>;
    </type>
    <!-- Channel flags -->
    <type requires="VkFenceCreateFlagBits"                >
      typedef <type>VkFlags</type> <name>VkFenceCreateFlags</name>;
    </type>
    <!-- Fence creation flags -->
    <type                                                 >
      typedef <type>VkFlags</type> <name>VkSemaphoreCreateFlags</name>;
    </type>
    <!-- Semaphore creation flags -->
    <type requires="VkFormatFeatureFlagBits"              >
      typedef <type>VkFlags</type> <name>VkFormatFeatureFlags</name>;
    </type>
    <!-- Format capability flags -->
    <type requires="VkQueryControlFlagBits"               >
      typedef <type>VkFlags</type> <name>VkQueryControlFlags</name>;
    </type>
    <!-- Query control flags -->
    <type requires="VkQueryResultFlagBits"                >
      typedef <type>VkFlags</type> <name>VkQueryResultFlags</name>;
    </type>
    <!-- Query result flags -->
    <type                                                 >
      typedef <type>VkFlags</type> <name>VkShaderModuleCreateFlags</name>;
    </type>
    <!-- Shader module creation flags (no bits yet) -->
    <type                                                 >
      typedef <type>VkFlags</type> <name>VkShaderCreateFlags</name>;
    </type>
    <!-- Shader creation flags (no bits yet) -->
    <type                                                 >
      typedef <type>VkFlags</type> <name>VkEventCreateFlags</name>;
    </type>
    <!-- Event creation flags  (no bits yet) -->
    <type                                                 >
      typedef <type>VkFlags</type> <name>VkCmdBufferCreateFlags</name>;
    </type>
    <!-- Command buffer creation flags (no bits yet) -->
    <type requires="VkCmdBufferOptimizeFlagBits"          >
      typedef <type>VkFlags</type> <name>VkCmdBufferOptimizeFlags</name>;
    </type>
    <!-- Command buffer optimization flags -->
    <type requires="VkQueryPipelineStatisticFlagBits"     >
      typedef <type>VkFlags</type> <name>VkQueryPipelineStatisticFlags</name>;
    </type>
    <!-- Pipeline statistics flags -->
    <type                                                 >
      typedef <type>VkFlags</type> <name>VkMemoryMapFlags</name>;
    </type>
    <!-- Memory mapping flags (no bits yet) -->

    <!-- Types which can be void pointers or class pointers, selected at compile time -->
    <type>
      VK_DEFINE_BASE_HANDLE(<name>VkObject</name>)
    </type>
    <type>
      VK_DEFINE_DISP_SUBCLASS_HANDLE(<name>VkInstance</name>, <type>VkObject</type>)
    </type>
    <type>
      VK_DEFINE_DISP_SUBCLASS_HANDLE(<name>VkPhysicalDevice</name>, <type>VkObject</type>)
    </type>
    <type>
      VK_DEFINE_DISP_SUBCLASS_HANDLE(<name>VkDevice</name>, <type>VkObject</type>)
    </type>
    <type>
      VK_DEFINE_DISP_SUBCLASS_HANDLE(<name>VkQueue</name>, <type>VkObject</type>)
    </type>
    <type>
      VK_DEFINE_DISP_SUBCLASS_HANDLE(<name>VkCmdBuffer</name>, <type>VkObject</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkNonDispatchable</name>, <type>VkObject</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkDeviceMemory</name>, <type>VkNonDispatchable</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkBuffer</name>, <type>VkNonDispatchable</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkBufferView</name>, <type>VkNonDispatchable</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkImage</name>, <type>VkNonDispatchable</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkImageView</name>, <type>VkNonDispatchable</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkColorAttachmentView</name>, <type>VkNonDispatchable</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkDepthStencilView</name>, <type>VkNonDispatchable</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkShaderModule</name>, <type>VkNonDispatchable</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkShader</name>, <type>VkNonDispatchable</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkPipeline</name>, <type>VkNonDispatchable</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkPipelineLayout</name>, <type>VkNonDispatchable</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkSampler</name>, <type>VkNonDispatchable</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkDescriptorSet</name>, <type>VkNonDispatchable</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkDescriptorSetLayout</name>, <type>VkNonDispatchable</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkDescriptorPool</name>, <type>VkNonDispatchable</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkDynamicStateObject</name>, <type>VkNonDispatchable</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkDynamicVpState</name>, <type>VkDynamicStateObject</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkDynamicRsState</name>, <type>VkDynamicStateObject</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkDynamicCbState</name>, <type>VkDynamicStateObject</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkDynamicDsState</name>, <type>VkDynamicStateObject</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkFence</name>, <type>VkNonDispatchable</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkSemaphore</name>, <type>VkNonDispatchable</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkEvent</name>, <type>VkNonDispatchable</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkQueryPool</name>, <type>VkNonDispatchable</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkFramebuffer</name>, <type>VkNonDispatchable</type>)
    </type>
    <type>
      VK_DEFINE_NONDISP_SUBCLASS_HANDLE(<name>VkRenderPass</name>, <type>VkNonDispatchable</type>)
    </type>

    <!-- Types generated from corresponding <enums> tags below -->
    <type name="VkAttachmentLoadOp" category="enum"/>
    <type name="VkAttachmentStoreOp" category="enum"/>
    <type name="VkBlend" category="enum"/>
    <type name="VkBlendOp" category="enum"/>
    <type name="VkBorderColor" category="enum"/>
    <type name="VkBufferCreateFlagBits" category="enum"/>
    <type name="VkBufferUsageFlagBits" category="enum"/>
    <type name="VkBufferViewType" category="enum"/>
    <type name="VkChannelFlagBits" category="enum"/>
    <type name="VkChannelSwizzle" category="enum"/>
    <type name="VkCmdBufferOptimizeFlagBits" category="enum"/>
    <type name="VkCompareOp" category="enum"/>
    <type name="VkCullMode" category="enum"/>
    <type name="VkDepthStencilViewCreateFlagBits" category="enum"/>
    <type name="VkDescriptorPoolUsage" category="enum"/>
    <type name="VkDescriptorSetUsage" category="enum"/>
    <type name="VkDescriptorType" category="enum"/>
    <type name="VkDeviceCreateFlagBits" category="enum"/>
    <type name="VkFenceCreateFlagBits" category="enum"/>
    <type name="VkFillMode" category="enum"/>
    <type name="VkFormat" category="enum"/>
    <type name="VkFormatFeatureFlagBits" category="enum"/>
    <type name="VkFrontFace" category="enum"/>
    <type name="VkImageAspect" category="enum"/>
    <type name="VkImageCreateFlagBits" category="enum"/>
    <type name="VkImageLayout" category="enum"/>
    <type name="VkImageTiling" category="enum"/>
    <type name="VkImageType" category="enum"/>
    <type name="VkImageUsageFlagBits" category="enum"/>
    <type name="VkImageViewType" category="enum"/>
    <type name="VkIndexType" category="enum"/>
    <type name="VkLogicOp" category="enum"/>
    <type name="VkMemoryInputFlagBits" category="enum"/>
    <type name="VkMemoryOutputFlagBits" category="enum"/>
    <type name="VkMemoryPropertyFlagBits" category="enum"/>
    <type name="VkObjectType" category="enum"/>
    <type name="VkPhysicalDeviceType" category="enum"/>
    <type name="VkPipeEvent" category="enum"/>
    <type name="VkPipelineBindPoint" category="enum"/>
    <type name="VkPipelineCreateFlagBits" category="enum"/>
    <type name="VkPrimitiveTopology" category="enum"/>
    <type name="VkQueryControlFlagBits" category="enum"/>
    <type name="VkQueryPipelineStatisticFlagBits" category="enum"/>
    <type name="VkQueryResultFlagBits" category="enum"/>
    <type name="VkQueryType" category="enum"/>
    <type name="VkQueueFlagBits" category="enum"/>
    <type name="VkResult" category="enum"/>
    <type name="VkShaderStage" category="enum"/>
    <type name="VkShaderStageFlagBits" category="enum"/>
    <type name="VkStateBindPoint" category="enum"/>
    <type name="VkStencilOp" category="enum"/>
    <type name="VkStructureType" category="enum"/>
    <type name="VkSystemAllocType" category="enum"/>
    <type name="VkTexAddress" category="enum"/>
    <type name="VkTexFilter" category="enum"/>
    <type name="VkTexMipmapMode" category="enum"/>
    <type name="VkTimestampType" category="enum"/>
    <type name="VkVertexInputStepRate" category="enum"/>
    <type name="VkWaitEvent" category="enum"/>

    <!-- The PFN_* types are used by VkAllocCallbacks below -->
    <type>
      typedef void* (VKAPI *<name>PFN_vkAllocFunction</name>)(
      void*                           pUserData,
      size_t                          size,
      size_t                          alignment,
      <type>VkSystemAllocType</type>               allocType);
    </type>
    <type>
      typedef void (VKAPI *<name>PFN_vkFreeFunction</name>)(
      void*                           pUserData,
      void*                           pMem);
    </type>

    <!-- Struct types -->
    <type category="struct" name="VkOffset2D">
      <member>
        <type>int32_t</type>
        <name>x</name>
      </member>
      <member>
        <type>int32_t</type>
        <name>y</name>
      </member>
    </type>
    <type category="struct" name="VkOffset3D">
      <member>
        <type>int32_t</type>
        <name>x</name>
      </member>
      <member>
        <type>int32_t</type>
        <name>y</name>
      </member>
      <member>
        <type>int32_t</type>
        <name>z</name>
      </member>
    </type>
    <type category="struct" name="VkExtent2D">
      <member>
        <type>int32_t</type>
        <name>width</name>
      </member>
      <member>
        <type>int32_t</type>
        <name>height</name>
      </member>
    </type>
    <type category="struct" name="VkExtent3D">
      <member>
        <type>int32_t</type>
        <name>width</name>
      </member>
      <member>
        <type>int32_t</type>
        <name>height</name>
      </member>
      <member>
        <type>int32_t</type>
        <name>depth</name>
      </member>
    </type>
    <type category="struct" name="VkViewport">
      <member>
        <type>float</type>
        <name>originX</name>
      </member>
      <member>
        <type>float</type>
        <name>originY</name>
      </member>
      <member>
        <type>float</type>
        <name>width</name>
      </member>
      <member>
        <type>float</type>
        <name>height</name>
      </member>
      <member>
        <type>float</type>
        <name>minDepth</name>
      </member>
      <member>
        <type>float</type>
        <name>maxDepth</name>
      </member>
    </type>
    <type category="struct" name="VkRect">
      <member>
        <type>VkOffset2D</type>
        <name>offset</name>
      </member>
      <member>
        <type>VkExtent2D</type>
        <name>extent</name>
      </member>
    </type>
    <type category="struct" name="VkChannelMapping">
      <member>
        <type>VkChannelSwizzle</type>
        <name>r</name>
      </member>
      <member>
        <type>VkChannelSwizzle</type>
        <name>g</name>
      </member>
      <member>
        <type>VkChannelSwizzle</type>
        <name>b</name>
      </member>
      <member>
        <type>VkChannelSwizzle</type>
        <name>a</name>
      </member>
    </type>
    <type category="struct" name="VkPhysicalDeviceProperties">
      <member>
        <type>uint32_t</type>
        <name>apiVersion</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>driverVersion</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>vendorId</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>deviceId</name>
      </member>
      <member>
        <type>VkPhysicalDeviceType</type>
        <name>deviceType</name>
      </member>
      <member>
        <type>char</type>           <name>deviceName</name>[<enum>VK_MAX_PHYSICAL_DEVICE_NAME</enum>]
      </member>
      <member>
        <type>VkDeviceSize</type>
        <name>maxInlineMemoryUpdateSize</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>maxBoundDescriptorSets</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>maxThreadGroupSize</name>
      </member>
      <member>
        <type>uint64_t</type>
        <name>timestampFrequency</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>multiColorAttachmentClears</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>maxDescriptorSets</name>
      </member>
      <!-- at least 2? -->
      <member>
        <type>uint32_t</type>
        <name>maxViewports</name>
      </member>
      <!-- at least 16? -->
      <member>
        <type>uint32_t</type>
        <name>maxColorAttachments</name>
      </member>
      <!-- at least 8? -->
    </type>
    <type category="struct" name="VkExtensionProperties">
      <member>
        <type>char</type>            <name>extName</name>[<enum>VK_MAX_EXTENSION_NAME</enum>]
      </member>
      <!-- extension name -->
      <member>
        <type>uint32_t</type>
        <name>version</name>
      </member>
      <!-- version of the extension specification -->
    </type>
    <type category="struct" name="VkApplicationInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Type of structure. Should be VK_STRUCTURE_TYPE_APPLICATION_INFO -->
      <member>
        const void*                  <name>pNext</name>
      </member>
      <!-- Next structure in chain -->
      <member>
        const <type>char</type>*     <name>pAppName</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>appVersion</name>
      </member>
      <member>
        const <type>char</type>*     <name>pEngineName</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>engineVersion</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>apiVersion</name>
      </member>
    </type>
    <type category="struct" name="VkAllocCallbacks">
      <member>
        void*                        <name>pUserData</name>
      </member>
      <member>
        <type>PFN_vkAllocFunction</type>
        <name>pfnAlloc</name>
      </member>
      <member>
        <type>PFN_vkFreeFunction</type>
        <name>pfnFree</name>
      </member>
    </type>
    <type category="struct" name="VkDeviceQueueCreateInfo">
      <member>
        <type>uint32_t</type>
        <name>queueNodeIndex</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>queueCount</name>
      </member>
    </type>
    <type category="struct" name="VkDeviceCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Should be VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO -->
      <member>
        const void*                  <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>uint32_t</type>
        <name>queueRecordCount</name>
      </member>
      <member>
        const <type>VkDeviceQueueCreateInfo</type>* <name>pRequestedQueues</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>extensionCount</name>
      </member>
      <member>
        const <type>char</type>*const*      <name>ppEnabledExtensionNames</name>
      </member>
      <member>
        const <type>VkPhysicalDeviceFeatures</type>* <name>pEnabledFeatures</name>
      </member>
      <member>
        <type>VkDeviceCreateFlags</type>
        <name>flags</name>
      </member>
      <!-- Device creation flags -->
    </type>
    <type category="struct" name="VkInstanceCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Should be VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        const <type>VkApplicationInfo</type>* <name>pAppInfo</name>
      </member>
      <member>
        const <type>VkAllocCallbacks</type>* <name>pAllocCb</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>extensionCount</name>
      </member>
      <member>
        const <type>char</type>*const*      <name>ppEnabledExtensionNames</name>
      </member>
      <!-- layer or extension name to be enabled -->
    </type>
    <type category="struct" name="VkLayerCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Should be VK_STRUCTURE_TYPE_LAYER_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>uint32_t</type>
        <name>layerCount</name>
      </member>
      <member>
        const <type>char</type> *const*     <name>ppActiveLayerNames</name>
      </member>
      <!-- layer name from the layer's vkEnumerateLayers()) -->
    </type>
    <type category="struct" name="VkPhysicalDeviceQueueProperties">
      <member>
        <type>VkQueueFlags</type>
        <name>queueFlags</name>
      </member>
      <!-- Queue flags -->
      <member>
        <type>uint32_t</type>
        <name>queueCount</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>maxAtomicCounters</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsTimestamps</name>
      </member>
    </type>
    <type category="struct" name="VkPhysicalDeviceMemoryProperties">
      <member>
        <type>bool32_t</type>
        <name>supportsMigration</name>
      </member>
    </type>
    <type category="struct" name="VkMemoryAllocInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_MEMORY_ALLOC_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>VkDeviceSize</type>
        <name>allocationSize</name>
      </member>
      <!-- Size of memory allocation -->
      <member>
        <type>VkMemoryPropertyFlags</type>
        <name>memProps</name>
      </member>
      <!-- Memory property flags -->
    </type>
    <type category="struct" name="VkMemoryRequirements">
      <member>
        <type>VkDeviceSize</type>
        <name>size</name>
      </member>
      <!-- Specified in bytes -->
      <member>
        <type>VkDeviceSize</type>
        <name>alignment</name>
      </member>
      <!-- Specified in bytes -->
      <member>
        <type>VkDeviceSize</type>
        <name>granularity</name>
      </member>
      <!-- Granularity at which memory can be bound to resource sub-ranges specified in bytes (usually the page size) -->
      <member>
        <type>VkMemoryPropertyFlags</type>
        <name>memPropsAllowed</name>
      </member>
      <!-- Allowed memory property flags -->
      <member>
        <type>VkMemoryPropertyFlags</type>
        <name>memPropsRequired</name>
      </member>
      <!-- Required memory property flags -->
    </type>
    <type category="struct" name="VkMappedMemoryRange">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>VkDeviceMemory</type>
        <name>mem</name>
      </member>
      <!-- Mapped memory object -->
      <member>
        <type>VkDeviceSize</type>
        <name>offset</name>
      </member>
      <!-- Offset within the mapped memory the range starts from -->
      <member>
        <type>VkDeviceSize</type>
        <name>size</name>
      </member>
      <!-- Size of the range within the mapped memory -->
    </type>
    <type category="struct" name="VkFormatProperties">
      <member>
        <type>VkFormatFeatureFlags</type>
        <name>linearTilingFeatures</name>
      </member>
      <!-- Format features in case of linear tiling -->
      <member>
        <type>VkFormatFeatureFlags</type>
        <name>optimalTilingFeatures</name>
      </member>
      <!-- Format features in case of optimal tiling -->
    </type>
    <type category="struct" name="VkDescriptorInfo">
      <member>
        <type>VkBufferView</type>
        <name>bufferView</name>
      </member>
      <!-- Buffer view to write to the descriptor (in case it's a buffer descriptor, otherwise should be VK_NULL_HANDLE) -->
      <member>
        <type>VkSampler</type>
        <name>sampler</name>
      </member>
      <!-- Sampler to write to the descriptor (in case it's a SAMPLER or COMBINED_IMAGE_SAMPLER descriptor, otherwise should be VK_NULL_HANDLE) -->
      <member>
        <type>VkImageView</type>
        <name>imageView</name>
      </member>
      <!-- Image view to write to the descriptor (in case it's a SAMPLED_IMAGE, STORAGE_IMAGE, or COMBINED_IMAGE_SAMPLER descriptor, otherwise should be VK_NULL_HANDLE) -->
      <member>
        <type>VkImageLayout</type>
        <name>imageLayout</name>
      </member>
      <!-- Layout the image is expected to be in when accessed using this descriptor (only used if imageView is not VK_NULL_HANDLE) -->
    </type>
    <type category="struct" name="VkWriteDescriptorSet">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>VkDescriptorSet</type>
        <name>destSet</name>
      </member>
      <!-- Destination descriptor set -->
      <member>
        <type>uint32_t</type>
        <name>destBinding</name>
      </member>
      <!-- Binding within the destination descriptor set to write -->
      <member>
        <type>uint32_t</type>
        <name>destArrayElement</name>
      </member>
      <!-- Array element within the destination binding to write -->
      <member>
        <type>uint32_t</type>
        <name>count</name>
      </member>
      <!-- Number of descriptors to write (determines the size of the array pointed by pDescriptors) -->
      <member>
        <type>VkDescriptorType</type>
        <name>descriptorType</name>
      </member>
      <!-- Descriptor type to write (determines which fields of the array pointed by pDescriptors are going to be used) -->
      <member>
        const <type>VkDescriptorInfo</type>* <name>pDescriptors</name>
      </member>
      <!-- Array of info structures describing the descriptors to write -->
    </type>
    <type category="struct" name="VkCopyDescriptorSet">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>VkDescriptorSet</type>
        <name>srcSet</name>
      </member>
      <!-- Source descriptor set -->
      <member>
        <type>uint32_t</type>
        <name>srcBinding</name>
      </member>
      <!-- Binding within the source descriptor set to copy from -->
      <member>
        <type>uint32_t</type>
        <name>srcArrayElement</name>
      </member>
      <!-- Array element within the source binding to copy from -->
      <member>
        <type>VkDescriptorSet</type>
        <name>destSet</name>
      </member>
      <!-- Destination descriptor set -->
      <member>
        <type>uint32_t</type>
        <name>destBinding</name>
      </member>
      <!-- Binding within the destination descriptor set to copy to -->
      <member>
        <type>uint32_t</type>
        <name>destArrayElement</name>
      </member>
      <!-- Array element within the destination binding to copy to -->
      <member>
        <type>uint32_t</type>
        <name>count</name>
      </member>
      <!-- Number of descriptors to copy -->
    </type>
    <type category="struct" name="VkBufferCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure. -->
      <member>
        <type>VkDeviceSize</type>
        <name>size</name>
      </member>
      <!-- Specified in bytes -->
      <member>
        <type>VkBufferUsageFlags</type>
        <name>usage</name>
      </member>
      <!-- Buffer usage flags -->
      <member>
        <type>VkBufferCreateFlags</type>
        <name>flags</name>
      </member>
      <!-- Buffer creation flags -->
    </type>
    <type category="struct" name="VkBufferViewCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure. -->
      <member>
        <type>VkBuffer</type>
        <name>buffer</name>
      </member>
      <member>
        <type>VkBufferViewType</type>
        <name>viewType</name>
      </member>
      <member>
        <type>VkFormat</type>
        <name>format</name>
      </member>
      <!-- Optionally specifies format of elements -->
      <member>
        <type>VkDeviceSize</type>
        <name>offset</name>
      </member>
      <!-- Specified in bytes -->
      <member>
        <type>VkDeviceSize</type>
        <name>range</name>
      </member>
      <!-- View size specified in bytes -->
    </type>
    <type category="struct" name="VkImageSubresource">
      <member>
        <type>VkImageAspect</type>
        <name>aspect</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>mipLevel</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>arraySlice</name>
      </member>
    </type>
    <type category="struct" name="VkImageSubresourceRange">
      <member>
        <type>VkImageAspect</type>
        <name>aspect</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>baseMipLevel</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>mipLevels</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>baseArraySlice</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>arraySize</name>
      </member>
    </type>
    <type category="struct" name="VkMemoryBarrier">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_MEMORY_BARRIER -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure. -->
      <member>
        <type>VkMemoryOutputFlags</type>
        <name>outputMask</name>
      </member>
      <!-- Outputs the barrier should sync -->
      <member>
        <type>VkMemoryInputFlags</type>
        <name>inputMask</name>
      </member>
      <!-- Inputs the barrier should sync to -->
    </type>
    <type category="struct" name="VkBufferMemoryBarrier">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure. -->
      <member>
        <type>VkMemoryOutputFlags</type>
        <name>outputMask</name>
      </member>
      <!-- Outputs the barrier should sync -->
      <member>
        <type>VkMemoryInputFlags</type>
        <name>inputMask</name>
      </member>
      <!-- Inputs the barrier should sync to -->
      <member>
        <type>VkBuffer</type>
        <name>buffer</name>
      </member>
      <!-- Buffer to sync -->
      <member>
        <type>VkDeviceSize</type>
        <name>offset</name>
      </member>
      <!-- Offset within the buffer to sync -->
      <member>
        <type>VkDeviceSize</type>
        <name>size</name>
      </member>
      <!-- Amount of bytes to sync -->
    </type>
    <type category="struct" name="VkImageMemoryBarrier">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure. -->
      <member>
        <type>VkMemoryOutputFlags</type>
        <name>outputMask</name>
      </member>
      <!-- Outputs the barrier should sync -->
      <member>
        <type>VkMemoryInputFlags</type>
        <name>inputMask</name>
      </member>
      <!-- Inputs the barrier should sync to -->
      <member>
        <type>VkImageLayout</type>
        <name>oldLayout</name>
      </member>
      <!-- Current layout of the image -->
      <member>
        <type>VkImageLayout</type>
        <name>newLayout</name>
      </member>
      <!-- New layout to transition the image to -->
      <member>
        <type>VkImage</type>
        <name>image</name>
      </member>
      <!-- Image to sync -->
      <member>
        <type>VkImageSubresourceRange</type>
        <name>subresourceRange</name>
      </member>
      <!-- Subresource range to sync -->
    </type>
    <type category="struct" name="VkImageCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure. -->
      <member>
        <type>VkImageType</type>
        <name>imageType</name>
      </member>
      <member>
        <type>VkFormat</type>
        <name>format</name>
      </member>
      <member>
        <type>VkExtent3D</type>
        <name>extent</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>mipLevels</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>arraySize</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>samples</name>
      </member>
      <member>
        <type>VkImageTiling</type>
        <name>tiling</name>
      </member>
      <member>
        <type>VkImageUsageFlags</type>
        <name>usage</name>
      </member>
      <!-- Image usage flags -->
      <member>
        <type>VkImageCreateFlags</type>
        <name>flags</name>
      </member>
      <!-- Image creation flags -->
    </type>
    <type category="struct" name="VkSubresourceLayout">
      <member>
        <type>VkDeviceSize</type>
        <name>offset</name>
      </member>
      <!-- Specified in bytes -->
      <member>
        <type>VkDeviceSize</type>
        <name>size</name>
      </member>
      <!-- Specified in bytes -->
      <member>
        <type>VkDeviceSize</type>
        <name>rowPitch</name>
      </member>
      <!-- Specified in bytes -->
      <member>
        <type>VkDeviceSize</type>
        <name>depthPitch</name>
      </member>
      <!-- Specified in bytes -->
    </type>
    <type category="struct" name="VkImageViewCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>VkImage</type>
        <name>image</name>
      </member>
      <member>
        <type>VkImageViewType</type>
        <name>viewType</name>
      </member>
      <member>
        <type>VkFormat</type>
        <name>format</name>
      </member>
      <member>
        <type>VkChannelMapping</type>
        <name>channels</name>
      </member>
      <member>
        <type>VkImageSubresourceRange</type>
        <name>subresourceRange</name>
      </member>
    </type>
    <type category="struct" name="VkColorAttachmentViewCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_COLOR_ATTACHMENT_VIEW_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>VkImage</type>
        <name>image</name>
      </member>
      <member>
        <type>VkFormat</type>
        <name>format</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>mipLevel</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>baseArraySlice</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>arraySize</name>
      </member>
      <member>
        <type>VkImage</type>
        <name>msaaResolveImage</name>
      </member>
      <member>
        <type>VkImageSubresourceRange</type>
        <name>msaaResolveSubResource</name>
      </member>
    </type>
    <type category="struct" name="VkDepthStencilViewCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_DEPTH_STENCIL_VIEW_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>VkImage</type>
        <name>image</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>mipLevel</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>baseArraySlice</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>arraySize</name>
      </member>
      <member>
        <type>VkImage</type>
        <name>msaaResolveImage</name>
      </member>
      <member>
        <type>VkImageSubresourceRange</type>
        <name>msaaResolveSubResource</name>
      </member>
      <member>
        <type>VkDepthStencilViewCreateFlags</type>
        <name>flags</name>
      </member>
      <!-- Depth stencil attachment view flags -->
    </type>
    <type category="struct" name="VkColorAttachmentBindInfo">
      <member>
        <type>VkColorAttachmentView</type>
        <name>view</name>
      </member>
      <member>
        <type>VkImageLayout</type>
        <name>layout</name>
      </member>
    </type>
    <type category="struct" name="VkDepthStencilBindInfo">
      <member>
        <type>VkDepthStencilView</type>
        <name>view</name>
      </member>
      <member>
        <type>VkImageLayout</type>
        <name>layout</name>
      </member>
    </type>
    <type category="struct" name="VkBufferCopy">
      <member>
        <type>VkDeviceSize</type>
        <name>srcOffset</name>
      </member>
      <!-- Specified in bytes -->
      <member>
        <type>VkDeviceSize</type>
        <name>destOffset</name>
      </member>
      <!-- Specified in bytes -->
      <member>
        <type>VkDeviceSize</type>
        <name>copySize</name>
      </member>
      <!-- Specified in bytes -->
    </type>
    <type category="struct" name="VkImageMemoryBindInfo">
      <member>
        <type>VkImageSubresource</type>
        <name>subresource</name>
      </member>
      <member>
        <type>VkOffset3D</type>
        <name>offset</name>
      </member>
      <member>
        <type>VkExtent3D</type>
        <name>extent</name>
      </member>
    </type>
    <type category="struct" name="VkImageCopy">
      <member>
        <type>VkImageSubresource</type>
        <name>srcSubresource</name>
      </member>
      <member>
        <type>VkOffset3D</type>
        <name>srcOffset</name>
      </member>
      <!-- Specified in pixels for both compressed and uncompressed images -->
      <member>
        <type>VkImageSubresource</type>
        <name>destSubresource</name>
      </member>
      <member>
        <type>VkOffset3D</type>
        <name>destOffset</name>
      </member>
      <!-- Specified in pixels for both compressed and uncompressed images -->
      <member>
        <type>VkExtent3D</type>
        <name>extent</name>
      </member>
      <!-- Specified in pixels for both compressed and uncompressed images -->
    </type>
    <type category="struct" name="VkImageBlit">
      <member>
        <type>VkImageSubresource</type>
        <name>srcSubresource</name>
      </member>
      <member>
        <type>VkOffset3D</type>
        <name>srcOffset</name>
      </member>
      <!-- Specified in pixels for both compressed and uncompressed images -->
      <member>
        <type>VkExtent3D</type>
        <name>srcExtent</name>
      </member>
      <!-- Specified in pixels for both compressed and uncompressed images -->
      <member>
        <type>VkImageSubresource</type>
        <name>destSubresource</name>
      </member>
      <member>
        <type>VkOffset3D</type>
        <name>destOffset</name>
      </member>
      <!-- Specified in pixels for both compressed and uncompressed images -->
      <member>
        <type>VkExtent3D</type>
        <name>destExtent</name>
      </member>
      <!-- Specified in pixels for both compressed and uncompressed images -->
    </type>
    <type category="struct" name="VkBufferImageCopy">
      <member>
        <type>VkDeviceSize</type>
        <name>bufferOffset</name>
      </member>
      <!-- Specified in bytes -->
      <member>
        <type>VkImageSubresource</type>
        <name>imageSubresource</name>
      </member>
      <member>
        <type>VkOffset3D</type>
        <name>imageOffset</name>
      </member>
      <!-- Specified in pixels for both compressed and uncompressed images -->
      <member>
        <type>VkExtent3D</type>
        <name>imageExtent</name>
      </member>
      <!-- Specified in pixels for both compressed and uncompressed images -->
    </type>
    <type category="struct" name="VkImageResolve">
      <member>
        <type>VkImageSubresource</type>
        <name>srcSubresource</name>
      </member>
      <member>
        <type>VkOffset3D</type>
        <name>srcOffset</name>
      </member>
      <member>
        <type>VkImageSubresource</type>
        <name>destSubresource</name>
      </member>
      <member>
        <type>VkOffset3D</type>
        <name>destOffset</name>
      </member>
      <member>
        <type>VkExtent3D</type>
        <name>extent</name>
      </member>
    </type>
    <type category="struct" name="VkShaderModuleCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>size_t</type>
        <name>codeSize</name>
      </member>
      <!-- Specified in bytes -->
      <member>
        const void*                         <name>pCode</name>
      </member>
      <!-- Binary code of size codeSize -->
      <member>
        <type>VkShaderModuleCreateFlags</type>
        <name>flags</name>
      </member>
      <!-- Reserved -->
    </type>
    <type category="struct" name="VkShaderCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_SHADER_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>VkShaderModule</type>
        <name>module</name>
      </member>
      <!-- Module containing entry point -->
      <member>
        <type>VkShaderCreateFlags</type>
        <name>flags</name>
      </member>
      <!-- Reserved -->
    </type>
    <type category="struct" name="VkDescriptorSetLayoutBinding">
      <member>
        <type>VkDescriptorType</type>
        <name>descriptorType</name>
      </member>
      <!-- Type of the descriptors in this binding -->
      <member>
        <type>uint32_t</type>
        <name>arraySize</name>
      </member>
      <!-- Number of descriptors in this binding -->
      <member>
        <type>VkShaderStageFlags</type>
        <name>stageFlags</name>
      </member>
      <!-- Shader stages this binding is visible to -->
      <member>
        const <type>VkSampler</type>*       <name>pImmutableSamplers</name>
      </member>
      <!-- Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains count number of elements) -->
    </type>
    <type category="struct" name="VkDescriptorSetLayoutCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>uint32_t</type>
        <name>count</name>
      </member>
      <!-- Number of bindings in the descriptor set layout -->
      <member>
        const <type>VkDescriptorSetLayoutBinding</type>* <name>pBinding</name>
      </member>
      <!-- Array of descriptor set layout bindings -->
    </type>
    <type category="struct" name="VkDescriptorTypeCount">
      <member>
        <type>VkDescriptorType</type>
        <name>type</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>count</name>
      </member>
    </type>
    <type category="struct" name="VkDescriptorPoolCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>uint32_t</type>
        <name>count</name>
      </member>
      <member>
        const <type>VkDescriptorTypeCount</type>* <name>pTypeCount</name>
      </member>
    </type>
    <type category="struct" name="VkSpecializationMapEntry">
      <member>
        <type>uint32_t</type>
        <name>constantId</name>
      </member>
      <!-- The SpecConstant ID specified in the BIL -->
      <member>
        <type>uint32_t</type>
        <name>offset</name>
      </member>
      <!-- Offset of the value in the data block -->
    </type>
    <type category="struct" name="VkSpecializationInfo">
      <member>
        <type>uint32_t</type>
        <name>mapEntryCount</name>
      </member>
      <member>
        const <type>VkSpecializationMapEntry</type>* <name>pMap</name>
      </member>
      <!-- mapEntryCount entries -->
      <member>
        const void*                         <name>pData</name>
      </member>
    </type>
    <type category="struct" name="VkPipelineShaderStageCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>VkShaderStage</type>
        <name>stage</name>
      </member>
      <member>
        <type>VkShader</type>
        <name>shader</name>
      </member>
      <member>
        const <type>VkSpecializationInfo</type>* <name>pSpecializationInfo</name>
      </member>
    </type>
    <type category="struct" name="VkComputePipelineCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>VkPipelineShaderStageCreateInfo</type>
        <name>cs</name>
      </member>
      <member>
        <type>VkPipelineCreateFlags</type>
        <name>flags</name>
      </member>
      <!-- Pipeline creation flags -->
      <member>
        <type>VkPipelineLayout</type>
        <name>layout</name>
      </member>
      <!-- Interface layout of the pipeline -->
    </type>
    <type category="struct" name="VkVertexInputBindingDescription">
      <member>
        <type>uint32_t</type>
        <name>binding</name>
      </member>
      <!-- Vertex buffer binding id -->
      <member>
        <type>uint32_t</type>
        <name>strideInBytes</name>
      </member>
      <!-- Distance between vertices in bytes (0 = no advancement) -->
      <member>
        <type>VkVertexInputStepRate</type>
        <name>stepRate</name>
      </member>
      <!-- Rate at which binding is incremented -->
    </type>
    <type category="struct" name="VkVertexInputAttributeDescription">
      <member>
        <type>uint32_t</type>
        <name>location</name>
      </member>
      <!-- location of the shader vertex attrib -->
      <member>
        <type>uint32_t</type>
        <name>binding</name>
      </member>
      <!-- Vertex buffer binding id -->
      <member>
        <type>VkFormat</type>
        <name>format</name>
      </member>
      <!-- format of source data -->
      <member>
        <type>uint32_t</type>
        <name>offsetInBytes</name>
      </member>
      <!-- Offset of first element in bytes from base of vertex -->
    </type>
    <type category="struct" name="VkPipelineVertexInputStateCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Should be VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>uint32_t</type>
        <name>bindingCount</name>
      </member>
      <!-- number of bindings -->
      <member>
        const <type>VkVertexInputBindingDescription</type>* <name>pVertexBindingDescriptions</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>attributeCount</name>
      </member>
      <!-- number of attributes -->
      <member>
        const <type>VkVertexInputAttributeDescription</type>* <name>pVertexAttributeDescriptions</name>
      </member>
    </type>
    <type category="struct" name="VkPipelineIaStateCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_IA_STATE_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>VkPrimitiveTopology</type>
        <name>topology</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>primitiveRestartEnable</name>
      </member>
    </type>
    <type category="struct" name="VkPipelineTessStateCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_TESS_STATE_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>uint32_t</type>
        <name>patchControlPoints</name>
      </member>
    </type>
    <type category="struct" name="VkPipelineVpStateCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_VP_STATE_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>uint32_t</type>
        <name>viewportCount</name>
      </member>
    </type>
    <type category="struct" name="VkPipelineRsStateCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_RS_STATE_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>bool32_t</type>
        <name>depthClipEnable</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>rasterizerDiscardEnable</name>
      </member>
      <member>
        <type>VkFillMode</type>
        <name>fillMode</name>
      </member>
      <!-- optional (GL45) -->
      <member>
        <type>VkCullMode</type>
        <name>cullMode</name>
      </member>
      <member>
        <type>VkFrontFace</type>
        <name>frontFace</name>
      </member>
    </type>
    <type category="struct" name="VkPipelineMsStateCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_MS_STATE_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>uint32_t</type>
        <name>samples</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>sampleShadingEnable</name>
      </member>
      <!-- optional (GL45) -->
      <member>
        <type>float</type>
        <name>minSampleShading</name>
      </member>
      <!-- optional (GL45) -->
      <member>
        <type>VkSampleMask</type>
        <name>sampleMask</name>
      </member>
    </type>
    <type category="struct" name="VkPipelineCbAttachmentState">
      <member>
        <type>bool32_t</type>
        <name>blendEnable</name>
      </member>
      <member>
        <type>VkFormat</type>
        <name>format</name>
      </member>
      <member>
        <type>VkBlend</type>
        <name>srcBlendColor</name>
      </member>
      <member>
        <type>VkBlend</type>
        <name>destBlendColor</name>
      </member>
      <member>
        <type>VkBlendOp</type>
        <name>blendOpColor</name>
      </member>
      <member>
        <type>VkBlend</type>
        <name>srcBlendAlpha</name>
      </member>
      <member>
        <type>VkBlend</type>
        <name>destBlendAlpha</name>
      </member>
      <member>
        <type>VkBlendOp</type>
        <name>blendOpAlpha</name>
      </member>
      <member>
        <type>VkChannelFlags</type>
        <name>channelWriteMask</name>
      </member>
    </type>
    <type category="struct" name="VkPipelineCbStateCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_CB_STATE_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>bool32_t</type>
        <name>alphaToCoverageEnable</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>logicOpEnable</name>
      </member>
      <member>
        <type>VkLogicOp</type>
        <name>logicOp</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>attachmentCount</name>
      </member>
      <!-- # of pAttachments -->
      <member>
        const <type>VkPipelineCbAttachmentState</type>* <name>pAttachments</name>
      </member>
    </type>
    <type category="struct" name="VkStencilOpState">
      <member>
        <type>VkStencilOp</type>
        <name>stencilFailOp</name>
      </member>
      <member>
        <type>VkStencilOp</type>
        <name>stencilPassOp</name>
      </member>
      <member>
        <type>VkStencilOp</type>
        <name>stencilDepthFailOp</name>
      </member>
      <member>
        <type>VkCompareOp</type>
        <name>stencilCompareOp</name>
      </member>
    </type>
    <type category="struct" name="VkPipelineDsStateCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_DS_STATE_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>VkFormat</type>
        <name>format</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>depthTestEnable</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>depthWriteEnable</name>
      </member>
      <member>
        <type>VkCompareOp</type>
        <name>depthCompareOp</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>depthBoundsEnable</name>
      </member>
      <!-- optional (depth_bounds_test) -->
      <member>
        <type>bool32_t</type>
        <name>stencilTestEnable</name>
      </member>
      <member>
        <type>VkStencilOpState</type>
        <name>front</name>
      </member>
      <member>
        <type>VkStencilOpState</type>
        <name>back</name>
      </member>
    </type>
    <type category="struct" name="VkGraphicsPipelineCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>uint32_t</type>
        <name>stageCount</name>
      </member>
      <member>
        const <type>VkPipelineShaderStageCreateInfo</type>* <name>pStages</name>
      </member>
      <!-- One entry for each active shader stage -->
      <member>
        const <type>VkPipelineVertexInputStateCreateInfo</type>* <name>pVertexInputState</name>
      </member>
      <member>
        const <type>VkPipelineIaStateCreateInfo</type>* <name>pIaState</name>
      </member>
      <member>
        const <type>VkPipelineTessStateCreateInfo</type>* <name>pTessState</name>
      </member>
      <member>
        const <type>VkPipelineVpStateCreateInfo</type>* <name>pVpState</name>
      </member>
      <member>
        const <type>VkPipelineRsStateCreateInfo</type>* <name>pRsState</name>
      </member>
      <member>
        const <type>VkPipelineMsStateCreateInfo</type>* <name>pMsState</name>
      </member>
      <member>
        const <type>VkPipelineDsStateCreateInfo</type>* <name>pDsState</name>
      </member>
      <member>
        const <type>VkPipelineCbStateCreateInfo</type>* <name>pCbState</name>
      </member>
      <member>
        <type>VkPipelineCreateFlags</type>
        <name>flags</name>
      </member>
      <!-- Pipeline creation flags -->
      <member>
        <type>VkPipelineLayout</type>
        <name>layout</name>
      </member>
      <!-- Interface layout of the pipeline -->
    </type>
    <type category="struct" name="VkPipelineLayoutCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>uint32_t</type>
        <name>descriptorSetCount</name>
      </member>
      <!-- Number of descriptor sets interfaced by the pipeline -->
      <member>
        const <type>VkDescriptorSetLayout</type>* <name>pSetLayouts</name>
      </member>
      <!-- Array of setCount number of descriptor set layout objects defining the layout of the -->
    </type>
    <type category="struct" name="VkSamplerCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>VkTexFilter</type>
        <name>magFilter</name>
      </member>
      <!-- Filter mode for magnification -->
      <member>
        <type>VkTexFilter</type>
        <name>minFilter</name>
      </member>
      <!-- Filter mode for minifiation -->
      <member>
        <type>VkTexMipmapMode</type>
        <name>mipMode</name>
      </member>
      <!-- Mipmap selection mode -->
      <member>
        <type>VkTexAddress</type>
        <name>addressU</name>
      </member>
      <member>
        <type>VkTexAddress</type>
        <name>addressV</name>
      </member>
      <member>
        <type>VkTexAddress</type>
        <name>addressW</name>
      </member>
      <member>
        <type>float</type>
        <name>mipLodBias</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>maxAnisotropy</name>
      </member>
      <member>
        <type>VkCompareOp</type>
        <name>compareOp</name>
      </member>
      <member>
        <type>float</type>
        <name>minLod</name>
      </member>
      <member>
        <type>float</type>
        <name>maxLod</name>
      </member>
      <member>
        <type>VkBorderColor</type>
        <name>borderColor</name>
      </member>
    </type>
    <type category="struct" name="VkDynamicVpStateCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_DYNAMIC_VP_STATE_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>uint32_t</type>
        <name>viewportAndScissorCount</name>
      </member>
      <!-- number of entries in pViewports and pScissors -->
      <member>
        const <type>VkViewport</type>*      <name>pViewports</name>
      </member>
      <member>
        const <type>VkRect</type>*          <name>pScissors</name>
      </member>
    </type>
    <type category="struct" name="VkDynamicRsStateCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_DYNAMIC_RS_STATE_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>float</type>
        <name>depthBias</name>
      </member>
      <member>
        <type>float</type>
        <name>depthBiasClamp</name>
      </member>
      <member>
        <type>float</type>
        <name>slopeScaledDepthBias</name>
      </member>
      <member>
        <type>float</type>
        <name>lineWidth</name>
      </member>
      <!-- optional (GL45) - Width of lines -->
    </type>
    <type category="struct" name="VkDynamicCbStateCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_DYNAMIC_CB_STATE_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>float</type>
        <name>blendConst[4]</name>
      </member>
    </type>
    <type category="struct" name="VkDynamicDsStateCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_DYNAMIC_DS_STATE_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>float</type>
        <name>minDepthBounds</name>
      </member>
      <!-- optional (depth_bounds_test) -->
      <member>
        <type>float</type>
        <name>maxDepthBounds</name>
      </member>
      <!-- optional (depth_bounds_test) -->
      <member>
        <type>uint32_t</type>
        <name>stencilReadMask</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>stencilWriteMask</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>stencilFrontRef</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>stencilBackRef</name>
      </member>
    </type>
    <type category="struct" name="VkCmdBufferCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_CMD_BUFFER_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>uint32_t</type>
        <name>queueNodeIndex</name>
      </member>
      <member>
        <type>VkCmdBufferCreateFlags</type>
        <name>flags</name>
      </member>
      <!-- Command buffer creation flags -->
    </type>
    <type category="struct" name="VkCmdBufferBeginInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_CMD_BUFFER_BEGIN_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>VkCmdBufferOptimizeFlags</type>
        <name>flags</name>
      </member>
      <!-- Command buffer optimization flags -->
    </type>
    <type category="struct" name="VkRenderPassBegin">
      <member>
        <type>VkRenderPass</type>
        <name>renderPass</name>
      </member>
      <member>
        <type>VkFramebuffer</type>
        <name>framebuffer</name>
      </member>
    </type>
    <type category="struct" name="VkCmdBufferGraphicsBeginInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_CMD_BUFFER_GRAPHICS_BEGIN_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>VkRenderPassBegin</type>
        <name>renderPassContinue</name>
      </member>
      <!-- Only needed when a render pass is split across two command buffers -->
    </type>
    <type category="union" name="VkClearColorValue" comment="// Union allowing specification of floating point or raw color data. Actual value selected is based on image being cleared.">
      <member>
        <type>float</type>
        <name>floatColor[4]</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>rawColor[4]</name>
      </member>
    </type>
    <type category="struct" name="VkClearColor">
      <member>
        <type>VkClearColorValue</type>
        <name>color</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>useRawValue</name>
      </member>
    </type>
    <type category="struct" name="VkRenderPassCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>VkRect</type>
        <name>renderArea</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>colorAttachmentCount</name>
      </member>
      <member>
        <type>VkExtent2D</type>
        <name>extent</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>sampleCount</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>layers</name>
      </member>
      <member>
        const <type>VkFormat</type>*        <name>pColorFormats</name>
      </member>
      <member>
        const <type>VkImageLayout</type>*   <name>pColorLayouts</name>
      </member>
      <member>
        const <type>VkAttachmentLoadOp</type>* <name>pColorLoadOps</name>
      </member>
      <member>
        const <type>VkAttachmentStoreOp</type>* <name>pColorStoreOps</name>
      </member>
      <member>
        const <type>VkClearColor</type>*    <name>pColorLoadClearValues</name>
      </member>
      <member>
        <type>VkFormat</type>
        <name>depthStencilFormat</name>
      </member>
      <member>
        <type>VkImageLayout</type>
        <name>depthStencilLayout</name>
      </member>
      <member>
        <type>VkAttachmentLoadOp</type>
        <name>depthLoadOp</name>
      </member>
      <member>
        <type>float</type>
        <name>depthLoadClearValue</name>
      </member>
      <member>
        <type>VkAttachmentStoreOp</type>
        <name>depthStoreOp</name>
      </member>
      <member>
        <type>VkAttachmentLoadOp</type>
        <name>stencilLoadOp</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>stencilLoadClearValue</name>
      </member>
      <member>
        <type>VkAttachmentStoreOp</type>
        <name>stencilStoreOp</name>
      </member>
    </type>
    <type category="struct" name="VkEventCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_EVENT_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>VkEventCreateFlags</type>
        <name>flags</name>
      </member>
      <!-- Event creation flags -->
    </type>
    <type category="struct" name="VkFenceCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_FENCE_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>VkFenceCreateFlags</type>
        <name>flags</name>
      </member>
      <!-- Fence creation flags -->
    </type>
    <type category="struct" name="VkPhysicalDeviceFeatures">
      <!-- GFL_32 features -->
      <member>
        <type>bool32_t</type>
        <name>supportsGeometryShader</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsTessellationShader</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsSampleRateShading</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsFragmentSideEffects</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsConstantStorageBufferArrayIdexing</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsConstantStorageImageArrayIndexing</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsConstantUniformBufferArrayIndexing</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsDynamicSampledImageArrayIndexing</name>
      </member>
      <!-- GFL_45 features -->
      <member>
        <type>bool32_t</type>
        <name>supportsBlendSrc1</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsClipAndCullDistance</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsLogicOp</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsInstancedDrawIndirect</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsDepthClip</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsFillMode</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsStorageImageExtendedFormats</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsStorageImageMultisample</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsPipelineStatisticsQuery</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsVTGSideEffects</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsDynamicUniformBufferArrayIndexing</name>
      </member>
      <!-- optional features -->
      <member>
        <type>bool32_t</type>
        <name>supportsDynamicStorageBufferArrayIndexing</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsDynamicStorageImageArrayIndexing</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsShaderFloat64</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsDepthBounds</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsWideLines</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsTextureCompressionETC2</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsTextureCompressionASTC_LDR</name>
      </member>
      <member>
        <type>bool32_t</type>
        <name>supportsTextureCompressionBC</name>
      </member>
    </type>
    <type category="struct" name="VkPhysicalDeviceLimits">
      <member>
        <type>uint32_t</type>
        <name>maxImageDimensions</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>maxImageDepth</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>maxImageArrayLayers</name>
      </member>
      <!-- lots more -->
    </type>
    <type category="struct" name="VkSemaphoreCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>uint32_t</type>
        <name>initialCount</name>
      </member>
      <member>
        <type>VkSemaphoreCreateFlags</type>
        <name>flags</name>
      </member>
      <!-- Semaphore creation flags -->
    </type>
    <type category="struct" name="VkQueryPoolCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>VkQueryType</type>
        <name>queryType</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>slots</name>
      </member>
      <member>
        <type>VkQueryPipelineStatisticFlags</type>
        <name>pipelineStatistics</name>
      </member>
      <!-- Optional -->
    </type>
    <type category="struct" name="VkFramebufferCreateInfo">
      <member>
        <type>VkStructureType</type>
        <name>sType</name>
      </member>
      <!-- Must be VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO -->
      <member>
        const void*                         <name>pNext</name>
      </member>
      <!-- Pointer to next structure -->
      <member>
        <type>uint32_t</type>
        <name>colorAttachmentCount</name>
      </member>
      <member>
        const <type>VkColorAttachmentBindInfo</type>* <name>pColorAttachments</name>
      </member>
      <member>
        const <type>VkDepthStencilBindInfo</type>* <name>pDepthStencilAttachment</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>sampleCount</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>width</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>height</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>layers</name>
      </member>
    </type>
    <type category="struct" name="VkDrawIndirectCmd">
      <member>
        <type>uint32_t</type>
        <name>vertexCount</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>instanceCount</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>firstVertex</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>firstInstance</name>
      </member>
    </type>
    <type category="struct" name="VkDrawIndexedIndirectCmd">
      <member>
        <type>uint32_t</type>
        <name>indexCount</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>instanceCount</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>firstIndex</name>
      </member>
      <member>
        <type>int32_t</type>
        <name>vertexOffset</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>firstInstance</name>
      </member>
    </type>
    <type category="struct" name="VkDispatchIndirectCmd">
      <member>
        <type>uint32_t</type>
        <name>x</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>y</name>
      </member>
      <member>
        <type>uint32_t</type>
        <name>z</name>
      </member>
    </type>
  </types>

  <!-- SECTION: Vulkan enumerant (token) definitions. -->

  <enums namespace="VK" comment="Misc. hardcoded constants - not an enumerated type">
    <!-- This is part of the header boilerplate -->
    <enum value="256"        name="VK_MAX_PHYSICAL_DEVICE_NAME"/>
    <enum value="256"        name="VK_MAX_EXTENSION_NAME"/>
    <enum value="MAX_FLOAT"  name="VK_LOD_CLAMP_NONE"/>
    <enum value="UINT32_MAX" name="VK_LAST_MIP_LEVEL"/>
    <enum value="UINT32_MAX" name="VK_LAST_ARRAY_SLICE"/>
    <enum value="UINT64_MAX" name="VK_WHOLE_SIZE"/>
    <enum value="1"          name="VK_TRUE"/>
    <enum value="0"          name="VK_FALSE"/>
    <enum value="0"          name="VK_NULL_HANDLE"/>
  </enums>

  <!-- Unlike OpenGL, most tokens in Vulkan are actual typed enumerants in
         their own numeric namespaces. The "name" attribute is the C enum
         type name, and is pulled in from a <type> definition above
         (slightly clunky, but retains the type / enum distinction). "type"
         attributes of "enum" or "bitmask" indicate that these values should
         be generated inside an appropriate definition. -->

  <enums namespace="VK" name="VkImageLayout" type="enum" expand="VK_IMAGE_LAYOUT">
    <enum value="0"     name="VK_IMAGE_LAYOUT_UNDEFINED"                         comment="Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation)"/>
    <enum value="1"     name="VK_IMAGE_LAYOUT_GENERAL"                           comment="General layout when image can be used for any kind of access"/>
    <enum value="2"     name="VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL"          comment="Optimal layout when image is only used for color attachment read/write"/>
    <enum value="3"     name="VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL"  comment="Optimal layout when image is only used for depth/stencil attachment read/write"/>
    <enum value="4"     name="VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL"   comment="Optimal layout when image is used for read only depth/stencil attachment and shader access"/>
    <enum value="5"     name="VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL"          comment="Optimal layout when image is used for read only shader access"/>
    <enum value="6"     name="VK_IMAGE_LAYOUT_CLEAR_OPTIMAL"                     comment="Optimal layout when image is used only for clear operations"/>
    <enum value="7"     name="VK_IMAGE_LAYOUT_TRANSFER_SOURCE_OPTIMAL"           comment="Optimal layout when image is used only as source of transfer operations"/>
    <enum value="8"     name="VK_IMAGE_LAYOUT_TRANSFER_DESTINATION_OPTIMAL"      comment="Optimal layout when image is used only as destination of transfer operations"/>
  </enums>
  <enums namespace="VK" name="VkPipeEvent" type="enum" expand="VK_PIPE_EVENT">
    <enum value="1"     name="VK_PIPE_EVENT_TOP_OF_PIPE"                         comment="Set event before the device starts processing subsequent command"/>
    <enum value="2"     name="VK_PIPE_EVENT_VERTEX_PROCESSING_COMPLETE"          comment="Set event when all pending vertex processing is complete"/>
    <enum value="3"     name="VK_PIPE_EVENT_LOCAL_FRAGMENT_PROCESSING_COMPLETE"  comment="Set event when all pending fragment shader executions are complete, within each fragment location"/>
    <enum value="4"     name="VK_PIPE_EVENT_FRAGMENT_PROCESSING_COMPLETE"        comment="Set event when all pending fragment shader executions are complete"/>
    <enum value="5"     name="VK_PIPE_EVENT_GRAPHICS_PIPELINE_COMPLETE"          comment="Set event when all pending graphics operations are complete"/>
    <enum value="6"     name="VK_PIPE_EVENT_COMPUTE_PIPELINE_COMPLETE"           comment="Set event when all pending compute operations are complete"/>
    <enum value="7"     name="VK_PIPE_EVENT_TRANSFER_COMPLETE"                   comment="Set event when all pending transfer operations are complete"/>
    <enum value="8"     name="VK_PIPE_EVENT_COMMANDS_COMPLETE"                   comment="Set event when all pending work is complete"/>
  </enums>
  <enums namespace="VK" name="VkWaitEvent" type="enum" expand="VK_WAIT_EVENT">
    <enum value="1"     name="VK_WAIT_EVENT_TOP_OF_PIPE"                         comment="Wait event before the device starts processing subsequent commands"/>
    <enum value="2"     name="VK_WAIT_EVENT_BEFORE_RASTERIZATION"                comment="Wait event before rasterizing subsequent primitives"/>
  </enums>
  <enums namespace="VK" name="VkAttachmentLoadOp" type="enum" expand="VK_ATTACHMENT_LOAD_OP">
    <enum value="0"     name="VK_ATTACHMENT_LOAD_OP_LOAD"/>
    <enum value="1"     name="VK_ATTACHMENT_LOAD_OP_CLEAR"/>
    <enum value="2"     name="VK_ATTACHMENT_LOAD_OP_DONT_CARE"/>
  </enums>
  <enums namespace="VK" name="VkAttachmentStoreOp" type="enum" expand="VK_ATTACHMENT_STORE_OP">
    <enum value="0"     name="VK_ATTACHMENT_STORE_OP_STORE"/>
    <enum value="1"     name="VK_ATTACHMENT_STORE_OP_RESOLVE_MSAA"/>
    <enum value="2"     name="VK_ATTACHMENT_STORE_OP_DONT_CARE"/>
  </enums>
  <enums namespace="VK" name="VkImageType" type="enum" expand="VK_IMAGE_TYPE">
    <enum value="0"     name="VK_IMAGE_TYPE_1D"/>
    <enum value="1"     name="VK_IMAGE_TYPE_2D"/>
    <enum value="2"     name="VK_IMAGE_TYPE_3D"/>
  </enums>
  <enums namespace="VK" name="VkImageTiling" type="enum" expand="VK_IMAGE_TILING">
    <enum value="0"     name="VK_IMAGE_TILING_LINEAR"/>
    <enum value="1"     name="VK_IMAGE_TILING_OPTIMAL"/>
  </enums>
  <enums namespace="VK" name="VkImageViewType" type="enum" expand="VK_IMAGE_VIEW_TYPE">
    <enum value="0"     name="VK_IMAGE_VIEW_TYPE_1D"/>
    <enum value="1"     name="VK_IMAGE_VIEW_TYPE_2D"/>
    <enum value="2"     name="VK_IMAGE_VIEW_TYPE_3D"/>
    <enum value="3"     name="VK_IMAGE_VIEW_TYPE_CUBE"/>
  </enums>
  <enums namespace="VK" name="VkImageAspect" type="enum" expand="VK_IMAGE_ASPECT">
    <enum value="0"     name="VK_IMAGE_ASPECT_COLOR"/>
    <enum value="1"     name="VK_IMAGE_ASPECT_DEPTH"/>
    <enum value="2"     name="VK_IMAGE_ASPECT_STENCIL"/>
  </enums>
  <enums namespace="VK" name="VkBufferViewType" type="enum" expand="VK_BUFFER_VIEW_TYPE">
    <enum value="0"     name="VK_BUFFER_VIEW_TYPE_RAW"                           comment="Raw buffer without special structure (UBO, SSBO)"/>
    <enum value="1"     name="VK_BUFFER_VIEW_TYPE_FORMATTED"                     comment="Buffer with format (TBO, IBO)"/>
  </enums>
  <enums namespace="VK" name="VkChannelSwizzle" type="enum" expand="VK_CHANNEL_SWIZZLE">
    <enum value="0"     name="VK_CHANNEL_SWIZZLE_ZERO"/>
    <enum value="1"     name="VK_CHANNEL_SWIZZLE_ONE"/>
    <enum value="2"     name="VK_CHANNEL_SWIZZLE_R"/>
    <enum value="3"     name="VK_CHANNEL_SWIZZLE_G"/>
    <enum value="4"     name="VK_CHANNEL_SWIZZLE_B"/>
    <enum value="5"     name="VK_CHANNEL_SWIZZLE_A"/>
  </enums>
  <enums namespace="VK" name="VkDescriptorType" type="enum" expand="VK_DESCRIPTOR_TYPE">
    <enum value="0"     name="VK_DESCRIPTOR_TYPE_SAMPLER"/>
    <enum value="1"     name="VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"/>
    <enum value="2"     name="VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE"/>
    <enum value="3"     name="VK_DESCRIPTOR_TYPE_STORAGE_IMAGE"/>
    <enum value="4"     name="VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER"/>
    <enum value="5"     name="VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER"/>
    <enum value="6"     name="VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER"/>
    <enum value="7"     name="VK_DESCRIPTOR_TYPE_STORAGE_BUFFER"/>
    <enum value="8"     name="VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC"/>
    <enum value="9"     name="VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC"/>
  </enums>
  <enums namespace="VK" name="VkDescriptorPoolUsage" type="enum" expand="VK_DESCRIPTOR_POOL_USAGE">
    <enum value="0"     name="VK_DESCRIPTOR_POOL_USAGE_ONE_SHOT"/>
    <enum value="1"     name="VK_DESCRIPTOR_POOL_USAGE_DYNAMIC"/>
  </enums>
  <enums namespace="VK" name="VkDescriptorSetUsage" type="enum" expand="VK_DESCRIPTOR_SET_USAGE">
    <enum value="0"     name="VK_DESCRIPTOR_SET_USAGE_ONE_SHOT"/>
    <enum value="1"     name="VK_DESCRIPTOR_SET_USAGE_STATIC"/>
  </enums>
  <enums namespace="VK" name="VkQueryType" type="enum" expand="VK_QUERY_TYPE">
    <enum value="0"     name="VK_QUERY_TYPE_OCCLUSION"/>
    <enum value="1"     name="VK_QUERY_TYPE_PIPELINE_STATISTICS"                 comment="Optional"/>
  </enums>
  <enums namespace="VK" name="VkTimestampType" type="enum" expand="VK_TIMESTAMP_TYPE">
    <enum value="0"     name="VK_TIMESTAMP_TYPE_TOP"/>
    <enum value="1"     name="VK_TIMESTAMP_TYPE_BOTTOM"/>
  </enums>
  <enums namespace="VK" name="VkBorderColor" type="enum" expand="VK_BORDER_COLOR">
    <enum value="0"     name="VK_BORDER_COLOR_OPAQUE_WHITE"/>
    <enum value="1"     name="VK_BORDER_COLOR_TRANSPARENT_BLACK"/>
    <enum value="2"     name="VK_BORDER_COLOR_OPAQUE_BLACK"/>
  </enums>
  <enums namespace="VK" name="VkPipelineBindPoint" type="enum" expand="VK_PIPELINE_BIND_POINT">
    <enum value="0"     name="VK_PIPELINE_BIND_POINT_COMPUTE"/>
    <enum value="1"     name="VK_PIPELINE_BIND_POINT_GRAPHICS"/>
  </enums>
  <enums namespace="VK" name="VkStateBindPoint" type="enum" expand="VK_STATE_BIND_POINT">
    <enum value="0"     name="VK_STATE_BIND_POINT_VIEWPORT"/>
    <enum value="1"     name="VK_STATE_BIND_POINT_RASTER"/>
    <enum value="2"     name="VK_STATE_BIND_POINT_COLOR_BLEND"/>
    <enum value="3"     name="VK_STATE_BIND_POINT_DEPTH_STENCIL"/>
  </enums>
  <enums namespace="VK" name="VkPrimitiveTopology" type="enum" expand="VK_PRIMITIVE_TOPOLOGY">
    <enum value="0"     name="VK_PRIMITIVE_TOPOLOGY_POINT_LIST"/>
    <enum value="1"     name="VK_PRIMITIVE_TOPOLOGY_LINE_LIST"/>
    <enum value="2"     name="VK_PRIMITIVE_TOPOLOGY_LINE_STRIP"/>
    <enum value="3"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST"/>
    <enum value="4"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP"/>
    <enum value="5"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN"/>
    <enum value="6"     name="VK_PRIMITIVE_TOPOLOGY_LINE_LIST_ADJ"/>
    <enum value="7"     name="VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_ADJ"/>
    <enum value="8"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_ADJ"/>
    <enum value="9"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_ADJ"/>
    <enum value="10"    name="VK_PRIMITIVE_TOPOLOGY_PATCH"/>
  </enums>
  <enums namespace="VK" name="VkIndexType" type="enum" expand="VK_INDEX_TYPE">
    <enum value="0"     name="VK_INDEX_TYPE_UINT8"/>
    <enum value="1"     name="VK_INDEX_TYPE_UINT16"/>
    <enum value="2"     name="VK_INDEX_TYPE_UINT32"/>
  </enums>
  <enums namespace="VK" name="VkTexFilter" type="enum" expand="VK_TEX_FILTER">
    <enum value="0"     name="VK_TEX_FILTER_NEAREST"/>
    <enum value="1"     name="VK_TEX_FILTER_LINEAR"/>
  </enums>
  <enums namespace="VK" name="VkTexMipmapMode" type="enum" expand="VK_TEX_MIPMAP_MODE">
    <enum value="0"     name="VK_TEX_MIPMAP_MODE_BASE"                           comment="Always choose base level"/>
    <enum value="1"     name="VK_TEX_MIPMAP_MODE_NEAREST"                        comment="Choose nearest mip level"/>
    <enum value="2"     name="VK_TEX_MIPMAP_MODE_LINEAR"                         comment="Linear filter between mip levels"/>
  </enums>
  <enums namespace="VK" name="VkTexAddress" type="enum" expand="VK_TEX_ADDRESS">
    <enum value="0"     name="VK_TEX_ADDRESS_WRAP"/>
    <enum value="1"     name="VK_TEX_ADDRESS_MIRROR"/>
    <enum value="2"     name="VK_TEX_ADDRESS_CLAMP"/>
    <enum value="3"     name="VK_TEX_ADDRESS_MIRROR_ONCE"/>
    <enum value="4"     name="VK_TEX_ADDRESS_CLAMP_BORDER"/>
  </enums>
  <enums namespace="VK" name="VkCompareOp" type="enum" expand="VK_COMPARE_OP">
    <enum value="0"     name="VK_COMPARE_OP_NEVER"/>
    <enum value="1"     name="VK_COMPARE_OP_LESS"/>
    <enum value="2"     name="VK_COMPARE_OP_EQUAL"/>
    <enum value="3"     name="VK_COMPARE_OP_LESS_EQUAL"/>
    <enum value="4"     name="VK_COMPARE_OP_GREATER"/>
    <enum value="5"     name="VK_COMPARE_OP_NOT_EQUAL"/>
    <enum value="6"     name="VK_COMPARE_OP_GREATER_EQUAL"/>
    <enum value="7"     name="VK_COMPARE_OP_ALWAYS"/>
  </enums>
  <enums namespace="VK" name="VkFillMode" type="enum" expand="VK_FILL_MODE">
    <enum value="0"     name="VK_FILL_MODE_POINTS"/>
    <enum value="1"     name="VK_FILL_MODE_WIREFRAME"/>
    <enum value="2"     name="VK_FILL_MODE_SOLID"/>
  </enums>
  <enums namespace="VK" name="VkCullMode" type="enum" expand="VK_CULL_MODE">
    <enum value="0"     name="VK_CULL_MODE_NONE"/>
    <enum value="1"     name="VK_CULL_MODE_FRONT"/>
    <enum value="2"     name="VK_CULL_MODE_BACK"/>
    <enum value="3"     name="VK_CULL_MODE_FRONT_AND_BACK"/>
  </enums>
  <enums namespace="VK" name="VkFrontFace" type="enum" expand="VK_FRONT_FACE">
    <enum value="0"     name="VK_FRONT_FACE_CCW"/>
    <enum value="1"     name="VK_FRONT_FACE_CW"/>
  </enums>
  <enums namespace="VK" name="VkBlend" type="enum" expand="VK_BLEND">
    <enum value="0"     name="VK_BLEND_ZERO"/>
    <enum value="1"     name="VK_BLEND_ONE"/>
    <enum value="2"     name="VK_BLEND_SRC_COLOR"/>
    <enum value="3"     name="VK_BLEND_ONE_MINUS_SRC_COLOR"/>
    <enum value="4"     name="VK_BLEND_DEST_COLOR"/>
    <enum value="5"     name="VK_BLEND_ONE_MINUS_DEST_COLOR"/>
    <enum value="6"     name="VK_BLEND_SRC_ALPHA"/>
    <enum value="7"     name="VK_BLEND_ONE_MINUS_SRC_ALPHA"/>
    <enum value="8"     name="VK_BLEND_DEST_ALPHA"/>
    <enum value="9"     name="VK_BLEND_ONE_MINUS_DEST_ALPHA"/>
    <enum value="10"    name="VK_BLEND_CONSTANT_COLOR"/>
    <enum value="11"    name="VK_BLEND_ONE_MINUS_CONSTANT_COLOR"/>
    <enum value="12"    name="VK_BLEND_CONSTANT_ALPHA"/>
    <enum value="13"    name="VK_BLEND_ONE_MINUS_CONSTANT_ALPHA"/>
    <enum value="14"    name="VK_BLEND_SRC_ALPHA_SATURATE"/>
    <enum value="15"    name="VK_BLEND_SRC1_COLOR"/>
    <enum value="16"    name="VK_BLEND_ONE_MINUS_SRC1_COLOR"/>
    <enum value="17"    name="VK_BLEND_SRC1_ALPHA"/>
    <enum value="18"    name="VK_BLEND_ONE_MINUS_SRC1_ALPHA"/>
  </enums>
  <enums namespace="VK" name="VkBlendOp" type="enum" expand="VK_BLEND_OP">
    <enum value="0"     name="VK_BLEND_OP_ADD"/>
    <enum value="1"     name="VK_BLEND_OP_SUBTRACT"/>
    <enum value="2"     name="VK_BLEND_OP_REVERSE_SUBTRACT"/>
    <enum value="3"     name="VK_BLEND_OP_MIN"/>
    <enum value="4"     name="VK_BLEND_OP_MAX"/>
  </enums>
  <enums namespace="VK" name="VkStencilOp" type="enum" expand="VK_STENCIL_OP">
    <enum value="0"     name="VK_STENCIL_OP_KEEP"/>
    <enum value="1"     name="VK_STENCIL_OP_ZERO"/>
    <enum value="2"     name="VK_STENCIL_OP_REPLACE"/>
    <enum value="3"     name="VK_STENCIL_OP_INC_CLAMP"/>
    <enum value="4"     name="VK_STENCIL_OP_DEC_CLAMP"/>
    <enum value="5"     name="VK_STENCIL_OP_INVERT"/>
    <enum value="6"     name="VK_STENCIL_OP_INC_WRAP"/>
    <enum value="7"     name="VK_STENCIL_OP_DEC_WRAP"/>
  </enums>
  <enums namespace="VK" name="VkLogicOp" type="enum" expand="VK_LOGIC_OP">
    <enum value="0"     name="VK_LOGIC_OP_COPY"/>
    <enum value="1"     name="VK_LOGIC_OP_CLEAR"/>
    <enum value="2"     name="VK_LOGIC_OP_AND"/>
    <enum value="3"     name="VK_LOGIC_OP_AND_REVERSE"/>
    <enum value="4"     name="VK_LOGIC_OP_AND_INVERTED"/>
    <enum value="5"     name="VK_LOGIC_OP_NOOP"/>
    <enum value="6"     name="VK_LOGIC_OP_XOR"/>
    <enum value="7"     name="VK_LOGIC_OP_OR"/>
    <enum value="8"     name="VK_LOGIC_OP_NOR"/>
    <enum value="9"     name="VK_LOGIC_OP_EQUIV"/>
    <enum value="10"    name="VK_LOGIC_OP_INVERT"/>
    <enum value="11"    name="VK_LOGIC_OP_OR_REVERSE"/>
    <enum value="12"    name="VK_LOGIC_OP_COPY_INVERTED"/>
    <enum value="13"    name="VK_LOGIC_OP_OR_INVERTED"/>
    <enum value="14"    name="VK_LOGIC_OP_NAND"/>
    <enum value="15"    name="VK_LOGIC_OP_SET"/>
  </enums>
  <enums namespace="VK" name="VkSystemAllocType" type="enum" expand="VK_SYSTEM_ALLOC_TYPE">
    <enum value="0"     name="VK_SYSTEM_ALLOC_TYPE_API_OBJECT"/>
    <enum value="1"     name="VK_SYSTEM_ALLOC_TYPE_INTERNAL"/>
    <enum value="2"     name="VK_SYSTEM_ALLOC_TYPE_INTERNAL_TEMP"/>
    <enum value="3"     name="VK_SYSTEM_ALLOC_TYPE_INTERNAL_SHADER"/>
    <enum value="4"     name="VK_SYSTEM_ALLOC_TYPE_DEBUG"/>
  </enums>
  <enums namespace="VK" name="VkPhysicalDeviceType" type="enum" expand="VK_PHYSICAL_DEVICE_TYPE">
    <enum value="0"     name="VK_PHYSICAL_DEVICE_TYPE_OTHER"/>
    <enum value="1"     name="VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU"/>
    <enum value="2"     name="VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU"/>
    <enum value="3"     name="VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU"/>
    <enum value="4"     name="VK_PHYSICAL_DEVICE_TYPE_CPU"/>
  </enums>
  <enums namespace="VK" name="VkVertexInputStepRate" type="enum" expand="VK_VERTEX_INPUT_STEP_RATE">
    <enum value="0"     name="VK_VERTEX_INPUT_STEP_RATE_VERTEX"/>
    <enum value="1"     name="VK_VERTEX_INPUT_STEP_RATE_INSTANCE"/>
  </enums>
  <enums namespace="VK" name="VkFormat" type="enum" expand="VK_FORMAT" comment="Vulkan format definitions">
    <enum value="0"     name="VK_FORMAT_UNDEFINED"/>
    <enum value="1"     name="VK_FORMAT_R4G4_UNORM"/>
    <enum value="2"     name="VK_FORMAT_R4G4_USCALED"/>
    <enum value="3"     name="VK_FORMAT_R4G4B4A4_UNORM"/>
    <enum value="4"     name="VK_FORMAT_R4G4B4A4_USCALED"/>
    <enum value="5"     name="VK_FORMAT_R5G6B5_UNORM"/>
    <enum value="6"     name="VK_FORMAT_R5G6B5_USCALED"/>
    <enum value="7"     name="VK_FORMAT_R5G5B5A1_UNORM"/>
    <enum value="8"     name="VK_FORMAT_R5G5B5A1_USCALED"/>
    <enum value="9"     name="VK_FORMAT_R8_UNORM"/>
    <enum value="10"    name="VK_FORMAT_R8_SNORM"/>
    <enum value="11"    name="VK_FORMAT_R8_USCALED"/>
    <enum value="12"    name="VK_FORMAT_R8_SSCALED"/>
    <enum value="13"    name="VK_FORMAT_R8_UINT"/>
    <enum value="14"    name="VK_FORMAT_R8_SINT"/>
    <enum value="15"    name="VK_FORMAT_R8_SRGB"/>
    <enum value="16"    name="VK_FORMAT_R8G8_UNORM"/>
    <enum value="17"    name="VK_FORMAT_R8G8_SNORM"/>
    <enum value="18"    name="VK_FORMAT_R8G8_USCALED"/>
    <enum value="19"    name="VK_FORMAT_R8G8_SSCALED"/>
    <enum value="20"    name="VK_FORMAT_R8G8_UINT"/>
    <enum value="21"    name="VK_FORMAT_R8G8_SINT"/>
    <enum value="22"    name="VK_FORMAT_R8G8_SRGB"/>
    <enum value="23"    name="VK_FORMAT_R8G8B8_UNORM"/>
    <enum value="24"    name="VK_FORMAT_R8G8B8_SNORM"/>
    <enum value="25"    name="VK_FORMAT_R8G8B8_USCALED"/>
    <enum value="26"    name="VK_FORMAT_R8G8B8_SSCALED"/>
    <enum value="27"    name="VK_FORMAT_R8G8B8_UINT"/>
    <enum value="28"    name="VK_FORMAT_R8G8B8_SINT"/>
    <enum value="29"    name="VK_FORMAT_R8G8B8_SRGB"/>
    <enum value="30"    name="VK_FORMAT_R8G8B8A8_UNORM"/>
    <enum value="31"    name="VK_FORMAT_R8G8B8A8_SNORM"/>
    <enum value="32"    name="VK_FORMAT_R8G8B8A8_USCALED"/>
    <enum value="33"    name="VK_FORMAT_R8G8B8A8_SSCALED"/>
    <enum value="34"    name="VK_FORMAT_R8G8B8A8_UINT"/>
    <enum value="35"    name="VK_FORMAT_R8G8B8A8_SINT"/>
    <enum value="36"    name="VK_FORMAT_R8G8B8A8_SRGB"/>
    <enum value="37"    name="VK_FORMAT_R10G10B10A2_UNORM"/>
    <enum value="38"    name="VK_FORMAT_R10G10B10A2_SNORM"/>
    <enum value="39"    name="VK_FORMAT_R10G10B10A2_USCALED"/>
    <enum value="40"    name="VK_FORMAT_R10G10B10A2_SSCALED"/>
    <enum value="41"    name="VK_FORMAT_R10G10B10A2_UINT"/>
    <enum value="42"    name="VK_FORMAT_R10G10B10A2_SINT"/>
    <enum value="43"    name="VK_FORMAT_R16_UNORM"/>
    <enum value="44"    name="VK_FORMAT_R16_SNORM"/>
    <enum value="45"    name="VK_FORMAT_R16_USCALED"/>
    <enum value="46"    name="VK_FORMAT_R16_SSCALED"/>
    <enum value="47"    name="VK_FORMAT_R16_UINT"/>
    <enum value="48"    name="VK_FORMAT_R16_SINT"/>
    <enum value="49"    name="VK_FORMAT_R16_SFLOAT"/>
    <enum value="50"    name="VK_FORMAT_R16G16_UNORM"/>
    <enum value="51"    name="VK_FORMAT_R16G16_SNORM"/>
    <enum value="52"    name="VK_FORMAT_R16G16_USCALED"/>
    <enum value="53"    name="VK_FORMAT_R16G16_SSCALED"/>
    <enum value="54"    name="VK_FORMAT_R16G16_UINT"/>
    <enum value="55"    name="VK_FORMAT_R16G16_SINT"/>
    <enum value="56"    name="VK_FORMAT_R16G16_SFLOAT"/>
    <enum value="57"    name="VK_FORMAT_R16G16B16_UNORM"/>
    <enum value="58"    name="VK_FORMAT_R16G16B16_SNORM"/>
    <enum value="59"    name="VK_FORMAT_R16G16B16_USCALED"/>
    <enum value="60"    name="VK_FORMAT_R16G16B16_SSCALED"/>
    <enum value="61"    name="VK_FORMAT_R16G16B16_UINT"/>
    <enum value="62"    name="VK_FORMAT_R16G16B16_SINT"/>
    <enum value="63"    name="VK_FORMAT_R16G16B16_SFLOAT"/>
    <enum value="64"    name="VK_FORMAT_R16G16B16A16_UNORM"/>
    <enum value="65"    name="VK_FORMAT_R16G16B16A16_SNORM"/>
    <enum value="66"    name="VK_FORMAT_R16G16B16A16_USCALED"/>
    <enum value="67"    name="VK_FORMAT_R16G16B16A16_SSCALED"/>
    <enum value="68"    name="VK_FORMAT_R16G16B16A16_UINT"/>
    <enum value="69"    name="VK_FORMAT_R16G16B16A16_SINT"/>
    <enum value="70"    name="VK_FORMAT_R16G16B16A16_SFLOAT"/>
    <enum value="71"    name="VK_FORMAT_R32_UINT"/>
    <enum value="72"    name="VK_FORMAT_R32_SINT"/>
    <enum value="73"    name="VK_FORMAT_R32_SFLOAT"/>
    <enum value="74"    name="VK_FORMAT_R32G32_UINT"/>
    <enum value="75"    name="VK_FORMAT_R32G32_SINT"/>
    <enum value="76"    name="VK_FORMAT_R32G32_SFLOAT"/>
    <enum value="77"    name="VK_FORMAT_R32G32B32_UINT"/>
    <enum value="78"    name="VK_FORMAT_R32G32B32_SINT"/>
    <enum value="79"    name="VK_FORMAT_R32G32B32_SFLOAT"/>
    <enum value="80"    name="VK_FORMAT_R32G32B32A32_UINT"/>
    <enum value="81"    name="VK_FORMAT_R32G32B32A32_SINT"/>
    <enum value="82"    name="VK_FORMAT_R32G32B32A32_SFLOAT"/>
    <enum value="83"    name="VK_FORMAT_R64_SFLOAT"/>
    <enum value="84"    name="VK_FORMAT_R64G64_SFLOAT"/>
    <enum value="85"    name="VK_FORMAT_R64G64B64_SFLOAT"/>
    <enum value="86"    name="VK_FORMAT_R64G64B64A64_SFLOAT"/>
    <enum value="87"    name="VK_FORMAT_R11G11B10_UFLOAT"/>
    <enum value="88"    name="VK_FORMAT_R9G9B9E5_UFLOAT"/>
    <enum value="89"    name="VK_FORMAT_D16_UNORM"/>
    <enum value="90"    name="VK_FORMAT_D24_UNORM"/>
    <enum value="91"    name="VK_FORMAT_D32_SFLOAT"/>
    <enum value="92"    name="VK_FORMAT_S8_UINT"/>
    <enum value="93"    name="VK_FORMAT_D16_UNORM_S8_UINT"/>
    <enum value="94"    name="VK_FORMAT_D24_UNORM_S8_UINT"/>
    <enum value="95"    name="VK_FORMAT_D32_SFLOAT_S8_UINT"/>
    <enum value="96"    name="VK_FORMAT_BC1_RGB_UNORM"/>
    <enum value="97"    name="VK_FORMAT_BC1_RGB_SRGB"/>
    <enum value="98"    name="VK_FORMAT_BC1_RGBA_UNORM"/>
    <enum value="99"    name="VK_FORMAT_BC1_RGBA_SRGB"/>
    <enum value="100"   name="VK_FORMAT_BC2_UNORM"/>
    <enum value="101"   name="VK_FORMAT_BC2_SRGB"/>
    <enum value="102"   name="VK_FORMAT_BC3_UNORM"/>
    <enum value="103"   name="VK_FORMAT_BC3_SRGB"/>
    <enum value="104"   name="VK_FORMAT_BC4_UNORM"/>
    <enum value="105"   name="VK_FORMAT_BC4_SNORM"/>
    <enum value="106"   name="VK_FORMAT_BC5_UNORM"/>
    <enum value="107"   name="VK_FORMAT_BC5_SNORM"/>
    <enum value="108"   name="VK_FORMAT_BC6H_UFLOAT"/>
    <enum value="109"   name="VK_FORMAT_BC6H_SFLOAT"/>
    <enum value="110"   name="VK_FORMAT_BC7_UNORM"/>
    <enum value="111"   name="VK_FORMAT_BC7_SRGB"/>
    <enum value="112"   name="VK_FORMAT_ETC2_R8G8B8_UNORM"/>
    <enum value="113"   name="VK_FORMAT_ETC2_R8G8B8_SRGB"/>
    <enum value="114"   name="VK_FORMAT_ETC2_R8G8B8A1_UNORM"/>
    <enum value="115"   name="VK_FORMAT_ETC2_R8G8B8A1_SRGB"/>
    <enum value="116"   name="VK_FORMAT_ETC2_R8G8B8A8_UNORM"/>
    <enum value="117"   name="VK_FORMAT_ETC2_R8G8B8A8_SRGB"/>
    <enum value="118"   name="VK_FORMAT_EAC_R11_UNORM"/>
    <enum value="119"   name="VK_FORMAT_EAC_R11_SNORM"/>
    <enum value="120"   name="VK_FORMAT_EAC_R11G11_UNORM"/>
    <enum value="121"   name="VK_FORMAT_EAC_R11G11_SNORM"/>
    <enum value="122"   name="VK_FORMAT_ASTC_4x4_UNORM"/>
    <enum value="123"   name="VK_FORMAT_ASTC_4x4_SRGB"/>
    <enum value="124"   name="VK_FORMAT_ASTC_5x4_UNORM"/>
    <enum value="125"   name="VK_FORMAT_ASTC_5x4_SRGB"/>
    <enum value="126"   name="VK_FORMAT_ASTC_5x5_UNORM"/>
    <enum value="127"   name="VK_FORMAT_ASTC_5x5_SRGB"/>
    <enum value="128"   name="VK_FORMAT_ASTC_6x5_UNORM"/>
    <enum value="129"   name="VK_FORMAT_ASTC_6x5_SRGB"/>
    <enum value="130"   name="VK_FORMAT_ASTC_6x6_UNORM"/>
    <enum value="131"   name="VK_FORMAT_ASTC_6x6_SRGB"/>
    <enum value="132"   name="VK_FORMAT_ASTC_8x5_UNORM"/>
    <enum value="133"   name="VK_FORMAT_ASTC_8x5_SRGB"/>
    <enum value="134"   name="VK_FORMAT_ASTC_8x6_UNORM"/>
    <enum value="135"   name="VK_FORMAT_ASTC_8x6_SRGB"/>
    <enum value="136"   name="VK_FORMAT_ASTC_8x8_UNORM"/>
    <enum value="137"   name="VK_FORMAT_ASTC_8x8_SRGB"/>
    <enum value="138"   name="VK_FORMAT_ASTC_10x5_UNORM"/>
    <enum value="139"   name="VK_FORMAT_ASTC_10x5_SRGB"/>
    <enum value="140"   name="VK_FORMAT_ASTC_10x6_UNORM"/>
    <enum value="141"   name="VK_FORMAT_ASTC_10x6_SRGB"/>
    <enum value="142"   name="VK_FORMAT_ASTC_10x8_UNORM"/>
    <enum value="143"   name="VK_FORMAT_ASTC_10x8_SRGB"/>
    <enum value="144"   name="VK_FORMAT_ASTC_10x10_UNORM"/>
    <enum value="145"   name="VK_FORMAT_ASTC_10x10_SRGB"/>
    <enum value="146"   name="VK_FORMAT_ASTC_12x10_UNORM"/>
    <enum value="147"   name="VK_FORMAT_ASTC_12x10_SRGB"/>
    <enum value="148"   name="VK_FORMAT_ASTC_12x12_UNORM"/>
    <enum value="149"   name="VK_FORMAT_ASTC_12x12_SRGB"/>
    <enum value="150"   name="VK_FORMAT_B4G4R4A4_UNORM"/>
    <enum value="151"   name="VK_FORMAT_B5G5R5A1_UNORM"/>
    <enum value="152"   name="VK_FORMAT_B5G6R5_UNORM"/>
    <enum value="153"   name="VK_FORMAT_B5G6R5_USCALED"/>
    <enum value="154"   name="VK_FORMAT_B8G8R8_UNORM"/>
    <enum value="155"   name="VK_FORMAT_B8G8R8_SNORM"/>
    <enum value="156"   name="VK_FORMAT_B8G8R8_USCALED"/>
    <enum value="157"   name="VK_FORMAT_B8G8R8_SSCALED"/>
    <enum value="158"   name="VK_FORMAT_B8G8R8_UINT"/>
    <enum value="159"   name="VK_FORMAT_B8G8R8_SINT"/>
    <enum value="160"   name="VK_FORMAT_B8G8R8_SRGB"/>
    <enum value="161"   name="VK_FORMAT_B8G8R8A8_UNORM"/>
    <enum value="162"   name="VK_FORMAT_B8G8R8A8_SNORM"/>
    <enum value="163"   name="VK_FORMAT_B8G8R8A8_USCALED"/>
    <enum value="164"   name="VK_FORMAT_B8G8R8A8_SSCALED"/>
    <enum value="165"   name="VK_FORMAT_B8G8R8A8_UINT"/>
    <enum value="166"   name="VK_FORMAT_B8G8R8A8_SINT"/>
    <enum value="167"   name="VK_FORMAT_B8G8R8A8_SRGB"/>
    <enum value="168"   name="VK_FORMAT_B10G10R10A2_UNORM"/>
    <enum value="169"   name="VK_FORMAT_B10G10R10A2_SNORM"/>
    <enum value="170"   name="VK_FORMAT_B10G10R10A2_USCALED"/>
    <enum value="171"   name="VK_FORMAT_B10G10R10A2_SSCALED"/>
    <enum value="172"   name="VK_FORMAT_B10G10R10A2_UINT"/>
    <enum value="173"   name="VK_FORMAT_B10G10R10A2_SINT"/>
  </enums>
  <enums namespace="VK" name="VkShaderStage" type="enum" expand="VK_SHADER_STAGE" comment="Shader stage enumerant">
    <enum value="0"     name="VK_SHADER_STAGE_VERTEX"/>
    <enum value="1"     name="VK_SHADER_STAGE_TESS_CONTROL"/>
    <enum value="2"     name="VK_SHADER_STAGE_TESS_EVALUATION"/>
    <enum value="3"     name="VK_SHADER_STAGE_GEOMETRY"/>
    <enum value="4"     name="VK_SHADER_STAGE_FRAGMENT"/>
    <enum value="5"     name="VK_SHADER_STAGE_COMPUTE"/>
  </enums>
  <enums namespace="VK" name="VkStructureType" type="enum" expand="VK_STRUCTURE_TYPE" comment="Structure type enumerant">
    <enum value="0"     name="VK_STRUCTURE_TYPE_APPLICATION_INFO"/>
    <enum value="1"     name="VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"/>
    <enum value="2"     name="VK_STRUCTURE_TYPE_MEMORY_ALLOC_INFO"/>
    <enum value="3"     name="VK_STRUCTURE_TYPE_BUFFER_VIEW_ATTACH_INFO"/>
    <enum value="4"     name="VK_STRUCTURE_TYPE_IMAGE_VIEW_ATTACH_INFO"/>
    <enum value="5"     name="VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"/>
    <enum value="6"     name="VK_STRUCTURE_TYPE_COLOR_ATTACHMENT_VIEW_CREATE_INFO"/>
    <enum value="7"     name="VK_STRUCTURE_TYPE_DEPTH_STENCIL_VIEW_CREATE_INFO"/>
    <enum value="8"     name="VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"/>
    <enum value="9"     name="VK_STRUCTURE_TYPE_SHADER_CREATE_INFO"/>
    <enum value="10"    name="VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"/>
    <enum value="11"    name="VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"/>
    <enum value="12"    name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"/>
    <enum value="13"    name="VK_STRUCTURE_TYPE_DYNAMIC_VP_STATE_CREATE_INFO"/>
    <enum value="14"    name="VK_STRUCTURE_TYPE_DYNAMIC_RS_STATE_CREATE_INFO"/>
    <enum value="15"    name="VK_STRUCTURE_TYPE_DYNAMIC_CB_STATE_CREATE_INFO"/>
    <enum value="16"    name="VK_STRUCTURE_TYPE_DYNAMIC_DS_STATE_CREATE_INFO"/>
    <enum value="17"    name="VK_STRUCTURE_TYPE_CMD_BUFFER_CREATE_INFO"/>
    <enum value="18"    name="VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"/>
    <enum value="19"    name="VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"/>
    <enum value="20"    name="VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"/>
    <enum value="21"    name="VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"/>
    <enum value="22"    name="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"/>
    <enum value="23"    name="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"/>
    <enum value="24"    name="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"/>
    <enum value="25"    name="VK_STRUCTURE_TYPE_PIPELINE_IA_STATE_CREATE_INFO"/>
    <enum value="26"    name="VK_STRUCTURE_TYPE_PIPELINE_TESS_STATE_CREATE_INFO"/>
    <enum value="27"    name="VK_STRUCTURE_TYPE_PIPELINE_VP_STATE_CREATE_INFO"/>
    <enum value="28"    name="VK_STRUCTURE_TYPE_PIPELINE_RS_STATE_CREATE_INFO"/>
    <enum value="29"    name="VK_STRUCTURE_TYPE_PIPELINE_MS_STATE_CREATE_INFO"/>
    <enum value="30"    name="VK_STRUCTURE_TYPE_PIPELINE_CB_STATE_CREATE_INFO"/>
    <enum value="31"    name="VK_STRUCTURE_TYPE_PIPELINE_DS_STATE_CREATE_INFO"/>
    <enum value="32"    name="VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"/>
    <enum value="33"    name="VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"/>
    <enum value="34"    name="VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"/>
    <enum value="35"    name="VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"/>
    <enum value="36"    name="VK_STRUCTURE_TYPE_CMD_BUFFER_BEGIN_INFO"/>
    <enum value="37"    name="VK_STRUCTURE_TYPE_CMD_BUFFER_GRAPHICS_BEGIN_INFO"/>
    <enum value="38"    name="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"/>
    <enum value="39"    name="VK_STRUCTURE_TYPE_LAYER_CREATE_INFO"/>
    <enum value="40"    name="VK_STRUCTURE_TYPE_MEMORY_BARRIER"/>
    <enum value="41"    name="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"/>
    <enum value="42"    name="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"/>
    <enum value="43"    name="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"/>
    <enum value="44"    name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"/>
    <enum value="45"    name="VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"/>
    <enum value="46"    name="VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"/>
    <enum value="47"    name="VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"/>
    <enum value="48"    name="VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"/>
  </enums>
  <enums namespace="VK" name="VkObjectType" type="enum" expand="VK_OBJECT_TYPE" comment="Object type enumerant">
    <enum value="0"     name="VK_OBJECT_TYPE_INSTANCE"/>
    <enum value="1"     name="VK_OBJECT_TYPE_PHYSICAL_DEVICE"/>
    <enum value="2"     name="VK_OBJECT_TYPE_DEVICE"/>
    <enum value="3"     name="VK_OBJECT_TYPE_QUEUE"/>
    <enum value="4"     name="VK_OBJECT_TYPE_COMMAND_BUFFER"/>
    <enum value="5"     name="VK_OBJECT_TYPE_DEVICE_MEMORY"/>
    <enum value="6"     name="VK_OBJECT_TYPE_BUFFER"/>
    <enum value="7"     name="VK_OBJECT_TYPE_BUFFER_VIEW"/>
    <enum value="8"     name="VK_OBJECT_TYPE_IMAGE"/>
    <enum value="9"     name="VK_OBJECT_TYPE_IMAGE_VIEW"/>
    <enum value="10"    name="VK_OBJECT_TYPE_COLOR_ATTACHMENT_VIEW"/>
    <enum value="11"    name="VK_OBJECT_TYPE_DEPTH_STENCIL_VIEW"/>
    <enum value="12"    name="VK_OBJECT_TYPE_SHADER_MODULE"/>
    <enum value="13"    name="VK_OBJECT_TYPE_SHADER"/>
    <enum value="14"    name="VK_OBJECT_TYPE_PIPELINE"/>
    <enum value="15"    name="VK_OBJECT_TYPE_PIPELINE_LAYOUT"/>
    <enum value="16"    name="VK_OBJECT_TYPE_SAMPLER"/>
    <enum value="17"    name="VK_OBJECT_TYPE_DESCRIPTOR_SET"/>
    <enum value="18"    name="VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT"/>
    <enum value="19"    name="VK_OBJECT_TYPE_DESCRIPTOR_POOL"/>
    <enum value="20"    name="VK_OBJECT_TYPE_DYNAMIC_VP_STATE"/>
    <enum value="21"    name="VK_OBJECT_TYPE_DYNAMIC_RS_STATE"/>
    <enum value="22"    name="VK_OBJECT_TYPE_DYNAMIC_CB_STATE"/>
    <enum value="23"    name="VK_OBJECT_TYPE_DYNAMIC_DS_STATE"/>
    <enum value="24"    name="VK_OBJECT_TYPE_FENCE"/>
    <enum value="25"    name="VK_OBJECT_TYPE_SEMAPHORE"/>
    <enum value="26"    name="VK_OBJECT_TYPE_EVENT"/>
    <enum value="27"    name="VK_OBJECT_TYPE_QUERY_POOL"/>
    <enum value="28"    name="VK_OBJECT_TYPE_FRAMEBUFFER"/>
    <enum value="29"    name="VK_OBJECT_TYPE_RENDER_PASS"/>
  </enums>
  <enums namespace="VK" name="VkResult" type="enum" expand="VK_RESULT" comment="Error and return codes">
    <!-- Return codes for successful operation execution (positive values) -->
    <enum value="0"     name="VK_SUCCESS"/>
    <enum value="1"     name="VK_UNSUPPORTED"/>
    <enum value="2"     name="VK_NOT_READY"/>
    <enum value="3"     name="VK_TIMEOUT"/>
    <enum value="4"     name="VK_EVENT_SET"/>
    <enum value="5"     name="VK_EVENT_RESET"/>
    <!-- Error codes (negative values) -->
    <enum value="-1"    name="VK_ERROR_UNKNOWN"/>
    <enum value="-2"    name="VK_ERROR_UNAVAILABLE"/>
    <enum value="-3"    name="VK_ERROR_INITIALIZATION_FAILED"/>
    <enum value="-4"    name="VK_ERROR_OUT_OF_HOST_MEMORY"/>
    <enum value="-5"    name="VK_ERROR_OUT_OF_DEVICE_MEMORY"/>
    <enum value="-6"    name="VK_ERROR_DEVICE_ALREADY_CREATED"/>
    <enum value="-7"    name="VK_ERROR_DEVICE_LOST"/>
    <enum value="-8"    name="VK_ERROR_INVALID_POINTER"/>
    <enum value="-9"    name="VK_ERROR_INVALID_VALUE"/>
    <enum value="-10"   name="VK_ERROR_INVALID_HANDLE"/>
    <enum value="-11"   name="VK_ERROR_INVALID_ORDINAL"/>
    <enum value="-12"   name="VK_ERROR_INVALID_MEMORY_SIZE"/>
    <enum value="-13"   name="VK_ERROR_INVALID_EXTENSION"/>
    <enum value="-14"   name="VK_ERROR_INVALID_FLAGS"/>
    <enum value="-15"   name="VK_ERROR_INVALID_ALIGNMENT"/>
    <enum value="-16"   name="VK_ERROR_INVALID_FORMAT"/>
    <enum value="-17"   name="VK_ERROR_INVALID_IMAGE"/>
    <enum value="-18"   name="VK_ERROR_INVALID_DESCRIPTOR_SET_DATA"/>
    <enum value="-19"   name="VK_ERROR_INVALID_QUEUE_TYPE"/>
    <enum value="-20"   name="VK_ERROR_INVALID_OBJECT_TYPE"/>
    <enum value="-21"   name="VK_ERROR_UNSUPPORTED_SHADER_IL_VERSION"/>
    <enum value="-22"   name="VK_ERROR_BAD_SHADER_CODE"/>
    <enum value="-23"   name="VK_ERROR_BAD_PIPELINE_DATA"/>
    <enum value="-24"   name="VK_ERROR_NOT_MAPPABLE"/>
    <enum value="-25"   name="VK_ERROR_MEMORY_MAP_FAILED"/>
    <enum value="-26"   name="VK_ERROR_MEMORY_UNMAP_FAILED"/>
    <enum value="-27"   name="VK_ERROR_INCOMPATIBLE_DEVICE"/>
    <enum value="-28"   name="VK_ERROR_INCOMPATIBLE_DRIVER"/>
    <enum value="-29"   name="VK_ERROR_INCOMPLETE_COMMAND_BUFFER"/>
    <enum value="-30"   name="VK_ERROR_BUILDING_COMMAND_BUFFER"/>
    <enum value="-31"   name="VK_ERROR_MEMORY_NOT_BOUND"/>
    <enum value="-32"   name="VK_ERROR_INCOMPATIBLE_QUEUE"/>
    <unused start="-33"/>
  </enums>
  <!-- Flags -->
  <enums namespace="VK" name="VkDeviceCreateFlagBits" type="bitmask">
    <enum bitpos="0"    name="VK_DEVICE_CREATE_VALIDATION_BIT"/>
  </enums>
  <enums namespace="VK" name="VkQueueFlagBits" type="bitmask">
    <enum bitpos="0"    name="VK_QUEUE_GRAPHICS_BIT"                             comment="Queue supports graphics operations"/>
    <enum bitpos="1"    name="VK_QUEUE_COMPUTE_BIT"                              comment="Queue supports compute operations"/>
    <enum bitpos="2"    name="VK_QUEUE_DMA_BIT"                                  comment="Queue supports DMA operations"/>
    <enum bitpos="3"    name="VK_QUEUE_SPARSE_MEMMGR_BIT"                        comment="Queue supports sparse resource memory management operations"/>
    <enum bitpos="30"   name="VK_QUEUE_EXTENDED_BIT"                             comment="Extended queue"/>
  </enums>
  <enums namespace="VK" name="VkMemoryPropertyFlagBits" type="bitmask">
    <enum value="0"     name="VK_MEMORY_PROPERTY_DEVICE_ONLY"                    comment="If otherwise stated, then allocate memory on device"/>
    <enum bitpos="0"    name="VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT"               comment="Memory should be mappable by host"/>
    <enum bitpos="1"    name="VK_MEMORY_PROPERTY_HOST_NON_COHERENT_BIT"          comment="Memory may not have i/o coherency so vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges must be used flush/invalidate host cache"/>
    <enum bitpos="2"    name="VK_MEMORY_PROPERTY_HOST_UNCACHED_BIT"              comment="Memory should not be cached by the host"/>
    <enum bitpos="3"    name="VK_MEMORY_PROPERTY_HOST_WRITE_COMBINED_BIT"        comment="Memory should support host write combining"/>
    <enum bitpos="4"    name="VK_MEMORY_PROPERTY_PREFER_HOST_LOCAL"              comment="If set, prefer host access"/>
  </enums>
  <enums namespace="VK" name="VkMemoryOutputFlagBits" type="bitmask">
    <enum bitpos="0"    name="VK_MEMORY_OUTPUT_HOST_WRITE_BIT"                   comment="Controls output coherency of host writes"/>
    <enum bitpos="1"    name="VK_MEMORY_OUTPUT_SHADER_WRITE_BIT"                 comment="Controls output coherency of generic shader writes"/>
    <enum bitpos="2"    name="VK_MEMORY_OUTPUT_COLOR_ATTACHMENT_BIT"             comment="Controls output coherency of color attachment writes"/>
    <enum bitpos="3"    name="VK_MEMORY_OUTPUT_DEPTH_STENCIL_ATTACHMENT_BIT"     comment="Controls output coherency of depth/stencil attachment writes"/>
    <enum bitpos="4"    name="VK_MEMORY_OUTPUT_TRANSFER_BIT"                     comment="Controls output coherency of transfer operations"/>
  </enums>
  <enums namespace="VK" name="VkMemoryInputFlagBits" type="bitmask">
    <enum bitpos="0"    name="VK_MEMORY_INPUT_HOST_READ_BIT"                     comment="Controls input coherency of host reads"/>
    <enum bitpos="1"    name="VK_MEMORY_INPUT_INDIRECT_COMMAND_BIT"              comment="Controls input coherency of indirect command reads"/>
    <enum bitpos="2"    name="VK_MEMORY_INPUT_INDEX_FETCH_BIT"                   comment="Controls input coherency of index fetches"/>
    <enum bitpos="3"    name="VK_MEMORY_INPUT_VERTEX_ATTRIBUTE_FETCH_BIT"        comment="Controls input coherency of vertex attribute fetches"/>
    <enum bitpos="4"    name="VK_MEMORY_INPUT_UNIFORM_READ_BIT"                  comment="Controls input coherency of uniform buffer reads"/>
    <enum bitpos="5"    name="VK_MEMORY_INPUT_SHADER_READ_BIT"                   comment="Controls input coherency of generic shader reads"/>
    <enum bitpos="6"    name="VK_MEMORY_INPUT_COLOR_ATTACHMENT_BIT"              comment="Controls input coherency of color attachment reads"/>
    <enum bitpos="7"    name="VK_MEMORY_INPUT_DEPTH_STENCIL_ATTACHMENT_BIT"      comment="Controls input coherency of depth/stencil attachment reads"/>
    <enum bitpos="8"    name="VK_MEMORY_INPUT_TRANSFER_BIT"                      comment="Controls input coherency of transfer operations"/>
  </enums>
  <enums namespace="VK" name="VkBufferUsageFlagBits" type="bitmask">
    <enum value="0"     name="VK_BUFFER_USAGE_GENERAL"                           comment="No special usage"/>
    <enum bitpos="0"    name="VK_BUFFER_USAGE_TRANSFER_SOURCE_BIT"               comment="Can be used as a source of transfer operations"/>
    <enum bitpos="1"    name="VK_BUFFER_USAGE_TRANSFER_DESTINATION_BIT"          comment="Can be used as a destination of transfer operations"/>
    <enum bitpos="2"    name="VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT"          comment="Can be used as TBO"/>
    <enum bitpos="3"    name="VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT"          comment="Can be used as IBO"/>
    <enum bitpos="4"    name="VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT"                comment="Can be used as UBO"/>
    <enum bitpos="5"    name="VK_BUFFER_USAGE_STORAGE_BUFFER_BIT"                comment="Can be used as SSBO"/>
    <enum bitpos="6"    name="VK_BUFFER_USAGE_INDEX_BUFFER_BIT"                  comment="Can be used as source of fixed function index fetch (index buffer)"/>
    <enum bitpos="7"    name="VK_BUFFER_USAGE_VERTEX_BUFFER_BIT"                 comment="Can be used as source of fixed function vertex fetch (VBO)"/>
    <enum bitpos="8"    name="VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT"               comment="Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer)"/>
  </enums>
  <enums namespace="VK" name="VkBufferCreateFlagBits" type="bitmask">
    <enum bitpos="0"    name="VK_BUFFER_CREATE_SPARSE_BIT"                       comment="Buffer should support sparse backing"/>
  </enums>
  <enums namespace="VK" name="VkShaderStageFlagBits" type="bitmask">
    <enum bitpos="0"    name="VK_SHADER_STAGE_VERTEX_BIT"/>
    <enum bitpos="1"    name="VK_SHADER_STAGE_TESS_CONTROL_BIT"/>
    <enum bitpos="2"    name="VK_SHADER_STAGE_TESS_EVALUATION_BIT"/>
    <enum bitpos="3"    name="VK_SHADER_STAGE_GEOMETRY_BIT"/>
    <enum bitpos="4"    name="VK_SHADER_STAGE_FRAGMENT_BIT"/>
    <enum bitpos="5"    name="VK_SHADER_STAGE_COMPUTE_BIT"/>
    <enum value="0x7FFFFFFF"    name="VK_SHADER_STAGE_ALL"/>
  </enums>
  <enums namespace="VK" name="VkImageUsageFlagBits" type="bitmask">
    <enum value="0"     name="VK_IMAGE_USAGE_GENERAL"                            comment="No special usage"/>
    <enum bitpos="0"    name="VK_IMAGE_USAGE_TRANSFER_SOURCE_BIT"                comment="Can be used as a source of transfer operations"/>
    <enum bitpos="1"    name="VK_IMAGE_USAGE_TRANSFER_DESTINATION_BIT"           comment="Can be used as a destination of transfer operations"/>
    <enum bitpos="2"    name="VK_IMAGE_USAGE_SAMPLED_BIT"                        comment="Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)"/>
    <enum bitpos="3"    name="VK_IMAGE_USAGE_STORAGE_BIT"                        comment="Can be used as storage image (STORAGE_IMAGE descriptor type)"/>
    <enum bitpos="4"    name="VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT"               comment="Can be used as framebuffer color attachment"/>
    <enum bitpos="5"    name="VK_IMAGE_USAGE_DEPTH_STENCIL_BIT"                  comment="Can be used as framebuffer depth/stencil attachment"/>
    <enum bitpos="6"    name="VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT"           comment="Image data not needed outside of rendering"/>
  </enums>
  <enums namespace="VK" name="VkImageCreateFlagBits" type="bitmask">
    <enum bitpos="0"    name="VK_IMAGE_CREATE_INVARIANT_DATA_BIT"/>
    <enum bitpos="1"    name="VK_IMAGE_CREATE_SPARSE_BIT"                        comment="Image should support sparse backing"/>
    <enum bitpos="2"    name="VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT"                comment="Allows image views to have different format than the base image"/>
    <enum bitpos="3"    name="VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT"               comment="Allows creating image views with cube type from the created image"/>
  </enums>
  <enums namespace="VK" name="VkDepthStencilViewCreateFlagBits" type="bitmask">
    <enum bitpos="0"    name="VK_DEPTH_STENCIL_VIEW_CREATE_READ_ONLY_DEPTH_BIT"/>
    <enum bitpos="1"    name="VK_DEPTH_STENCIL_VIEW_CREATE_READ_ONLY_STENCIL_BIT"/>
  </enums>
  <enums namespace="VK" name="VkPipelineCreateFlagBits" type="bitmask">
    <enum bitpos="0"    name="VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT"/>
    <enum bitpos="1"    name="VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT"/>
  </enums>
  <enums namespace="VK" name="VkChannelFlagBits" type="bitmask">
    <enum bitpos="0"    name="VK_CHANNEL_R_BIT"/>
    <enum bitpos="1"    name="VK_CHANNEL_G_BIT"/>
    <enum bitpos="2"    name="VK_CHANNEL_B_BIT"/>
    <enum bitpos="3"    name="VK_CHANNEL_A_BIT"/>
  </enums>
  <enums namespace="VK" name="VkFenceCreateFlagBits" type="bitmask">
    <enum bitpos="0"    name="VK_FENCE_CREATE_SIGNALED_BIT"/>
  </enums>
  <enums namespace="VK" name="VkFormatFeatureFlagBits" type="bitmask">
    <enum bitpos="0"    name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT"               comment="Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)"/>
    <enum bitpos="1"    name="VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT"               comment="Format can be used for storage images (STORAGE_IMAGE descriptor type)"/>
    <enum bitpos="2"    name="VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT"        comment="Format supports atomic operations in case it's used for storage images"/>
    <enum bitpos="3"    name="VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT"        comment="Format can be used for uniform texel buffers (TBOs)"/>
    <enum bitpos="4"    name="VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT"        comment="Format can be used for storage texel buffers (IBOs)"/>
    <enum bitpos="5"    name="VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT" comment="Format supports atomic operations in case it's used for storage texel buffers"/>
    <enum bitpos="6"    name="VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT"               comment="Format can be used for vertex buffers (VBOs)"/>
    <enum bitpos="7"    name="VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT"            comment="Format can be used for color attachment images"/>
    <enum bitpos="8"    name="VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT"      comment="Format supports blending in case it's used for color attachment images"/>
    <enum bitpos="9"    name="VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT"    comment="Format can be used for depth/stencil attachment images"/>
    <enum bitpos="10"   name="VK_FORMAT_FEATURE_CONVERSION_BIT"                  comment="Format can be used as the source or destination of format converting blits"/>
  </enums>
  <enums namespace="VK" name="VkQueryControlFlagBits" type="bitmask">
    <enum bitpos="0"    name="VK_QUERY_CONTROL_CONSERVATIVE_BIT"                 comment="Allow conservative results to be collected by the query"/>
  </enums>
  <enums namespace="VK" name="VkQueryResultFlagBits" type="bitmask">
    <enum value="0"     name="VK_QUERY_RESULT_DEFAULT"                           comment="Results of the queries are immediately written to the destination buffer as 32-bit values"/>
    <enum bitpos="0"    name="VK_QUERY_RESULT_64_BIT"                            comment="Results of the queries are written to the destination buffer as 64-bit values"/>
    <enum bitpos="1"    name="VK_QUERY_RESULT_WAIT_BIT"                          comment="Results of the queries are waited on before proceeding with the result copy"/>
    <enum bitpos="2"    name="VK_QUERY_RESULT_WITH_AVAILABILITY_BIT"             comment="Besides the results of the query, the availability of the results is also written"/>
    <enum bitpos="3"    name="VK_QUERY_RESULT_PARTIAL_BIT"                       comment="Copy the partial results of the query even if the final results aren't available"/>
  </enums>
  <enums namespace="VK" name="VkCmdBufferOptimizeFlagBits" type="bitmask">
    <enum bitpos="0"    name="VK_CMD_BUFFER_OPTIMIZE_SMALL_BATCH_BIT"/>
    <enum bitpos="1"    name="VK_CMD_BUFFER_OPTIMIZE_PIPELINE_SWITCH_BIT"/>
    <enum bitpos="2"    name="VK_CMD_BUFFER_OPTIMIZE_ONE_TIME_SUBMIT_BIT"/>
    <enum bitpos="3"    name="VK_CMD_BUFFER_OPTIMIZE_DESCRIPTOR_SET_SWITCH_BIT"/>
  </enums>
  <enums namespace="VK" name="VkQueryPipelineStatisticFlagBits" type="bitmask">
    <enum bitpos="0"    name="VK_QUERY_PIPELINE_STATISTIC_IA_VERTICES_BIT"       comment="Optional"/>
    <enum bitpos="1"    name="VK_QUERY_PIPELINE_STATISTIC_IA_PRIMITIVES_BIT"     comment="Optional"/>
    <enum bitpos="2"    name="VK_QUERY_PIPELINE_STATISTIC_VS_INVOCATIONS_BIT"    comment="Optional"/>
    <enum bitpos="3"    name="VK_QUERY_PIPELINE_STATISTIC_GS_INVOCATIONS_BIT"    comment="Optional"/>
    <enum bitpos="4"    name="VK_QUERY_PIPELINE_STATISTIC_GS_PRIMITIVES_BIT"     comment="Optional"/>
    <enum bitpos="5"    name="VK_QUERY_PIPELINE_STATISTIC_C_INVOCATIONS_BIT"     comment="Optional"/>
    <enum bitpos="6"    name="VK_QUERY_PIPELINE_STATISTIC_C_PRIMITIVES_BIT"      comment="Optional"/>
    <enum bitpos="7"    name="VK_QUERY_PIPELINE_STATISTIC_FS_INVOCATIONS_BIT"    comment="Optional"/>
    <enum bitpos="8"    name="VK_QUERY_PIPELINE_STATISTIC_TCS_PATCHES_BIT"       comment="Optional"/>
    <enum bitpos="9"    name="VK_QUERY_PIPELINE_STATISTIC_TES_INVOCATIONS_BIT"   comment="Optional"/>
    <enum bitpos="10"   name="VK_QUERY_PIPELINE_STATISTIC_CS_INVOCATIONS_BIT"    comment="Optional"/>
  </enums>

  <!-- SECTION: Vulkan command definitions -->
  <commands namespace="vk">
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateInstance</name>
      </proto>
      <param>
        const <type>VkInstanceCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkInstance</type>* <name>pInstance</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkDestroyInstance</name>
      </proto>
      <param>
        <type>VkInstance</type>
        <name>instance</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkEnumeratePhysicalDevices</name>
      </proto>
      <param>
        <type>VkInstance</type>
        <name>instance</name>
      </param>
      <param>
        <type>uint32_t</type>* <name>pPhysicalDeviceCount</name>
      </param>
      <param>
        <type>VkPhysicalDevice</type>* <name>pPhysicalDevices</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkGetPhysicalDeviceProperties</name>
      </proto>
      <param>
        <type>VkPhysicalDevice</type>
        <name>physicalDevice</name>
      </param>
      <param>
        <type>VkPhysicalDeviceProperties</type>* <name>pProperties</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkGetPhysicalDeviceQueueCount</name>
      </proto>
      <param>
        <type>VkPhysicalDevice</type>
        <name>physicalDevice</name>
      </param>
      <param>
        <type>uint32_t</type>* <name>pCount</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkGetPhysicalDeviceQueueProperties</name>
      </proto>
      <param>
        <type>VkPhysicalDevice</type>
        <name>physicalDevice</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>count</name>
      </param>
      <param>
        <type>VkPhysicalDeviceQueueProperties</type>* <name>pQueueProperties</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkGetPhysicalDeviceMemoryProperties</name>
      </proto>
      <param>
        <type>VkPhysicalDevice</type>
        <name>physicalDevice</name>
      </param>
      <param>
        <type>VkPhysicalDeviceMemoryProperties</type>* <name>pMemoryProperies</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkGetPhysicalDeviceFeatures</name>
      </proto>
      <param>
        <type>VkPhysicalDevice</type>
        <name>physicalDevice</name>
      </param>
      <param>
        <type>VkPhysicalDeviceFeatures</type>* <name>pFeatures</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkGetPhysicalDeviceFormatInfo</name>
      </proto>
      <param>
        <type>VkPhysicalDevice</type>
        <name>physicalDevice</name>
      </param>
      <param>
        <type>VkFormat</type>
        <name>format</name>
      </param>
      <param>
        <type>VkFormatProperties</type>* <name>pFormatInfo</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkGetPhysicalDeviceLimits</name>
      </proto>
      <param>
        <type>VkPhysicalDevice</type>
        <name>physicalDevice</name>
      </param>
      <param>
        <type>VkPhysicalDeviceLimits</type>* <name>pLimits</name>
      </param>
    </command>
    <command>
      <proto>
        void * <name>vkGetProcAddr</name>
      </proto>
      <param>
        <type>VkPhysicalDevice</type>
        <name>physicalDevice</name>
      </param>
      <param>
        const char* <name>pName</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateDevice</name>
      </proto>
      <param>
        <type>VkPhysicalDevice</type>
        <name>physicalDevice</name>
      </param>
      <param>
        const <type>VkDeviceCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkDevice</type>* <name>pDevice</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkDestroyDevice</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkGetGlobalExtensionCount</name>
      </proto>
      <param>
        <type>uint32_t</type>* <name>pCount</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkGetGlobalExtensionProperties</name>
      </proto>
      <param>
        <type>uint32_t</type>
        <name>extensionIndex</name>
      </param>
      <param>
        <type>VkExtensionProperties</type>* <name>pProperties</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkGetPhysicalDeviceExtensionCount</name>
      </proto>
      <param>
        <type>VkPhysicalDevice</type>
        <name>physicalDevice</name>
      </param>
      <param>
        <type>uint32_t</type>* <name>pCount</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkGetPhysicalDeviceExtensionProperties</name>
      </proto>
      <param>
        <type>VkPhysicalDevice</type>
        <name>physicalDevice</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>extensionIndex</name>
      </param>
      <param>
        <type>VkExtensionProperties</type>* <name>pProperties</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkEnumerateLayers</name>
      </proto>
      <param>
        <type>VkPhysicalDevice</type>
        <name>physicalDevice</name>
      </param>
      <param>
        <type>size_t</type>
        <name>maxStringSize</name>
      </param>
      <param>
        <type>size_t</type>* <name>pLayerCount</name>
      </param>
      <param>
        char* const* <name>pOutLayers</name>
      </param>
      <param>
        void* <name>pReserved</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkGetDeviceQueue</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>queueNodeIndex</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>queueIndex</name>
      </param>
      <param>
        <type>VkQueue</type>* <name>pQueue</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkQueueSubmit</name>
      </proto>
      <param>
        <type>VkQueue</type>
        <name>queue</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>cmdBufferCount</name>
      </param>
      <param>
        const <type>VkCmdBuffer</type>* <name>pCmdBuffers</name>
      </param>
      <param>
        <type>VkFence</type>
        <name>fence</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkQueueWaitIdle</name>
      </proto>
      <param>
        <type>VkQueue</type>
        <name>queue</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkDeviceWaitIdle</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkAllocMemory</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkMemoryAllocInfo</type>* <name>pAllocInfo</name>
      </param>
      <param>
        <type>VkDeviceMemory</type>* <name>pMem</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkFreeMemory</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>VkDeviceMemory</type>
        <name>mem</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkMapMemory</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>VkDeviceMemory</type>
        <name>mem</name>
      </param>
      <param>
        <type>VkDeviceSize</type>
        <name>offset</name>
      </param>
      <param>
        <type>VkDeviceSize</type>
        <name>size</name>
      </param>
      <param>
        <type>VkMemoryMapFlags</type>
        <name>flags</name>
      </param>
      <param>
        void** <name>ppData</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkUnmapMemory</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>VkDeviceMemory</type>
        <name>mem</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkFlushMappedMemoryRanges</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>memRangeCount</name>
      </param>
      <param>
        const <type>VkMappedMemoryRange</type>* <name>pMemRanges</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkInvalidateMappedMemoryRanges</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>memRangeCount</name>
      </param>
      <param>
        const <type>VkMappedMemoryRange</type>* <name>pMemRanges</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkDestroyObject</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>VkObjectType</type>
        <name>objType</name>
      </param>
      <param>
        <type>VkObject</type>
        <name>object</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkGetObjectMemoryRequirements</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>VkObjectType</type>
        <name>objType</name>
      </param>
      <param>
        <type>VkObject</type>
        <name>object</name>
      </param>
      <param>
        <type>VkMemoryRequirements</type>* <name>pMemoryRequirements</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkBindObjectMemory</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>VkObjectType</type>
        <name>objType</name>
      </param>
      <param>
        <type>VkObject</type>
        <name>object</name>
      </param>
      <param>
        <type>VkDeviceMemory</type>
        <name>mem</name>
      </param>
      <param>
        <type>VkDeviceSize</type>
        <name>memOffset</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkQueueBindSparseBufferMemory</name>
      </proto>
      <param>
        <type>VkQueue</type>
        <name>queue</name>
      </param>
      <param>
        <type>VkBuffer</type>
        <name>buffer</name>
      </param>
      <param>
        <type>VkDeviceSize</type>
        <name>rangeOffset</name>
      </param>
      <param>
        <type>VkDeviceSize</type>
        <name>rangeSize</name>
      </param>
      <param>
        <type>VkDeviceMemory</type>
        <name>mem</name>
      </param>
      <param>
        <type>VkDeviceSize</type>
        <name>memOffset</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkQueueBindSparseImageMemory</name>
      </proto>
      <param>
        <type>VkQueue</type>
        <name>queue</name>
      </param>
      <param>
        <type>VkImage</type>
        <name>image</name>
      </param>
      <param>
        const <type>VkImageMemoryBindInfo</type>* <name>pBindInfo</name>
      </param>
      <param>
        <type>VkDeviceMemory</type>
        <name>mem</name>
      </param>
      <param>
        <type>VkDeviceSize</type>
        <name>memOffset</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateFence</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkFenceCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkFence</type>* <name>pFence</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkResetFences</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>fenceCount</name>
      </param>
      <param>
        const <type>VkFence</type>* <name>pFences</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkGetFenceStatus</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>VkFence</type>
        <name>fence</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkWaitForFences</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>fenceCount</name>
      </param>
      <param>
        const <type>VkFence</type>* <name>pFences</name>
      </param>
      <param>
        <type>bool32_t</type>
        <name>waitAll</name>
      </param>
      <param>
        <type>uint64_t</type>
        <name>timeout</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateSemaphore</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkSemaphoreCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkSemaphore</type>* <name>pSemaphore</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkQueueSignalSemaphore</name>
      </proto>
      <param>
        <type>VkQueue</type>
        <name>queue</name>
      </param>
      <param>
        <type>VkSemaphore</type>
        <name>semaphore</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkQueueWaitSemaphore</name>
      </proto>
      <param>
        <type>VkQueue</type>
        <name>queue</name>
      </param>
      <param>
        <type>VkSemaphore</type>
        <name>semaphore</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateEvent</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkEventCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkEvent</type>* <name>pEvent</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkGetEventStatus</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>VkEvent</type>
        <name>event</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkSetEvent</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>VkEvent</type>
        <name>event</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkResetEvent</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>VkEvent</type>
        <name>event</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateQueryPool</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkQueryPoolCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkQueryPool</type>* <name>pQueryPool</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkGetQueryPoolResults</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>VkQueryPool</type>
        <name>queryPool</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>startQuery</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>queryCount</name>
      </param>
      <param>
        <type>size_t</type>* <name>pDataSize</name>
      </param>
      <param>
        void* <name>pData</name>
      </param>
      <param>
        <type>VkQueryResultFlags</type>
        <name>flags</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateBuffer</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkBufferCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkBuffer</type>* <name>pBuffer</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateBufferView</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkBufferViewCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkBufferView</type>* <name>pView</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateImage</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkImageCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkImage</type>* <name>pImage</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkGetImageSubresourceLayout</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>VkImage</type>
        <name>image</name>
      </param>
      <param>
        const <type>VkImageSubresource</type>* <name>pSubresource</name>
      </param>
      <param>
        <type>VkSubresourceLayout</type>* <name>pLayout</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateImageView</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkImageViewCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkImageView</type>* <name>pView</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateColorAttachmentView</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkColorAttachmentViewCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkColorAttachmentView</type>* <name>pView</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateDepthStencilView</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkDepthStencilViewCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkDepthStencilView</type>* <name>pView</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateShaderModule</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkShaderModuleCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkShaderModule</type>* <name>pShaderModule</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateShader</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkShaderCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkShader</type>* <name>pShader</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateGraphicsPipeline</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkGraphicsPipelineCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkPipeline</type>* <name>pPipeline</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateGraphicsPipelineDerivative</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkGraphicsPipelineCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkPipeline</type>
        <name>basePipeline</name>
      </param>
      <param>
        <type>VkPipeline</type>* <name>pPipeline</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateComputePipeline</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkComputePipelineCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkPipeline</type>* <name>pPipeline</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkStorePipeline</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>VkPipeline</type>
        <name>pipeline</name>
      </param>
      <param>
        <type>size_t</type>* <name>pDataSize</name>
      </param>
      <param>
        void* <name>pData</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkLoadPipeline</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>size_t</type>
        <name>dataSize</name>
      </param>
      <param>
        const void* <name>pData</name>
      </param>
      <param>
        <type>VkPipeline</type>* <name>pPipeline</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkLoadPipelineDerivative</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>size_t</type>
        <name>dataSize</name>
      </param>
      <param>
        const void* <name>pData</name>
      </param>
      <param>
        <type>VkPipeline</type>
        <name>basePipeline</name>
      </param>
      <param>
        <type>VkPipeline</type>* <name>pPipeline</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreatePipelineLayout</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkPipelineLayoutCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkPipelineLayout</type>* <name>pPipelineLayout</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateSampler</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkSamplerCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkSampler</type>* <name>pSampler</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateDescriptorSetLayout</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkDescriptorSetLayoutCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkDescriptorSetLayout</type>* <name>pSetLayout</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateDescriptorPool</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>VkDescriptorPoolUsage</type>
        <name>poolUsage</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>maxSets</name>
      </param>
      <param>
        const <type>VkDescriptorPoolCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkDescriptorPool</type>* <name>pDescriptorPool</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkResetDescriptorPool</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>VkDescriptorPool</type>
        <name>descriptorPool</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkAllocDescriptorSets</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>VkDescriptorPool</type>
        <name>descriptorPool</name>
      </param>
      <param>
        <type>VkDescriptorSetUsage</type>
        <name>setUsage</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>count</name>
      </param>
      <param>
        const <type>VkDescriptorSetLayout</type>* <name>pSetLayouts</name>
      </param>
      <param>
        <type>VkDescriptorSet</type>* <name>pDescriptorSets</name>
      </param>
      <param>
        <type>uint32_t</type>* <name>pCount</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkUpdateDescriptorSets</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>writeCount</name>
      </param>
      <param>
        const <type>VkWriteDescriptorSet</type>* <name>pDescriptorWrites</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>copyCount</name>
      </param>
      <param>
        const <type>VkCopyDescriptorSet</type>* <name>pDescriptorCopies</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateDynamicViewportState</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkDynamicVpStateCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkDynamicVpState</type>* <name>pState</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateDynamicRasterState</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkDynamicRsStateCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkDynamicRsState</type>* <name>pState</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateDynamicColorBlendState</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkDynamicCbStateCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkDynamicCbState</type>* <name>pState</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateDynamicDepthStencilState</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkDynamicDsStateCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkDynamicDsState</type>* <name>pState</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateCommandBuffer</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkCmdBufferCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkCmdBuffer</type>* <name>pCmdBuffer</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkBeginCommandBuffer</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        const <type>VkCmdBufferBeginInfo</type>* <name>pBeginInfo</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkEndCommandBuffer</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkResetCommandBuffer</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdBindPipeline</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkPipelineBindPoint</type>
        <name>pipelineBindPoint</name>
      </param>
      <param>
        <type>VkPipeline</type>
        <name>pipeline</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdBindDynamicStateObject</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkStateBindPoint</type>
        <name>stateBindPoint</name>
      </param>
      <param>
        <type>VkDynamicStateObject</type>
        <name>dynamicState</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdBindDescriptorSets</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkPipelineBindPoint</type>
        <name>pipelineBindPoint</name>
      </param>
      <param>
        <type>VkPipelineLayout</type>
        <name>layout</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>firstSet</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>setCount</name>
      </param>
      <param>
        const <type>VkDescriptorSet</type>* <name>pDescriptorSets</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>dynamicOffsetCount</name>
      </param>
      <param>
        const <type>uint32_t</type>* <name>pDynamicOffsets</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdBindIndexBuffer</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkBuffer</type>
        <name>buffer</name>
      </param>
      <param>
        <type>VkDeviceSize</type>
        <name>offset</name>
      </param>
      <param>
        <type>VkIndexType</type>
        <name>indexType</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdBindVertexBuffers</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>startBinding</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>bindingCount</name>
      </param>
      <param>
        const <type>VkBuffer</type>* <name>pBuffers</name>
      </param>
      <param>
        const <type>VkDeviceSize</type>* <name>pOffsets</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdDraw</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>firstVertex</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>vertexCount</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>firstInstance</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>instanceCount</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdDrawIndexed</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>firstIndex</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>indexCount</name>
      </param>
      <param>
        <type>int32_t</type>
        <name>vertexOffset</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>firstInstance</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>instanceCount</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdDrawIndirect</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkBuffer</type>
        <name>buffer</name>
      </param>
      <param>
        <type>VkDeviceSize</type>
        <name>offset</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>count</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>stride</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdDrawIndexedIndirect</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkBuffer</type>
        <name>buffer</name>
      </param>
      <param>
        <type>VkDeviceSize</type>
        <name>offset</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>count</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>stride</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdDispatch</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>x</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>y</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>z</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdDispatchIndirect</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkBuffer</type>
        <name>buffer</name>
      </param>
      <param>
        <type>VkDeviceSize</type>
        <name>offset</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdCopyBuffer</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkBuffer</type>
        <name>srcBuffer</name>
      </param>
      <param>
        <type>VkBuffer</type>
        <name>destBuffer</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>regionCount</name>
      </param>
      <param>
        const <type>VkBufferCopy</type>* <name>pRegions</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdCopyImage</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkImage</type>
        <name>srcImage</name>
      </param>
      <param>
        <type>VkImageLayout</type>
        <name>srcImageLayout</name>
      </param>
      <param>
        <type>VkImage</type>
        <name>destImage</name>
      </param>
      <param>
        <type>VkImageLayout</type>
        <name>destImageLayout</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>regionCount</name>
      </param>
      <param>
        const <type>VkImageCopy</type>* <name>pRegions</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdBlitImage</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkImage</type>
        <name>srcImage</name>
      </param>
      <param>
        <type>VkImageLayout</type>
        <name>srcImageLayout</name>
      </param>
      <param>
        <type>VkImage</type>
        <name>destImage</name>
      </param>
      <param>
        <type>VkImageLayout</type>
        <name>destImageLayout</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>regionCount</name>
      </param>
      <param>
        const <type>VkImageBlit</type>* <name>pRegions</name>
      </param>
      <param>
        <type>VkTexFilter</type>
        <name>filter</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdCopyBufferToImage</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkBuffer</type>
        <name>srcBuffer</name>
      </param>
      <param>
        <type>VkImage</type>
        <name>destImage</name>
      </param>
      <param>
        <type>VkImageLayout</type>
        <name>destImageLayout</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>regionCount</name>
      </param>
      <param>
        const <type>VkBufferImageCopy</type>* <name>pRegions</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdCopyImageToBuffer</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkImage</type>
        <name>srcImage</name>
      </param>
      <param>
        <type>VkImageLayout</type>
        <name>srcImageLayout</name>
      </param>
      <param>
        <type>VkBuffer</type>
        <name>destBuffer</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>regionCount</name>
      </param>
      <param>
        const <type>VkBufferImageCopy</type>* <name>pRegions</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdUpdateBuffer</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkBuffer</type>
        <name>destBuffer</name>
      </param>
      <param>
        <type>VkDeviceSize</type>
        <name>destOffset</name>
      </param>
      <param>
        <type>VkDeviceSize</type>
        <name>dataSize</name>
      </param>
      <param>
        const <type>uint32_t</type>* <name>pData</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdFillBuffer</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkBuffer</type>
        <name>destBuffer</name>
      </param>
      <param>
        <type>VkDeviceSize</type>
        <name>destOffset</name>
      </param>
      <param>
        <type>VkDeviceSize</type>
        <name>fillSize</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>data</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdClearColorImage</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkImage</type>
        <name>image</name>
      </param>
      <param>
        <type>VkImageLayout</type>
        <name>imageLayout</name>
      </param>
      <param>
        const <type>VkClearColor</type>* <name>pColor</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>rangeCount</name>
      </param>
      <param>
        const <type>VkImageSubresourceRange</type>* <name>pRanges</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdClearDepthStencil</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkImage</type>
        <name>image</name>
      </param>
      <param>
        <type>VkImageLayout</type>
        <name>imageLayout</name>
      </param>
      <param>
        <type>float</type>
        <name>depth</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>stencil</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>rangeCount</name>
      </param>
      <param>
        const <type>VkImageSubresourceRange</type>* <name>pRanges</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdResolveImage</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkImage</type>
        <name>srcImage</name>
      </param>
      <param>
        <type>VkImageLayout</type>
        <name>srcImageLayout</name>
      </param>
      <param>
        <type>VkImage</type>
        <name>destImage</name>
      </param>
      <param>
        <type>VkImageLayout</type>
        <name>destImageLayout</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>regionCount</name>
      </param>
      <param>
        const <type>VkImageResolve</type>* <name>pRegions</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdSetEvent</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkEvent</type>
        <name>event</name>
      </param>
      <param>
        <type>VkPipeEvent</type>
        <name>pipeEvent</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdResetEvent</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkEvent</type>
        <name>event</name>
      </param>
      <param>
        <type>VkPipeEvent</type>
        <name>pipeEvent</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdWaitEvents</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkWaitEvent</type>
        <name>waitEvent</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>eventCount</name>
      </param>
      <param>
        const <type>VkEvent</type>* <name>pEvents</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>memBarrierCount</name>
      </param>
      <param>
        const void** <name>ppMemBarriers</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdPipelineBarrier</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkWaitEvent</type>
        <name>waitEvent</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>pipeEventCount</name>
      </param>
      <param>
        const <type>VkPipeEvent</type>* <name>pPipeEvents</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>memBarrierCount</name>
      </param>
      <param>
        const void** <name>ppMemBarriers</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdBeginQuery</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkQueryPool</type>
        <name>queryPool</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>slot</name>
      </param>
      <param>
        <type>VkQueryControlFlags</type>
        <name>flags</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdEndQuery</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkQueryPool</type>
        <name>queryPool</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>slot</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdResetQueryPool</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkQueryPool</type>
        <name>queryPool</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>startQuery</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>queryCount</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdWriteTimestamp</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkTimestampType</type>
        <name>timestampType</name>
      </param>
      <param>
        <type>VkBuffer</type>
        <name>destBuffer</name>
      </param>
      <param>
        <type>VkDeviceSize</type>
        <name>destOffset</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdCopyQueryPoolResults</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkQueryPool</type>
        <name>queryPool</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>startQuery</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>queryCount</name>
      </param>
      <param>
        <type>VkBuffer</type>
        <name>destBuffer</name>
      </param>
      <param>
        <type>VkDeviceSize</type>
        <name>destOffset</name>
      </param>
      <param>
        <type>VkDeviceSize</type>
        <name>destStride</name>
      </param>
      <param>
        <type>VkQueryResultFlags</type>
        <name>flags</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdInitAtomicCounters</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkPipelineBindPoint</type>
        <name>pipelineBindPoint</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>startCounter</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>counterCount</name>
      </param>
      <param>
        const <type>uint32_t</type>* <name>pData</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdLoadAtomicCounters</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkPipelineBindPoint</type>
        <name>pipelineBindPoint</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>startCounter</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>counterCount</name>
      </param>
      <param>
        <type>VkBuffer</type>
        <name>srcBuffer</name>
      </param>
      <param>
        <type>VkDeviceSize</type>
        <name>srcOffset</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdSaveAtomicCounters</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkPipelineBindPoint</type>
        <name>pipelineBindPoint</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>startCounter</name>
      </param>
      <param>
        <type>uint32_t</type>
        <name>counterCount</name>
      </param>
      <param>
        <type>VkBuffer</type>
        <name>destBuffer</name>
      </param>
      <param>
        <type>VkDeviceSize</type>
        <name>destOffset</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateFramebuffer</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkFramebufferCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkFramebuffer</type>* <name>pFramebuffer</name>
      </param>
    </command>
    <command>
      <proto>
        <type>VkResult</type>
        <name>vkCreateRenderPass</name>
      </proto>
      <param>
        <type>VkDevice</type>
        <name>device</name>
      </param>
      <param>
        const <type>VkRenderPassCreateInfo</type>* <name>pCreateInfo</name>
      </param>
      <param>
        <type>VkRenderPass</type>* <name>pRenderPass</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdBeginRenderPass</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        const <type>VkRenderPassBegin</type>* <name>pRenderPassBegin</name>
      </param>
    </command>
    <command>
      <proto>
        void <name>vkCmdEndRenderPass</name>
      </proto>
      <param>
        <type>VkCmdBuffer</type>
        <name>cmdBuffer</name>
      </param>
      <param>
        <type>VkRenderPass</type>
        <name>renderPass</name>
      </param>
    </command>
  </commands>

  <!-- SECTION: Vulkan API interface definitions -->
  <feature api="vulkan" name="VK_VERSION_1_0" number="1.0">
    <require comment="Header boilerplate">
      <type name="vk_platform"/>
    </require>
    <require comment="API constants">
      <enum name="VK_MAX_PHYSICAL_DEVICE_NAME"/>
      <enum name="VK_MAX_EXTENSION_NAME"/>
      <enum name="VK_LOD_CLAMP_NONE"/>
      <enum name="VK_LAST_MIP_LEVEL"/>
      <enum name="VK_LAST_ARRAY_SLICE"/>
      <enum name="VK_WHOLE_SIZE"/>
      <enum name="VK_TRUE"/>
      <enum name="VK_FALSE"/>
      <enum name="VK_NULL_HANDLE"/>
    </require>
    <require comment="Types not diretly used by the API">
      <!-- Include <type name="typename"/> here for e.g. structs that
                 are not parameter types of commands, but still need to be
                 defined in the API.
             -->
      <type name="VkBufferMemoryBarrier"/>
      <type name="VkCmdBufferGraphicsBeginInfo"/>
      <type name="VkDispatchIndirectCmd"/>
      <type name="VkDrawIndexedIndirectCmd"/>
      <type name="VkDrawIndirectCmd"/>
      <type name="VkExtensionProperties"/>
      <type name="VkFormatFeatureFlagBits"/>
      <type name="VkFormatProperties"/>
      <type name="VkImageMemoryBarrier"/>
      <type name="VkLayerCreateInfo"/>
      <type name="VkMemoryBarrier"/>
      <type name="VkMemoryInputFlagBits"/>
      <type name="VkMemoryOutputFlagBits"/>
      <type name="VkMemoryRequirements"/>
      <type name="VkPhysicalDeviceFeatures"/>
      <type name="VkPhysicalDeviceLimits"/>
      <type name="VkPhysicalDeviceMemoryProperties"/>
      <type name="VkPhysicalDeviceProperties"/>
      <type name="VkPhysicalDeviceQueueProperties"/>
      <type name="VkPhysicalDeviceType"/>
      <type name="VkQueueFlagBits"/>
      <type name="VkSubresourceLayout"/>
    </require>
    <require comment="Device initialization">
      <command name="vkCreateInstance"/>
      <command name="vkDestroyInstance"/>
      <command name="vkEnumeratePhysicalDevices"/>
      <command name="vkGetPhysicalDeviceFeatures"/>
      <command name="vkGetPhysicalDeviceFormatInfo"/>
      <command name="vkGetPhysicalDeviceLimits"/>
      <command name="vkGetPhysicalDeviceProperties"/>
      <command name="vkGetPhysicalDeviceQueueCount"/>
      <command name="vkGetPhysicalDeviceQueueProperties"/>
      <command name="vkGetPhysicalDeviceMemoryProperties"/>
      <command name="vkGetProcAddr"/>
    </require>
    <require comment="Device functions">
      <command name="vkCreateDevice"/>
      <command name="vkDestroyDevice"/>
    </require>
    <require comment="Extension discovery functions">
      <command name="vkGetGlobalExtensionCount"/>
      <command name="vkGetGlobalExtensionProperties"/>
      <command name="vkGetPhysicalDeviceExtensionCount"/>
      <command name="vkGetPhysicalDeviceExtensionProperties"/>
    </require>
    <require comment="Layer discovery functions">
      <command name="vkEnumerateLayers"/>
    </require>
    <require comment="Queue functions">
      <command name="vkGetDeviceQueue"/>
      <command name="vkQueueSubmit"/>
      <command name="vkQueueWaitIdle"/>
      <command name="vkDeviceWaitIdle"/>
    </require>
    <require comment="Memory functions">
      <command name="vkAllocMemory"/>
      <command name="vkFreeMemory"/>
      <command name="vkMapMemory"/>
      <command name="vkUnmapMemory"/>
      <command name="vkFlushMappedMemoryRanges"/>
      <command name="vkInvalidateMappedMemoryRanges"/>
    </require>
    <require comment="Generic API object functions">
      <command name="vkDestroyObject"/>
    </require>
    <require comment="Memory management API functions">
      <command name="vkBindObjectMemory"/>
      <command name="vkGetObjectMemoryRequirements"/>
    </require>
    <require comment="Sparse resource memory management API functions">
      <command name="vkQueueBindSparseBufferMemory"/>
      <command name="vkQueueBindSparseImageMemory"/>
    </require>
    <require comment="Fence functions">
      <command name="vkCreateFence"/>
      <command name="vkResetFences"/>
      <command name="vkGetFenceStatus"/>
      <command name="vkWaitForFences"/>
    </require>
    <require comment="Queue semaphore functions">
      <command name="vkCreateSemaphore"/>
      <command name="vkQueueSignalSemaphore"/>
      <command name="vkQueueWaitSemaphore"/>
    </require>
    <require comment="Event functions">
      <command name="vkCreateEvent"/>
      <command name="vkGetEventStatus"/>
      <command name="vkSetEvent"/>
      <command name="vkResetEvent"/>
    </require>
    <require comment="Query functions">
      <command name="vkCreateQueryPool"/>
      <command name="vkGetQueryPoolResults"/>
    </require>
    <require comment="Buffer functions">
      <command name="vkCreateBuffer"/>
    </require>
    <require comment="Buffer view functions">
      <command name="vkCreateBufferView"/>
    </require>
    <require comment="Image functions">
      <command name="vkCreateImage"/>
      <command name="vkGetImageSubresourceLayout"/>
    </require>
    <require comment="Image view functions">
      <command name="vkCreateImageView"/>
      <command name="vkCreateColorAttachmentView"/>
      <command name="vkCreateDepthStencilView"/>
    </require>
    <require comment="Shader functions">
      <command name="vkCreateShaderModule"/>
      <command name="vkCreateShader"/>
    </require>
    <require comment="Pipeline functions">
      <command name="vkCreateGraphicsPipeline"/>
      <command name="vkCreateGraphicsPipelineDerivative"/>
      <command name="vkCreateComputePipeline"/>
      <command name="vkStorePipeline"/>
      <command name="vkLoadPipeline"/>
      <command name="vkLoadPipelineDerivative"/>
    </require>
    <require comment="Pipeline layout functions">
      <command name="vkCreatePipelineLayout"/>
    </require>
    <require comment="Sampler functions">
      <command name="vkCreateSampler"/>
    </require>
    <require comment="Descriptor set functions">
      <command name="vkCreateDescriptorSetLayout"/>
      <command name="vkCreateDescriptorPool"/>
      <command name="vkResetDescriptorPool"/>
      <command name="vkAllocDescriptorSets"/>
      <command name="vkUpdateDescriptorSets"/>
    </require>
    <require comment="State object functions">
      <command name="vkCreateDynamicViewportState"/>
      <command name="vkCreateDynamicRasterState"/>
      <command name="vkCreateDynamicColorBlendState"/>
      <command name="vkCreateDynamicDepthStencilState"/>
    </require>
    <require comment="Command buffer functions">
      <command name="vkCreateCommandBuffer"/>
      <command name="vkBeginCommandBuffer"/>
      <command name="vkEndCommandBuffer"/>
      <command name="vkResetCommandBuffer"/>
    </require>
    <require comment="Command buffer building functions">
      <command name="vkCmdBindPipeline"/>
      <command name="vkCmdBindDynamicStateObject"/>
      <command name="vkCmdBindDescriptorSets"/>
      <command name="vkCmdBindIndexBuffer"/>
      <command name="vkCmdBindVertexBuffers"/>
      <command name="vkCmdDraw"/>
      <command name="vkCmdDrawIndexed"/>
      <command name="vkCmdDrawIndirect"/>
      <command name="vkCmdDrawIndexedIndirect"/>
      <command name="vkCmdDispatch"/>
      <command name="vkCmdDispatchIndirect"/>
      <command name="vkCmdCopyBuffer"/>
      <command name="vkCmdCopyImage"/>
      <command name="vkCmdBlitImage"/>
      <command name="vkCmdCopyBufferToImage"/>
      <command name="vkCmdCopyImageToBuffer"/>
      <command name="vkCmdUpdateBuffer"/>
      <command name="vkCmdFillBuffer"/>
      <command name="vkCmdClearColorImage"/>
      <command name="vkCmdClearDepthStencil"/>
      <command name="vkCmdResolveImage"/>
      <command name="vkCmdSetEvent"/>
      <command name="vkCmdResetEvent"/>
      <command name="vkCmdWaitEvents"/>
      <command name="vkCmdPipelineBarrier"/>
      <command name="vkCmdBeginQuery"/>
      <command name="vkCmdEndQuery"/>
      <command name="vkCmdResetQueryPool"/>
      <command name="vkCmdWriteTimestamp"/>
      <command name="vkCmdCopyQueryPoolResults"/>
      <command name="vkCmdInitAtomicCounters"/>
      <command name="vkCmdLoadAtomicCounters"/>
      <command name="vkCmdSaveAtomicCounters"/>
      <command name="vkCreateFramebuffer"/>
      <command name="vkCreateRenderPass"/>
      <command name="vkCmdBeginRenderPass"/>
      <command name="vkCmdEndRenderPass"/>
    </require>
  </feature>

  <!-- SECTION: Vulkan extension interface definitions (none yet) -->
</registry>